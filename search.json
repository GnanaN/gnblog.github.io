[{"title":"vue模拟抖音","url":"/2024/09/20/devlopment/vue模拟抖音/","content":"\n# 自适应调整页面-rem和vh/vw\n简介使用rem适应不同终端的变化，调整页面元素的大小。\n使用动态计算vh的目的是，因为移动端的地址栏的出现与消失会影响也页面视窗的高度即vh。因此需要动态计算。\n![图 2](../../images/b30f698c939f387b4d155527dbbb7caedde302d0603961edda5900857b147d00.png)\n\n> 核心问题是移动浏览器（Chrome 和 Safari）有一个“有用”的功能，地址栏有时可见，有时隐藏，从而改变视口的可见大小。这些浏览器并没有随着视口高度的变化而将高度调整100vh为屏幕的可见部分，而是将100vh地址栏设置为隐藏地址的浏览器高度。结果是，当地址栏可见时，屏幕的底部将被切断，从而违背了100vh最初的目的。\n>\n## rem\n\n`rem` 的值是根据根元素 `html` 字体大小的来计算的，即`1rem = html font-szie`，\n如果 `html` 元素没有指定字体大小，那么浏览器默认的字体大小是 `16px` ，所以 `1rem = 16px`\n如果 `html` 元素指定 `font-size: 1px` ，那么 `1rem = 1px`\n同理 `html` 元素指定 `font-size: 3px` ，那么 `1rem = 3px`\n同理 `html` 元素指定 `font-size: 1000000px` ，那么 `1rem = 1000000px`\n同理 `html` 元素指定 `font-size: 0.000001px` ，那么 `1rem = 0.000001px`\n\n### rem和em的区别\n`em` 是以父元素的字体大小来计算; `rem` 顾名思义,就是 `root` 的 `em`， 所以它是以`html`的字体大小来计算\n\n### 不同屏幕自适应\n不同用户的设备屏幕宽度不同，若每个用户对应的 `html` 元素 `font-size` 值相同的话，用户看到的显示效果也是不同的。\n\n可以用 `JavaScript` 来根据用户的屏幕宽度，动态更改 `html` 元素上的 `font-size` 值，从而使实际显示的内容比例始终保持不变，不同用户看到的效果也会保持一致。\n\n比如，设计稿的宽度为 `400px` ，里面显示了一个宽度为 `40px` 的盒子。某用户以 `800px` 宽度的设备来访问，看到的盒子宽度应该为 80px。那么此时在 `html` 元素的 `font-size` 值设置为 `2px` ，然后盒子的宽度采用 `rem` 单位，设置为 `40rem` ，那么就能显示出 `80px` 的盒子了。保持用户看到的和设计稿中的效果比例一致。\n\n所以，`html`元素的`font-size`计算公式为：\n\n```js\n// 用户设备宽度 / 设计稿标准宽度\ndocument.documentElement.style.fontSize = document.documentElement.clientWidth / 375 + 'px'\n```\n\n## vh\n`vh` 和 `vw` 都是相对于视窗的宽高度，“视窗”所指为浏览器内部的可视区域大小，即`window`.`innerWidth/window.innerHeight`大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。可以简单理解为屏幕百分比，`1vh` = 屏幕的1%\n\n### 移动端 100vh 显示 bug\n`vh` 在移动端的Chrome 和 Safari上会显示溢出 ，如下图\n\n![图 3](../../images/dfe61e8a9f2db576c92a9576390bdd330cb23112111c696ede216bd194d69844.png)\n\n当地址栏处于视图中时，元素底部被裁剪（右），但我们想要的是元素能完整的占据一屏（左）。\n造成这种现象的原因就在于移动端浏览器对于 vh 单位的计算，是不包含地址栏的，也就是说 100vh 的高度会使带有地址栏的视图溢出。\n\n### 解决方法\n使用 `window.innerHeight` 获取当前视窗的的高度，将高度按 `100` 份等分，得到视窗的单位高度, 然后通过 `js` 设置成一个 `css` 的变量 `--vh`。\n\n```js\ndocument.documentElement.style.setProperty('--vh', `${vh}px`)\n```\ncss中使用\n```js\n//表示100vh\nheight: calc(var(--vh, 1vh) * 100);\n\n//100vh - 60rem\nheight: calc(var(--vh, 1vh) * 100 - 60rem);\n```\n\n### 代码\n```js\nfunction resetVhAndPx() {\n  let vh = window.innerHeight * 0.01\n  document.documentElement.style.setProperty('--vh', `${vh}px`)\n  document.documentElement.style.fontSize = document.documentElement.clientWidth / 375 + 'px'\n}\n\nonMounted(() => {\n  resetVhAndPx()\n  // 监听resize事件 视图大小发生变化就重新计算1vh的值\n  window.addEventListener('resize',resetVhAndPx)\n})\n```\n\n\n# 实现原理\n无限滑动的原理和虚拟滚动的原理差不多，要保持 SlideList 里面永远只有 N 个 SlideItem，就要在滑动时不断的删除和增加 SlideItem。\n滑动时调整 SlideList 的偏移量 translateY 的值，以及列表里那几个 SlideItem 的 top 值，就可以了\n\n为什么要调整 SlideList 的偏移量 translateY 的值同时还要调整 SlideItem 的 top 值呢？\n因为 translateY 只是将整个列表移动，如果我们列表里面的元素是固定的，不会变多和减少，那么没关系，只调整　translateY 值就可以了，上滑了几页就减几页的高度，下滑同理\n\n但是如果整个列表向前移动了一页，同时前面的 SlideItem 也少了一个，，那么最终效果就是移动了两页...因为 塌陷 了一页\n这显然不是我们想要的，所以我们还需要同时调整 SlideItem 的 top 值，加上前面少的 SlideItem 的高度，这样才能显示出正常的内容\n","tags":["vue","抖音"],"categories":["开发","前端"]},{"title":"大文件续传","url":"/2024/09/20/devlopment/大文件续传/","content":"\n## 是什么\n- 针对问题：\n   在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。\n- 解决思路：\n  将这个请求拆分成多个请求，每个请求的时间就会缩短，且如果某个请求失败，只需要重新发送这一次请求即可，无需从头开始，这样是否可以解决大文件上传的问题呢？\n\n- 要求\n  - 支持拆分上传文件请求\n  - 支持断点续传\n  - 支持显示上传进度和暂定进度\n\n- 技术\n  - webWorker:\n  是一种在后台线程中运行脚本的技术，允许开发者在不阻塞用户界面的情况下执行复杂和耗时的任务。Web Worker 提供了一个独立的执行环境，与主线程（UI 线程）隔离开来，避免了长时间运行的脚本导致的页面卡顿。\n\n\n## 逻辑\n- 1、将上传的文件切片，并对每个切片标上记号，是哪个文件的切片是切片的那一部分（用hash实现标记）\n- 2、后端把成功的标记记录下来，上传每个文件时，都判断一下标记是否存在，如果存在不上传，如果存在就上传。\n- 3、后端对上传完整的文件切片进行拼接。\n\n## 细节\n### webworker 处理对文件的切片\n#### webWorker的特点\n- 独立线程：Web Worker 在独立的线程中运行，与主线程并行执行。\n- 无阻塞：由于在独立线程中运行，Web Worker 不会阻塞主线程的执行。\n- 通信机制：主线程和 Worker 线程之间通过消息传递（postMessage 和 onmessage）进行通信。\n- 受限环境：Worker 线程不能访问 DOM，也不能调用一些特定的 Web API，如 alert 和 localStorage。\n\n#### 基本用法\n- 监听消息事件\n```js\nself.addEventListener('message', async e => {\n  console.log(e)\n  const { file, chunkSize } = e.data\n  const fileChunkList = await createFileChunk(file, chunkSize)\n  await calculateChunksHash(fileChunkList)\n})\n```\n- 监听错误事件\n```js\nself.addEventListener('error', function (e) {\n  console.log(\"%cWorker 线程 error 监听事件: \", 'color: red', e)\n  // worker 线程关闭\n  self.close()\n})\n```\n#### 切片实现\n- 1、文件切片\n```js\n//第一个参数是file，第二个是切片大小\nfunction createFileChunk(file, chunkSize) {\n  // new Promise 的基本用法：来创建一个新的 Promise 对象,该函数有两个参数：resolve 和 reject。\n  //resolve 用于在异步操作成功时返回结果，reject 用于在异步操作失败时返回错误。\n  return new Promise(resolve => {\n    let fileChunkList = []\n    let cur = 0\n    while (cur < file.size) {\n      fileChunkList.push({ chunkFile: file.slice(cur, cur + chunkSize) })\n      cur += chunkSize\n    }\n    resolve(fileChunkList)\n  })\n}\n```\n\n#### 切片标记\n- 每个切片有自己的MD5哈希值，所有切片的哈希值保存在SparkMD5.ArrayBuffer 实例spark中，在切片完成后，spark值传递给fileHash，webWork将fileHash和fileChunkList文件切片传给了主线程。\n\n```js\n// 记载并计算文件切片的 md5\nasync function calculateChunksHash(fileChunkList = []) {\n  // 创建一个 SparkMD5.ArrayBuffer 实例，用于计算 MD5 哈希值。\n  const spark = new SparkMD5.ArrayBuffer()\n\n  // 计算切片进度\n  let percentage = 0\n\n  try {\n    const fileHash = await loadNext()\n    self.postMessage({ percentage: 100, fileHash, fileChunkList })\n    self.close()\n  } catch (err) {\n    self.postMessage({ name: 'error', data: err })\n    self.close()\n  }\n\n  // 递归函数，处理文件的切片\n  async function loadNext(index = 0) {\n    // 所有的切片都已处理完毕\n    if (index >= fileChunkList.length) {\n      // 返回这个文件的MD5哈希值\n      return spark.end()\n    }\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader()\n      reader.readAsArrayBuffer(fileChunkList[index].chunkFile)\n      reader.onload = (e) => {\n        spark.append(e.target.result)\n        percentage += 100 / fileChunkList.length\n        self.postMessage({\n          percentage\n        })\n        resolve(loadNext(index + 1))\n      }\n      reader.onerror = (err) => reject(err)\n    })\n  }\n}\n```\n\n\n### 主线程任务\n- 该方法能依次上传多个文件。\n- 切片大小设置为5MB\n- 多个文件输入处理逻辑：\n  - 如果输入框有change事件，判断是否有文件传入，如果有将每个文件进行切片处理，并上传\n  - 对每个文件绑定响应式对象，对象包括文件名、文件大小、文件状态、***所有需要上传的切片***、文件hash、最大报错次数、上传进度等属性。\n  - 根据文件的状态来确定，当前文件需要进行的流程。\n  - 需要切片上传的文件，交给webworker切片，并将结果返回。作为参数传给开始上传函数\n  - **多个文件并行上传**\n- 开始上传文件的逻辑：\n  - 需要参数，file，inTaskArrItem（初始化的一个对象，包含单个文件的属性）， fileChunkList（单个文件的切片）\n  - 判断文件是否已经存在于服务器，如果存在直接return，如果不存在执行上传的逻辑\n  - 将每个切片的信息写入inTaskArrItem的allChunList（***所有需要上传的切片***）中\n  - 对allChunkList进行过滤，过滤掉已经上传成功的切片（判断是否上传成功，由checkfile函数完成）\n  - 如果没有需要上传的切片，但是前面判断服务器中没有此文件，说明需要合并，再次执行文件合并函数\n- 每一个文件的处理逻辑\n  - 如果没有需要上传的切片或者状态为正在被上传，不做处理\n  - 找出需要上传的文件，并将入待处理文件的列表中。根据列表长度计算每个文件的并发请求数量。（chrome浏览器同域名同一时间请求的最大并发数限制为 6，如果有三个文件需要上传，那么每个文件上传只能同时并发2个请求）\n  - 从需要上传的切片尾部拿2个切片，放入请求数组中。并将其从allChunkList中删除\n  - 开始上传切片\n- 切片上传逻辑\n  - 首先判断文件状态，如果文件状态为暂停或终端就什么都不错\n  - 每个切片由三次机会，如果三次都失败，则文件上传失败","tags":["大文件续传"],"categories":["性能优化"]},{"title":"图片懒加载","url":"/2024/09/20/devlopment/图片懒加载/","content":"\n# 图片懒加载\n## 简介\n- 图片懒加载是一种前端性能优化技术，它通过延迟非关键资源（如图片）的加载时机，直到这些资源即将被用户看到内或者经过一定的延迟后，才开始加载，从而减少初次页面加载的时间和数据使用量，提高用户体验。\n- 本文总结的图片懒加载技术依赖vue，并将其封装为一个插件\n- 支持组件可见或即将可见时懒加载\n- 支持加载真实组件前展示骨架组件，提高用户体验\n\n## 涉及的属性\n### 非响应式\n1.timeout:\n- 类型：Number\n- 作用：指定延迟加载的时间（以毫秒为单位）。如果设置了这个属性，组件将在指定时间后初始化。\n\n2、tagName:\n- 类型：String\n- 默认值：'div'\n- 作用：指定包裹内容的 HTML 标签名称。默认是 div，可以根据需要更改为其他标签。\n\n3、viewport:\n- 类型：HTMLElement 或 Object\n- 默认值：null\n- 作用：指定视口元素，用于 IntersectionObserver。如果没有指定，默认是 null，表示使用浏览器的视口。\n\n4、threshold:\n- 类型：String\n- 默认值：'0px'\n- 作用：指定触发懒加载的阈值。可以设置为像素值或百分比，例如 '100px' 或 '50%'。\n\n5、direction:\n- 类型：String\n- 默认值：'vertical'\n- 作用：指定滚动方向。可以是 'vertical'（垂直方向）或 'horizontal'（水平方向）。\n\n6、maxWaitingTime:\n- 类型：Number\n- 默认值：50\n- 作用：指定最大等待时间（以毫秒为单位），用于 requestAnimationFrame 回调，防止主线程卡顿。\n\n这些属性允许用户在使用 VueLazyComponent 时进行灵活配置，以满足不同的需求。\n\n### 响应式\n1、isInit:\n- 类型：Boolean\n- 默认值：false\n- 作用：表示组件是否已经初始化。当组件完成初始化时，这个值会被设置为 true。\n\n2、timer:\n- 类型：null 或 Number\n- 默认值：null\n- 作用：用于存储定时器的引用。如果设置了 timeout 属性，组件会在指定时间后初始化，这个定时器用于实现这个功能。\n\n3、io:\n- 类型：null 或 IntersectionObserver\n- 默认值：null\n- 作用：用于存储 IntersectionObserver 的实例。IntersectionObserver 用于检测组件是否进入视口，以便延迟加载内容。\n\n4、loading:\n- 类型：Boolean\n- 默认值：false\n- 作用：表示组件是否正在加载内容。当组件开始加载内容时，这个值会被设置为 true。\n\n这些数据属性用于管理组件的状态和行为。通过响应式的数据属性，Vue.js 可以在数据变化时自动更新视图，从而实现动态和交互式的用户界面。\n\n\n## 功能详解\n### 懒加载内容\n- IntersectionObserver是浏览器内置API，用于异步观察一个目标元素与其祖先元素或顶级文档视口（viewport）交叉状态的变化。它可以用于实现懒加载、无限滚动、广告曝光监测等功能。\n- IntersectionObserver 构造函数用于创建一个新的 IntersectionObserver 实例。它接受两个参数：\n\n  - 回调函数（callback）：当目标元素的可见性发生变化时，这个回调函数会被调用。\n  - 选项对象（options）：用于配置 IntersectionObserver 的行为。\n    可选参数，用于配置 IntersectionObserver 的行为。包含以下属性：\n    - root：指定用作视口的元素，必须是目标元素的祖先元素。默认是浏览器的视口。\n    - rootMargin：用于扩展或缩小 root 元素的边界，类似于 CSS 的 margin 属性。可以使用像素值或百分比。\n    - threshold：一个数值或数值数组，表示目标元素的可见比例达到这些值时，回调函数会被触发。\n\n\n\n### 骨架展示\n模板中的条件渲染：\n- 使用 v-if 和 v-else-if 指令根据 isInit 状态渲染实际内容或骨架屏。\n- isInit 为 false 时显示骨架屏，为 true 时显示实际内容。\n\n```js\n<template>\n  <transition-group :tag=\"tagName\" name=\"lazy-component\" style=\"position: relative;\"\n    @before-enter=\"(el) => $emit('before-enter', el)\"\n    @before-leave=\"(el) => $emit('before-leave', el)\"\n    @after-enter=\"(el) => $emit('after-enter', el)\"\n    @after-leave=\"(el) => $emit('after-leave', el)\"\n  >\n    <div v-if=\"isInit\" key=\"component\">\n      <slot :loading=\"loading\"></slot>\n    </div>\n    <div v-else-if=\"$slots.skeleton\" key=\"skeleton\">\n      <slot name=\"skeleton\"></slot>\n    </div>\n    <div v-else key=\"loading\">\n    </div>\n  </transition-group>\n</template>\n```\n\n### 过渡动画\ntransition-group：\n- 使用 transition-group 包裹内容，实现内容切换时的过渡动画。\n- 通过 @before-enter、@before-leave、@after-enter 和 @after-leave 事件触发父组件的相应事件。\n\n\n### 事件通知\n在组件生命周期的不同阶段触发事件，通知父组件。\n\n\n## 逻辑\n- **首先搞清楚，这里的懒加载是指以显示骨架内容代替真实数据，，等到有需要的时候再加载真实数据。**\n\n- 在视口加载和超过设定时长自动加载，两者通过timeout属性决定，timeout为true使用延时加载，否则使用视口加载模式\n\n- **初始化是指加载真实数据的组件，即将loading指改为true。**\n\n- 在挂载时，如果timeout值为加假，说明要使用视口交叉来懒加载图片。需要初始化视口交叉监视API：IntersectionObserver\n\n- 在创建阶段，如果指定timeout则无论可见与否都是在timeout之后初始化\n\n- 销毁：在组件销毁前取消观察\n\n- 然后这里还定义了一些自定义函数，供插件使用者监听组件的状况。","tags":["图片懒加载"],"categories":["性能优化"]},{"title":"面试算法题","url":"/2024/09/18/algrithm/面试手撕前端/","content":"\n","categories":["前端"]},{"title":"面试算法题","url":"/2024/09/10/algrithm/前端面试算法题汇总/","content":"\n# 双指针系列\n## 合并两个有序数组\n![图 0](../../images/3d3e5dce452c7bb545719640281a0488bc37105ab9889359c9d9d79c194c9184.png)\n\n### 解决思路\n逆向双指针，从后往前比较两个数组的元素大小。大的填入应在的位置，然后指针前移，小的不作操作。\n\n\n### 代码\n```js\n// 逆向双指针的方法\nvar merge = function(nums1, m, nums2, n) {\n  let p1 = m-1,p2 = n-1,p = m+n-1  //三个指针，第一个用来遍历数组1中的每个值。\n  //第二个用来遍历数组2中的每一个值，第三个用来存数据，从数组1的最后一个位置开始。\n  while(p1>=0 && p2>=0){ // 双指针，从两个数组的最后一个数开始，倒着比较值的大小。\n    if (nums2[p2]>=nums1[p1]){\n      nums1[p] = nums2[p2]\n      p2--\n    }\n    else{\n      nums1[p] = nums1[p1]\n      p1--\n    }\n    p--\n  }\n  while(p2>=0){//如果数组2中还有剩余的元素，全部放在数组1的前面\n    nums1[p] = nums2[p2]\n    p2--\n    p--\n  }\n};\n```\n## 最长无重复子串\n![图 5](../../images/e1ca3a01738ca9738272adeefd50a1c7cddc915bbd5b141ab5e64808c2806e96.png)\n\n### 解题思路\n滑动窗口\n- 1、使用left和right两个指针，分别表示滑动窗口的左右边界，初始时都指向字符串的开头。\n- 2、使用一个哈希表（或者数组）来记录字符是否出现过以及字符出现的位置。\n- 3、不断移动右指针 right，每次移动时判断当前字符是否出现过：\n  * 如果当前字符已经出现过，并且在当前窗口内（即其位置大于等于 left），则更新 left 指针的位置为该字符上次出现的位置的下一个位置。\n  * 如果当前字符没有出现过，或者虽然出现过但不在当前窗口内，则更新最长子字符串的长度。\n- 不断更新最长子字符串的长度，并返回结果。\n### 代码\n```js\nvar lengthOfLongestSubstring = function(s) {\n  let l=0,r=0,max=0\n  let map = new Map()\n  while(r<s.length){\n    //判断map的记录中，这个字符的值是否在滑动窗口内\n    if (map.has(s[r]) && map.get(s[r]) >= l) {\n      //如果在窗口内l指针指向当前记录值的后一位\n      l = map.get(s[r])+1\n    }\n    //如果map中没有当前字符得记录或者有记录但是不在滑动窗口范围内\n    map.set(s[r], r)\n    max = Math.max(max, r - l + 1)\n    r++\n  }\n  return max\n}\n```\n\n## 判断子序列\n![图 6](../../images/a9479004f8982e479db91a305f90eb315c0bb64d5e8d87b28a7b71b2d90f59a3.png)\n\n### 解题思路\n- 初始化指针i，j分别指向字符串是，和t的起始位置；其中s是子串，t是较长的字符串\n- 遍历比较s[i]和t[j]的情况\n  * 如果s[i]==t[j]，那么指向子串的指针+1，即i++；且j++\n  * 如果不想等j++\n- 判断子序列：如果 i 移动到了 s 的末尾，则说明 s 是 t 的子序列，返回 true；否则返回 false。\n### 代码\n```js\nvar isSubsequence = function(s, t) {\n  let i=0,j=0\n  //处理两个字符串都是空字符串的情况\n  if (s==t) return true\n  while (j<t.length){\n    if (s[i]===t[j]) i++\n    j++\n  }\n  if (i==s.length) return true\n  else return false\n};\n```\n\n## 两数之和\n![图 1](../../images/f10b6a6f2ce89f0b2941de25cdfed619ce0d7bdd16dd9b8a4722361cfbfb3386.png)\n\n### 解题思路\n使用字典,判断目标值减去当前值的结果是否，存在于字典中。\n\n### 代码\n\n```js\nvar twoSum = function(nums, target) {\n  let map = new Map()\n  // 判断target-当前元素的结果是否存在于map中，如果存在返回下标\n  for (let i=0;i<nums.length;i++){\n    if (map.has(target-nums[i])){\n      return [map.get(target-nums[i]),i]\n    }\n    //如果不存在，设置当前元素为键，当前元素下表为值\n    else{\n      map.set(nums[i],i)\n    }\n  }\n}\n```\n\n## 三数之和\n![图 2](../../images/1c543bade55ef7ba85f6117d46e6537cfc3df2a27b79572cd379ac4343cfd13b.png)\n\n### 解决思路回溯算法：\n1、回溯的三部曲，参数确定，确定终止条件，单层递归逻辑。提升效率要剪枝\n2、双指针法：对数组进行排序，先确定第一个数字，然后使用双指针分别总数组的第一个和第最后一个开始，判断当前总和，综合大，右边指针前移，否者左边指针后移。\n\n去重逻辑：第一个数字的去重，和后面两个数字的去重。\n\n### 代码\n```js\nvar threeSum = function (nums) {\n  let res = []\n  nums = nums.sort((a,b)=>a-b) //首先要进行排序\n  for (let i = 0; i < nums.length-2; i++) {  //减2是因为求得是三个元素的和。\n    if (i > 0 && nums[i] == nums[i - 1]) continue //a去重\n    let left = i + 1,right = nums.length - 1 //指定双指针\n    while (left < right) {\n      let sum = nums[i]+nums[left]+nums[right]\n      if (sum>0) right--\n      if (sum<0) left++\n      if(sum===0){\n        res.push([nums[i],nums[left],nums[right]])\n        //后两个数去重逻辑，如果指针指向下一个元素与当前相同，跳过该元素\n        while(left<right && nums[left] === nums[left+1]) left++\n        while(left<right && nums[right] === nums[right-1]) right--\n        left++     //忘记调整这两个了\n        right--\n      }\n    }\n  }\n  return res\n}\n```\n\n## 反转链表\n![图 3](../../images/d918ce4ff18b67517cae8e2925b5c7841d9afeea292f7de999c24b7bc9c635ce.png)\n\n### 自定义链表\n\n### 解题代码\n```js\nvar reverseList = function(head) {\n  let prev = null\n  let cur = head\n  while(cur){\n    // 这一步我忘记了，没有把next的值保存下来，直接给cur.next赋值了\n    const next = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n  }\n  return prev //最后一个cur是null，他前面一个才是第一个有值的节点\n};\n```\n\n\n## 排序算法\n### 快速排序\n其核心思想是分治，选择一个基准元素，将比基准小的元素放在左边，比基准大的元素放在右边。然后地柜对左右两个部分，分别进行快速排序。\n\n快速排序复杂度\n平均时间复杂度（Onlogn）、最坏情况O(n^2)\n\n```js\nfunction quickSort(arr) {\n  //终止条件\n  if (arr.length <= 1) return arr\n  //找基准,选择最后一个元素作为基准\n  let std = arr.length - 1\n  //用来存储左右两个数组\n  let leftArr = [],\n    rightArr = []\n  for (let i = 0; i < std && i != std; i++) {\n    if (arr[i] <= arr[std]) leftArr.push(arr[i])\n    else rightArr.push(arr[i])\n  }\n  //分别处理左右两个子数组\n  return [...quickSort(leftArr), arr[std], ...quickSort(rightArr)]\n}\nconsole.log(quickSort([5, 2, 9, 1, 7, 6,3,80,34]))\n```\n\n### 选择排序\n选择最大的数，放在数组的最右边，然后再选择第二大的数，放在数组的右边第二的位置，以此类推。\n\n选择排序复杂度\n平均时间复杂度（Onlogn）、最坏情况O(n^2)\n\n```js\nfunction selectSort(arr){\n  const n = arr.length-1\n  // 从后往前排好arr的顺序，所以遍历从后往前\n  for (let i=n;i>0;i--){\n    let maxIndex = i\n    // 将没排好序的过一遍\n    for (let j=0;j<=i;j++){\n      if (arr[j]>arr[maxIndex]) maxIndex = j\n    }\n    if (maxIndex != i){\n      [arr[maxIndex],arr[i]] = [arr[i],arr[maxIndex]]\n    }\n  }\n  return arr\n}\n```\n\n### 冒泡排序\n冒泡排序通过重复遍历要排序的列表，每次比较相邻的两个元素。如果顺序不正确，就交换它们的位置。这个过程会重复直到整个列表有序。\n\n每一轮遍历会将一个最大的元素“冒泡”到末尾。\n\n复杂度：时间复杂度：O(n²)\n\n```js\nfunction populeSort(arr){\n  let len = arr.length-1\n  for(let i=0;i<len;i++){\n    // 每一轮遍历都会将一个最大的元素“冒泡”到末尾，所以下一轮遍历就不用再遍历最后一个元素\n    for(let j=0;j<len-1;j++){\n      if(arr[j]>arr[j+1]) [arr[j],arr[j+1]] = [arr[j+1],arr[j]]\n    }\n  }\n  return arr\n}\n```\n### 插入排序\n插入排序将数组划分为已排序和未排序部分，从未排序部分取出元素，并将其插入到已排序部分的适当位置。这个过程会反复执行，直到所有元素都被插入到正确的位置。\n\n复杂度：时间复杂度：O(n²)  最好情况（数组本身有序）：O(n)\n\n```js\nfunction insertSort(arr){\n  //有序无序两部分，从无序的数据中一次拿数据，插入到有序部分\n  let len = arr.length\n  // 第一个元素是有序部分，从第二个数据开始拿数据\n  for(let i=1;i<len;i++){\n    let curr = arr[i]\n    let j=i-1\n    //从有序数据的后面开始往前遍历，直到找到合适插入的位置\n    while(j>=0 && curr<arr[j]){\n      // 给将来要插入元素的地方腾位置\n      arr[j+1] = arr[j]\n      j--\n    }\n    arr[j+1] = curr\n  }\n  return arr\n}\n```\n\n### 归并排序\n归并排序是另一种分治算法，它将数组递归地拆分为两个子数组，直到每个子数组只有一个元素。然后将这些子数组有序地合并，直到所有元素合并成一个有序数组。\n\n归并排序是一种稳定排序，而且它的最坏情况复杂度和平均复杂度都是 O(n log n)。\n\n```js\nfunction mergeSort(arr){\n  //终止条件，就是arr长度\n  if (arr.length<=1) return arr\n  //首先将数组分为二部分\n  let mid = Math.floor(arr.length/2)\n  let leftArr = arr.slice(0,mid)\n  let rightArr = arr.slice(mid)\n  return merge(mergeSort(leftArr),mergeSort(rightArr))\n}\n\nfunction merge(left,right){\n  let result =[]\n  let i=0,j=0\n  while(i<left.length && j<right.length){\n    if (left[i]<right[j]){\n      result.push(left[i])\n      i++\n    }\n    else{\n      result.push(right[j])\n      j++\n    }\n  }\n  return result.concat(left.slice(i)).concat(right.slice(j))\n}\n```\n\n### 堆排序\n堆排序利用了堆这种数据结构。堆是一种特殊的完全二叉树，分为大顶堆和小顶堆。堆排序的核心思想是：首先将数组构造成一个最大堆，然后依次将堆顶元素（最大值）与最后一个元素交换，再将剩下的元素重新调整为堆，直到排序完成。\n\n复杂度：时间复杂度：O(n log n)\n\n\n\n## 二叉树系列\n### 层序遍历\n\n### 前序遍历\n#### 递归法\n```js\nvar preorderTraversal = function (root) {\n  const res = []\n  const preorder = (rt)=>{\n    if (!rt) return\n    res.push(rt.val)\n    preorder(rt.left)\n    preorder(rt.right)\n  }\n  preorder(root)\n  return res\n}\n```\n\n#### 迭代法\n```js\nvar preorderTraversal = function (root) {\n  let res = []\n  if (!root) return res   // 应对空二叉树\n  let queue = [root]\n  while(queue.length){\n    //每次从队列里去一个节点，把该节点的值添加到result，\n    let cur = queue.pop()\n    res.push(cur.val) //该节点的右孩子和左孩子依次加入节点，\n    if (cur.right) queue.push(cur.right) //等到下一轮，就会分别依次遍历左孩子和有孩子了\n    if (cur.left) queue.push(cur.left)\n  }\nreturn res\n}\n```\n\n### 后序遍历\n#### 递归法\n```js\nvar postorderTraversal = function (root) {\n  let res = []\n  const postorder = (rt) => {\n    if (!rt) return    //不要忘了这个条件\n    postorder(rt.left)\n    postorder(rt.right)\n    res.push(rt.val)\n  }\n  postorder(root)\n  return res\n}\n```\n\n#### 迭代法\n```js\n\n```\n### 中序遍历\n#### 递归法\n```js\nvar inorderTraversal = function (root) {\n  let res =[]\n  const inorder = (rt)=>{\n    if (!rt) return\n    rt.left && inorder(rt.left)\n    res.push(rt.val)\n    rt.right && inorder(rt.right)\n  }\n  inorder(root)\n  return res\n}\n```\n#### 迭代法\n```js\nvar inorderTraversal = function (root) {\n  // 入栈:左->右\n  // 出栈:左 中 右\n  let res = []\n  const stack = []\n  if (root) stack.push(root)\n  while (stack.length) {\n    const node = stack.pop()\n    if (!node) {\n      res.push(stack.pop().val)\n      continue\n    }\n    if (node.right) stack.push(node.right) // 右\n    stack.push(node) // 中\n    stack.push(null)\n    if (node.left) stack.push(node.left) // 左\n  }\n  return res\n}\n```","categories":["算法"]},{"title":"面试算法题","url":"/2024/09/10/interview/promiseall实现/","content":"\n# promise\n## 是什么\n`Promise` 是用于处理异步操作的对象。它有三种状态：`pending`（进行中）、`fulfilled`（已成功）和 `rejected`（已失败）。我们可以手写一个简化版的 `Promise`，实现其基本功能。\n\n实现思路：\n`Promise` 构造函数接收一个执行器函数，该函数有两个参数 `resolve` 和 `reject`，用于改变 `Promise` 的状态。\n`then` 方法用于注册回调函数，在 `Promise`的状态改变后执行。\n使用状态机来管理 `pending`、`fulfilled` 和 `rejected` 状态。\n\n## 实现\n```js\nclass MyPromise {hexp\n  constructor(executor) {\n    this.state = 'pending';   // 初始状态\n    this.value = undefined;    // 成功的值\n    this.reason = undefined;   // 失败的原因\n    this.onFulfilledCallbacks = []; // 存储成功回调\n    this.onRejectedCallbacks = [];  // 存储失败回调\n\n    // resolve 函数\n    const resolve = (value) => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';   // 状态转为 fulfilled\n        this.value = value;         // 传递成功的值\n        this.onFulfilledCallbacks.forEach(fn => fn(this.value)); // 执行成功回调\n      }\n    };\n\n    // reject 函数\n    const reject = (reason) => {\n      if (this.state === 'pending') {\n        this.state = 'rejected';   // 状态转为 rejected\n        this.reason = reason;      // 传递失败的原因\n        this.onRejectedCallbacks.forEach(fn => fn(this.reason)); // 执行失败回调\n      }\n    };\n\n    // 执行 executor，并捕获异常\n    try {\n      executor(resolve, reject);\n    } catch (error) {\n      reject(error);\n    }\n  }\n\n  // then 方法\n  then(onFulfilled, onRejected) {\n    // 如果 `onFulfilled` 不是函数，默认返回 value\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    // 如果 `onRejected` 不是函数，默认抛出 reason\n    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };\n\n    if (this.state === 'fulfilled') {\n      onFulfilled(this.value);\n    }\n\n    if (this.state === 'rejected') {\n      onRejected(this.reason);\n    }\n\n    if (this.state === 'pending') {\n      this.onFulfilledCallbacks.push(onFulfilled);\n      this.onRejectedCallbacks.push(onRejected);\n    }\n  }\n}\n\n// 测试 MyPromise\nconst promise = new MyPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('Success!');\n  }, 1000);\n});\n\npromise.then(\n  value => console.log('Fulfilled:', value),\n  reason => console.log('Rejected:', reason)\n);\n\n```\n\n# promise.all\n## 是什么\nPromise.all() 是一个用于并行处理多个 Promise 的方法，它接受一个包含多个 Promise 的可迭代对象，并返回一个新的 Promise。只有当所有 Promise 都成功时，这个新的 Promise 才会 resolve；如果其中任何一个 Promise 失败，Promise.all() 就会 reject，并返回第一个失败的 Promise 的原因。\n\n## 实现\n```js\n// promise.all\nfunction promiseAll(promises){\n  return new Promise((resolve,reject)=>{\n    if(!Array.isArray(promises)) return reject(new TypeError('参数类型应该为数组'))\n    if (promises.length==0) return resolve([])\n    let resultArr = []\n    let completedPromises = 0\n    promises.forEach((promise,index)=>{\n      Promise.resolve(promise)\n      .then(result=>{\n        resultArr[index] = result\n        completedPromises ++\n        if (completedPromises==promises.length) resolve(resultArr)\n      })\n      .catch(error=> reject(error))\n    })\n  })\n}\n// 示例\nconst p1 = Promise.resolve(3)\nconst p2 = new Promise((resolve) => setTimeout(resolve, 1000, 'foo'))\nconst p3 = Promise.resolve(42)\n\npromiseAll([p1, p2, p3])\n  .then((results) => console.log(results)) // 输出 [3, \"foo\", 42]\n  .catch((err) => console.log(err))\n```\n\n# promise.race\n## 是什么\nPromise.race() 方法会返回一个新的 Promise，一旦传入的 Promise 中有一个完成（无论是 resolved 还是 rejected），就会立即以那个 Promise 的结果（resolved 或 rejected）进行决议。\n\n## 实现\n```js\nfunction promiseRace(promises) {\n  return new Promise((resolve, reject) => {\n    if (!Array.isArray(promises)) {\n      return reject(new TypeError('Argument must be an array'));\n    }\n\n    // 如果传入的数组为空，Promise 将永远不会 resolve 或 reject\n    if (promises.length === 0) {\n      return;  // 不返回任何内容，Promise 将保持 pending 状态\n    }\n\n    // 遍历每个 Promise\n    promises.forEach(promise => {\n      // 使用 Promise.resolve 将所有项处理为 Promise\n      Promise.resolve(promise)\n        .then(resolve)   // 一旦某个 Promise resolve，立即 resolve 结果\n        .catch(reject);  // 一旦某个 Promise reject，立即 reject 错误\n    });\n  });\n}\n\n// 示例\nconst p1 = new Promise((resolve) => setTimeout(resolve, 500, \"First\"));\nconst p2 = new Promise((resolve) => setTimeout(resolve, 100, \"Second\"));\nconst p3 = new Promise((resolve, reject) => setTimeout(reject, 200, \"Error\"));\n\npromiseRace([p1, p2, p3])\n  .then(result => console.log(result))  // 输出 \"Second\" 因为 p2 最先完成\n  .catch(err => console.log(err));\n```\n\n","tags":["promise"],"categories":["面试","手撕"]},{"title":"面试算法题","url":"/2024/09/10/interview/缓存/","content":"\n# web缓存\n## 是什么\n* web缓存有两部分：浏览器缓存和http缓存\n  * 浏览器缓存比如:localStorage、sessionStorage、cookies等。用于缓存一些必要数据，用户信息、需要携带到后端的参数、一些列表数据。\n\n  * 存储大小有限制localStorage、sessionStorage有5M，cookies大概4kb\n\n* http缓存\n> 官方介绍:Web 缓存是可以自动保存常见文档副本的 HTTP 设备。当 Web 请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这 个文档。\n* 客户端发起请求http请求，服务器需要处理http的请求，并且http去传输数据，需要带宽，带宽是要钱买的啊。而我们缓存，就是为了让服务器不去处理这个请求，客户端也可以拿到数据。\n\n* 一般缓存静态资源html，css，img，动态资源实时性强不适合缓存\n\n## 解决的问题与优缺点\n* 减少不必要的网络传输，节省带宽。\n* 更快加载页面\n* 减少服务器负担，避免服务器过载\n\n实际场景：\n> 其实日常的开发中，我们最最最最关心的，还是\"更快的加载页面\";尤其是对于react/vue等SPA（单页面）应用来说，首屏加载是老生常谈的问题。这个时候，缓存就显得非常重要。不需要往后端请求，直接在缓存中读取。速度上，会有显著的提升。是一种提升网站性能与用户体验的有效策略。\n\n### 知识扩展\n* 单页Web应用（single page web application，SPA），整个应用在初次加载时加载一个包含必要资源的HTML页面，之后所有的页面内容变化都是通过JavaScript动态更新DOM来实现，不需要重新加载整个页面。\n* 多页面应用，每次用户导航到新的页面时，都需要从服务器加载一个新的HTML页面。\n\n![图 0](../../images/1e8b8331c7b87dfb6bc09e6545d002b0550019c924a4f157bcc4d7200c303ff1.png)\n\n\n## 强缓存和协商缓存\n![图 2](../../images/831596a7469b0f37b09cb9e8c383b869f7eb019a8b0c868fed13afdc225848b3.png)\n### 强缓存\n从强制缓存的角度触发，如果浏览器判断请求的目标资源有效命中强缓存，如果命中，则可以直接从内存中读取目标资源，无需与服务器做任何通讯。\n\nCache-control的使用方法页很简单，只要在资源的响应头上写上需要缓存多久就好了，单位是秒。比如\n在响应头中Cache-Control:'max-age=10'\n\nCache-Control:max-age=N，N就是需要缓存的秒数。从第一次请求资源的时候开始，往后N秒内，资源若再次请求，则直接从磁盘（或内存中读取），不与服务器做任何交互。\n\n* Cache-control有max-age、s-maxage、no-cache、no-store、private、public这六个属性。\n  * max-age决定客户端资源被缓存多久。\n  * s-maxage决定代理服务器缓存的时长。\n  * no-cache表示是强制进行协商缓存。\n  * no-store是表示禁止任何缓存策略。\n  * public表示资源即可以被浏览器缓存也可以被代理服务器缓存。\n  * private表示资源只能被浏览器缓存。\n> **注意**，no-cache和no-store是一组互斥属性，这两个属性不能同时出现在Cache-Control中。\n> **注意**，public和private也是一组互斥属性。他们两个不能同时出现在响应头的cache-control字段中。\n> **注意**，max-age和s-maxage并不互斥。他们可以一起使用。\n\n### 协商缓存\n* 基于last-modified的协商缓存\n  基于last-modified的协商缓存实现方式是:\n    1、首先需要在服务器端读出文件修改时间，\n    2、将读出来的修改时间赋给响应头的last-modified字段。\n    3、最后设置Cache-control:no-cache\n\n![图 3](../../images/f2f3f2882a03a286ddbd4a9445bbef6ae64e47c1d61a78ab8bc13b0711b1320e.png)\n\n注意圈出来的三行。\n第一行，读出修改时间。\n第二行，给该资源响应头的last-modified字段赋值修改时间\n第三行，给该资源响应头的Cache-Control字段值设置为:no-cache.(上文有介绍，Cache-control:no-cache的意思是跳过强缓存校验，直接进行协商缓存。)\n还没完。到这里还无法实现协商缓存\n当客户端读取到last-modified的时候，会在下次的请求标头中携带一个字段:If-Modified-Since。\n\n![图 4](../../images/7de631787542393fe638a9278f0b10ce3be4276b601af4ae9de9eaec9450e1f9.png)\n\n那么之后每次对该资源的请求，都会带上If-Modified-Since这个字段，而务端就需要拿到这个时间并再次读取该资源的修改时间，让他们两个做一个比对来决定是读取缓存还是返回新的资源。\n\n![图 5](../../images/3cfc6a17b68e817c941879a3e453300f62729b5fb9ccbb04697e9cad228a044c.png)\n\n使用以上方式的协商缓存已经存在两个非常明显的漏洞。这两个漏洞都是基于文件是通过比较修改时间来判断是否更改而产生的。\n\n1.因为是更具文件修改时间来判断的，所以，在文件内容本身不修改的情况下，依然有可能更新文件修改时间（比如修改文件名再改回来），这样，就有可能文件内容明明没有修改，但是缓存依然失效了。\n\n2.当文件在极短时间内完成修改的时候（比如几百毫秒）。因为文件修改时间记录的最小单位是秒，所以，如果文件在几百毫秒内完成修改的话，文件修改时间不会改变，这样，即使文件内容修改了，依然不会 返回新的文件。\n\n为了解决上述的这两个问题。从`http1.1`开始新增了一个头信息，`ETag`(`Entity` 实体标签)\n\n基础ETag的协商缓存\n不用太担心，如果你已经理解了上面比较时间戳形式的协商缓存的话，ETag对你来说不会有难度。\n\nETag就是将原先协商缓存的比较时间戳的形式修改成了比较文件指纹。\n\n> 文件指纹:根据文件内容计算出的唯一哈希值。文件内容一旦改变则指纹改变。\n\n1.第一次请求某资源的时候，服务端读取文件并计算出文件指纹，将文件指纹放在响应头的etag字段中跟资源一起返回给客户端。\n\n2.第二次请求某资源的时候，客户端自动从缓存中读取出上一次服务端返回的ETag也就是文件指纹。并赋给请求头的`if-None-Match`字段，让上一次的文件指纹跟随请求一起回到服务端。\n\n3.服务端拿到请求头中的`is-None-Match`字段值（也就是上一次的文件指纹），并再次读取目标资源并生成文件指纹，两个指纹做对比。如果两个文件指纹完全吻合，说明文件没有被改变，则直接返回304状态码和一个空的响应体并`return`。如果两个文件指纹不吻合，则说明文件被更改，那么将新的文件指纹重新存储到响应头的`ETag`中并返回给客户端\n\n","tags":["缓存"],"categories":["面试"]},{"title":"单调栈","url":"/2024/07/25/algrithm/单调栈/","content":"\n# 单调栈\n## 何时用单调栈\n通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。时间复杂度为O(n)。如果暴力破解复杂度为O(n^2)。\n\n##\n那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？\n\n单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。\n\n更直白来说，就是用一个栈来记录我们遍历过的元素，因为我们遍历数组的时候，我们不知道之前都遍历了哪些元素，以至于遍历一个元素找不到是不是之前遍历过一个更小的，所以我们需要用一个容器（这里用单调栈）来记录我们遍历过的元素。\n\n\n## 单调栈怎们用\n* 栈中元素存什么\n  存元素下标\n\n* 单调栈里元素是递增呢？ 还是递减呢？\n  * **首先是递增和递减的判断是指，从栈口到栈底**\n  * 递增：求左边或者右边第一个比他大的元素\n  * 递减：求左边或者右边第一个比他晓得元素\n\n* 单调栈的作用\n  存放遍历过的元素\n\n* 主要判断条件\n  当前遍历元素T[i]与T[st.pop()]的关系\n  * 1、T[i] > T[st.pop()]  i-st.pop() i进栈\n  * 2、T[i] == T[st.pop()] i-st.pop() i进栈\n  * 3、T[i] < T[st.pop()]  i进栈\n\n![图 8](../../images/7c3664fbf3e5c5e22f255380b7598b14b32a87562f5df52f96e3d3772b35858d.png)\n\n\n## 题目\n\n### [每日温度](URL=\"https://leetcode.cn/problems/daily-temperatures/description/\")\n\n![图 7](../../images/ad7820adcc8deb619f24bf0f994914c69d73c9c4b2958f37853a1eceba4e08a5.png)\n\n```js\nvar dailyTemperatures = function(temperatures) {\n  let n = temperatures.length\n  let stack = [0]\n  let res = Array(n).fill(0)\n  for(let i=1;i<n;i++){\n    let top = stack[stack.length-1]\n    //小于和等于的情况，直接压入栈\n    if (temperatures[i] === temperatures[top]){\n      stack.push(i)\n    }\n    else if(temperatures[i] < temperatures[top]){\n      stack.push(i)\n    }\n    //当前元素大于栈顶元素的情况，要计算距离，\n    //删掉栈顶元素知道所有小于当前元素的栈顶元素被删完，压入当前元素\n    else{\n      while (stack.length && temperatures[i] > temperatures[stack[stack.length-1]]) {\n        top = stack.pop()\n        res[top] = i-top\n      }\n      stack.push(i)\n    }\n  }\n  return res\n};\n```\n\n### [下一个更大元素 I](URL=\"https://leetcode.cn/problems/next-greater-element-i/description/\")\n\n![图 9](../../images/dfca6eb0f8942f6a513514af4e34d19e238dad6231ecffe4188644a2e7d291a1.png)\n\n**思路**\n用到hash,将nums1存在map中，键位nums1中的元素，值为nums1中元素的索引\n\n使用单调栈解决问题，遍历数组nums2，根据条件进行不同处理\n  * 1、当前元素小于或等于栈顶元素，当前元素压入栈\n  * 2、当前元素大于栈顶元素，查看栈顶元素是否出现在nums1中，如果在，那么及已经找到的他右边的较大元素。\n\n```js\nvar nextGreaterElement = function (nums1, nums2) {\n  const m = nums1.length\n  const n = nums2.length\n  let stack = [nums2[0]]\n  let res = Array(m).fill(-1)\n  let map = new Map()\n  for (let i = 0; i < m; i++) {\n    map.set(nums1[i],i)\n  }\n  for (let j = 1; j < n; j++) {\n    let top = stack[stack.length-1]\n    if (nums2[j]<top || nums2===top) stack.push(nums2[j])\n    else{\n        // console.log(res)\n        while(stack.length && nums2[j]>stack[stack.length-1]){\n          top = stack.pop()\n          if (map.has(top)){\n            res[map.get(top)] = nums2[j]\n\n          }\n        }\n        stack.push(nums2[j])\n      }\n  }\n  return res\n}\n```\n\n### [下一个更大元素](URL=\"https://leetcode.cn/problems/next-greater-element-ii/description/\")\n\n![图 10](../../images/1219981e1ecbd602b459cbf0b2cb98ff79e62962739f81b43ad79bb5934fbb78.png)\n\n**思路**\n数组循环了，思路是把数组复制一份拼接在原数组后面，但是这占用了空间，所以思路是遍历两次数组就好。\n\n```js\nvar nextGreaterElements = function(nums) {\n  let n = nums.length\n  let res = Array(n).fill(-1)\n  let stack = [0]\n  for(let i=1;i<n*2;i++){\n    let j = i\n    if (i>=n)  j = i - n\n    while (stack.length && nums[j] > nums[stack[stack.length - 1]]) {\n      let top = stack.pop()\n      res[top] = nums[j]\n    }\n    stack.push(j)\n  }\n  return res\n};\n```\n\n### [接雨水](URL=\"https://leetcode.cn/problems/trapping-rain-water/description/\")\n\n![图 11](../../images/0ccd6807c5e8e7080a41c93eaf87ae10a99268ff343e7acbae516ec62e2c544c.png)\n\n![图 12](../../images/78f4889062e8b9ac7482844e71214da054c3776d6f004a66c01e26cf58dea244.png)\n\n\n```js\nvar trap = function(height) {\n  let n = height.length\n  let res = 0\n  let stack = [0]\n  for(let i=1;i<n;i++){\n    while(stack.length && height[i]>height[stack[stack.length-1]]){\n        let top = stack.pop()\n        if (stack.length === 0) break\n        let topl = stack[stack.length-1]\n        res += (Math.min(height[i],height[topl])-height[top]) * (i-topl-1)\n    }\n    stack.push(i)\n  }\n  return res\n};\n```\n### [柱状图中最大的矩形](URL=\"https://leetcode.cn/problems/largest-rectangle-in-histogram/description/\")\n\n![图 13](../../images/b9e13624b44e375eb02655e66467f3ee24d0f9c576821af92e01297c1f9edf3d.png)\n\n![图 14](../../images/781e522c28aa43dd338a837b1d9fa9bab99d284dd39f1b50df28a4fc288acd25.png)\n\n\n```js\nvar largestRectangleArea = function(heights) {\n  heights = [0,...heights,0]\n  let n = heights.length\n  let maxArea = 0\n  let stack =[0]\n  for (let i=1;i<n;i++){\n    while(heights[i]<heights[stack[stack.length-1]]){\n      let top = stack.pop()\n      let topl = stack[stack.length-1]\n      let w = i-topl-1\n      maxArea = Math.max(maxArea,w*heights[top])\n    }\n    stack.push(i)\n  }\n  return maxArea\n};\n```","tags":["数组","单调栈"],"categories":["算法","单调栈"]},{"title":"衣橱整理","url":"/2024/07/24/algrithm/衣橱整理/","content":"\n# LCR 130. [衣橱整理](URL=\"https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/\")\n\n![图 0](../../images/5d83b51864b71e894f3c1603ab0b804db60800a7befc1615471376f5a7880254.png)\n\n## 思路\n首先需要理解题意，我刚开始理解为在一个矩阵中找到所有符合digit(i)+digit(j)<=cnt的个数。如下图我以为是找出蓝色格子数量。\n\n实际并不是，只要找到从(0,0)触发，能通过向下或向右走一格能到达的符合digit(i)+digit(j)<=cnt的格子的个数。也就是说要找的是从（0，0）出发通过右移或下移一格能到达的蓝色格子的个数。\n\n题解和网友说要用到深度优先遍历。\n\n![图解](https://pic.leetcode-cn.com/20e6c066e9e692646035d87cf1b11c415c6ac5940bbaf37a70d3470cbe3cd5f1-%E5%B9%BB%E7%81%AF%E7%89%879.JPG)\n\n\n```js\nfunction wardrobeFinishing(m, n, cnt) {\n  const digitSum = (num) => {\n    let sum = 0\n    while (num) {\n      sum += num % 10\n      num = Math.floor(num / 10)\n    }\n    return sum\n  }\n\n  const visited = Array.from({ length: m }, () => Array(n).fill(false))\n  let count = 0\n\n  const dfs = (i, j) => {\n    if ( i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || digitSum(i) + digitSum(j) > cnt)\n      return\n    visited[i][j] = true\n    count++\n    dfs(i + 1, j) // 向下移动\n    dfs(i, j + 1) // 向右移动\n  }\n\n  dfs(0, 0) // 从(0, 0)开始搜索\n  return count\n}\n```","tags":["深度优先搜索","广度优先搜索"],"categories":["算法","动态规划"]},{"title":"字母迷宫","url":"/2024/07/23/algrithm/字母迷宫/","content":"\n# 字母迷宫([单词搜索](URL='https://leetcode.cn/problems/word-search/description/'))\n\n![图 0](../../images/f57deea02bd356d89616967d59158e89927670f012509a377a8b6d327f1818e0.png)\n\n## 思路\n\n刚开始看到这题，知道用回溯算法，所以回忆了回溯算法三部曲\n* 1、确定参数\n* 2、确定终止条件\n* 3、单层搜索逻辑\n\n但是看了半天之确定了参数，终止条件和单层逻辑都理出来。看了讲解知道了原因。\n\n第一个字母的匹配逻辑和后续字母匹配逻辑不一致。\n\n- 第一个字母就在矩阵中挨个遍历，哪个元素等于target[0],就可以开始下一个字母。\n\n- 而非第一个字的匹配，是要在第一个匹配上的字母的上下左右寻找。\n\n前者按照行列遍历，后者按照方向遍历。因此有必要分成两部分，先找到第一个字母吗，然后后续字母遵照一样的逻辑处理。\n\n\n## 思路详解\n* 1、参数：i,j,k分别表示矩阵的行、矩阵的列以及当前遍历到target字符的哪一位字符\n* 2、确定终止条件\n  * 如果当前位置的字符不等于 target[k]，则当前路径不可能构成目标单词，返回 false。\n  * 如果 k == target.length - 1 且当前字符匹配，说明已经成功找到目标单词，返回 true。\n  * 注意，还应该有一个终止条件是检查 (i, j) 是否越界或者该位置已经被访问过，以避免重复访问。\n* 3、单层搜索逻辑：\n  * 对于矩阵中的每一个元素，如果它是 target[0]，则从这个元素开始，尝试所有可能的搜索路径。\n  * 一旦找到匹配的第一个字母，后续的搜索应该限制在当前元素的上下左右四个方向上。\n  * 搜索过程中，需要标记当前路径已访问过的位置，以避免循环访问。搜索后，需要撤销标记（回溯），以便其他搜索路径可以使用这些位置。\n\n## 代码\n```js\nvar wordPuzzle = function(grid, target) {\n  const h = grid.length,\n    w = grid[0].length;\n  const direction = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0]\n  ];\n  const visited = Array.from({ length: h }, () => Array(w).fill(false));\n\n  const check = (i, j, k) => {\n    if (grid[i][j] != target[k]) return false;\n    else if (k == target.length - 1) return true; // 修正比较操作\n\n    visited[i][j] = true;\n    //向四分方向寻找\n    for (let [dx, dy] of direction) { // 添加let声明\n      let newi = i + dx, newj = j + dy;\n      if (newi >= 0 && newi < h && newj >= 0 && newj < w && !visited[newi][newj]) { // 修正条件判断\n        if (check(newi, newj, k + 1)) {\n          return true; // 找到匹配后立即返回true\n        }\n      }\n    }\n    visited[i][j] = false;\n    return false;\n  };\n  // 第一个字母的判断\n  for (let i = 0; i < h; i++) {\n    for (let j = 0; j < w; j++) {\n      if (check(i, j, 0)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n```\n\n## copilot 代码\n```js\nvar wordPuzzle = function(grid, target) {\n  const h = grid.length,\n        w = grid[0].length;\n  const directions = [\n    [0, 1],  // 右\n    [0, -1], // 左\n    [1, 0],  // 下\n    [-1, 0]  // 上\n  ];\n\n  const visited = Array.from({ length: h }, () => Array(w).fill(false));\n\n  const dfs = (i, j, k) => {\n    if (i < 0 || i >= h || j < 0 || j >= w || visited[i][j] || grid[i][j] !== target[k]) {\n      return false;\n    }\n    if (k === target.length - 1) {\n      return true;\n    }\n    visited[i][j] = true;\n    for (const [di, dj] of directions) {\n      if (dfs(i + di, j + dj, k + 1)) {\n        return true;\n      }\n    }\n    visited[i][j] = false; // 回溯\n    return false;\n  };\n\n  for (let i = 0; i < h; i++) {\n    for (let j = 0; j < w; j++) {\n      if (grid[i][j] === target[0] && dfs(i, j, 0)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n```","tags":["数组","回溯算法","字符串","矩阵"],"categories":["算法","回溯算法"]},{"title":"基于cesium和高德地图API的路径规划","url":"/2024/07/21/devlopment/基于cesium和高德地图API的路径规划/","content":"\n# 基于cesium和高德地图API的路径规划\n## cesium\n* 作为一个开源的、世界级的、展现3D全球地图的JavaScript类库，Cesium毫无疑问已然成为WebGIS开发中三维地球框架的首选，(https://cesium.com/)\n\n* cesium的组成和功能，如下表所示\n\n| Component | Description |\n|-----------|-------------|\n| Viewer | 提供3D、2D、2.5D的地图视图 |\n| DataSource | 支持多种数据源，包括地形、影像、矢量数据等  |\n| Entity | 用于在地图上展示点、线、面等几何图形  |\n| Widget | 提供了一系列UI组件，如指南针、缩放控件等 |\n|Scene|管理和渲染3D场景|\n|Camera|控制视角和视图|\n|CesiumWidget|不带UI控件的Cesium Viewer的简化版本|\n|Primitives|用于渲染几何图形和图像|\n|ImageryLayer|管理地图影像图层|\n|TerrainProvider|提供地形数据|\n\n\n## 高德地图api\n* 高德地图api在js中的应用，有两大类一种是已经封装好的web服务，一种是js API\n\n| 类别 | 描述 | 使用场景 |\n|------|------|----------|\n| Web服务 | 高德地图提供的一系列服务器端API，可以通过HTTP请求访问。这些服务包括地理编码、路径规划、静态地图等。 | 当你需要在服务器端处理地图数据，或者在客户端进行简单的HTTP请求以获取地图数据时使用。 |\n| JavaScript API | 一套在网页中直接嵌入和操作地图的接口。提供了丰富的功能，如地图显示、交互、覆盖物添加等。 | 当你需要在网页中嵌入交互式地图，实现复杂的地图操作和数据可视化时使用。 |\n\n前者已经封装好api，直接访问即可返回数据，而后者是需要在前端页面中嵌入的地图功能。\n\n### 输入提示([JS API](URL 'https://lbs.amap.com/api/javascript-api-v2/guide/services/autocomplete'))\n\n#### 安装\n```js\nnpm install @amap/amap-jsapi-loader\n```\n#### 引入\nES Module:\n```js\nimport AMapLoader from '@amap/amap-jsapi-loader'\n// 初始化地图时要配置key，和密钥\n// 因为我没配置密钥导致我的提示一直不出来，搞了好久才成功\nAMapLoader.load({\n  \"key\": \"你的高德地图API密钥\", // 请替换成你的高德地图API密钥\n  \"version\": \"2.0\", // API版本号\n  \"plugins\": [] // 需要使用的插件列表\n}).then((AMap) => {\n  // 高德地图API已成功加载，现在可以通过AMap对象进行地图开发了\n}).catch(e => {\n  console.log(e); // 加载错误\n});\n```\n\n```js\n// 在index.html中通过CDN的方式引入\n<script type=\"text/javascript\">\n     window._AMapSecurityConfig = {\n            securityJsCode:'安全密钥',\n        }\n    </script>\n<script src=\"https://webapi.amap.com/maps?v=2.0&key=我的key\"></script>\n<script src=\"https://webapi.amap.com/ui/1.1/main.js\"></script>\n```\n\n```js\n//使得id为inputId的input元素可以实现搜索提示\nconst initAutocomplete = (inputId) => {\n  // 延迟执行，确保DOM元素已经渲染\n      nextTick(() => {\n        AMap.plugin('AMap.AutoComplete', () => {\n          const autoOptions = {\n            input: inputId\n          };\n          const autoComplete = new AMap.Autocomplete(autoOptions);\n          //选中某个poi之后的操作，获取poi的经纬度用于后续路径规划\n          autoComplete.on('select', (e) => {\n            console.log('select', e)\n            if (inputId === 'tipinput1') {\n              startPoint.value = e.poi.name;\n              startCoor.value.lng = e.poi.location.lng;\n              startCoor.value.lat = e.poi.location.lat;\n              // startCity.value = e.poi.sdcode;\n            } else {\n              endPoint.value = e.poi.name;\n              endCoor.value.lng = e.poi.location.lng;\n              endCoor.value.lat = e.poi.location.lat;\n              // endCity.value = e.poi.adcode ;\n            }\n          });\n        });\n      });\n};\n```\n\n### 路径规划([web 服务](URL 'https://lbs.amap.com/api/webservice/guide/api/direction'))\n\n只需处理数据，把输入数据根据api要求拼接成想要url即可\n```js\n//封装好的axios\nimport instance from \"./outServeRequest.js\"\n// 访问高德地图api，获取数据;v3有polyline，v5没有\nconst url = '/amap/v3/direction/'\nconst key = '我的key'\nexport function getRoute(routeOpt,originCoor,destinationCoor,) {\n  let routeUrl = ''\n  if (routeOpt === 'integrated') {\n    //后面两个city的值是城市的adcode\n    routeUrl = `${url}/transit/${routeOpt}?&key=${key}&origin=${originCoor.lng},${originCoor.lat}&destination=${destinationCoor.lng},${destinationCoor.lat}&city=110000&cityd=110000`\n  } else {\n    routeUrl = `${url}${routeOpt}?&key=${key}&origin=${originCoor.lng},${originCoor.lat}&destination=${destinationCoor.lng},${destinationCoor.lat}`\n  }\n  return routeUrl\n}\n// 发起get请求\nexport function getRouteData(routeOpt,originCoor,destinationCoor) {\n  const routeUrl = getRoute(routeOpt,originCoor,destinationCoor)\n  return instance.get(routeUrl)\n}\n```\n\n\n**使用api时常看控制台的网络服务，看看请求是否发送，响应是什么。如果发生错误可以根据响应代码对照高德地图api提供的[错误代码](URL \"https://lbs.amap.com/api/webservice/guide/tools/info\")查看错误类型()**\n## 前后端的跨域问题\n后端跨域问题配置，只能解决后端提供的api\n\n而第三方提供的api修改后端跨域无法解决，由于我用的打包工具时vite，在解决第三方跨域问题时需要配置vite.config.js，设置代理为`'/amap'`。配置之后前端api访问时的地址也需要更改需要使用代理,`'/amap/v3/direction'`。\n\n```js\nvite.config.js\nexport default defineConfig({\n  server: {\n      proxy: {\n        // 代理所有到 /amap 的请求到 https://restapi.amap.com\n        '/amap': {\n          //第三方地址，这里用amap代理了，那么请求的地址就应该时amap开头\n          target: 'https://restapi.amap.com', // 目标地址\n          changeOrigin: true, // 必须设置为true，以便代理服务器发送请求时更改Origin头信息\n          rewrite: (path) => path.replace(/^\\/amap/, ''), // 将请求地址中的 /amap 替换为空，因为实际的API地址中不包含 /amap\n          secure: false,\n          xfwd: true,\n        }\n      }\n    }\n})\n```\n\n```js\n前端使用代理\nconst url = `/amap/v3/assistant/coordinate/convert?key=${key}&locations=${locations}&coordsys=gps`\n\n不使用代理前的url为\n'https://restapi.amap.com/v3/assistant/coordinate/...'\n\n```\n\n## 坐标系转换\n高德地图的坐标系和cesium的坐标系是不同的，当然不同数据的坐标系都有差异，我们需要进行坐标系的转换。\n可以借助现有的库，我用的是gcoord(https://github.com/hujiulong/gcoord)\n\n### 安装\nnpm 安装\n```js\nnpm install gcoord --save\n```\n或者直接在页面中通过 script 标签引入:\n```js\n<script src=\"https://unpkg.com/gcoord/dist/gcoord.global.prod.js\"></script>\n```\n\n### 引入\nCommonJS:\n```js\nconst gcoord = require('gcoord');\n```\n\nES Module:\n```js\nimport gcoord from 'gcoord';\n```\n通过 script 标签引入可以直接使用全局变量 gcoord 或 window.gcoord\n\n### transform API\n#### transform(input, from, to)\n进行坐标转换\n\n#### 参数\n* `input` GeoJSON | string | Array<number> GeoJSON对象，或GeoJSON字符串，或经纬度数组\n* `from` CRS 当前坐标系\n* `to` CRS 目标坐标系\n#### 返回值\nGeoJSON | Array<number>\n\n示例\n\n```js\n// 将GCJ02坐标转换为WGS84坐标\nvar result = gcoord.transform([123, 45], gcoord.GCJ02, gcoord.WGS84);\nconsole.log(result);  // [122.99395597, 44.99804071]\n```\n```js\n// 转换GeoJSON坐标\nvar geojson = {\n  \"type\": \"Point\",\n  \"coordinates\": [123, 45]\n}\ngcoord.transform(geojson, gcoord.GCJ02, gcoord.WGS84);\nconsole.log(geojson.coordinates); // [122.99395597, 44.99804071]\n```\n返回数组或GeoJSON对象（由输入决定），**注意：当输入为GeoJSON时，transform会改变输入对象**\n\n**前一种输入为数组，后一种为一个geojson，geojson的coordinates可以是二维数组**\n\nCRS为坐标系，目标支持以下几种坐标系\n\n| CRS            | 坐标格式  | 说明                                                         |\n|----------------|---------|------------------------------------------------------------|\n| gcoord.WGS84| [lng,lat] | WGS-84坐标系，GPS设备获取的经纬度坐标                          |\n| gcoord.GCJ02| [lng,lat] | GCJ-02坐标系，google中国地图、soso地图、aliyun地图、mapabc地图和高德地图所用的经纬度坐标 |\n| gcoord.BD09| [lng,lat] | BD-09坐标系，百度地图采用的经纬度坐标                          |\n| gcoord.BD09LL| [lng,lat] | 同BD09                                                      |\n| gcoord.BD09MC| [x,y]    | BD-09米制坐标，百度地图采用的米制坐标，单位：米                   |\n| gcoord.BD09Meter| [x,y]    | 同BD09MC                                                    |\n| gcoord.Baidu| [lng,lat] | 百度坐标系，BD-09坐标系别名，同BD-09                           |\n| gcoord.BMap| [lng,lat] | 百度地图，BD-09坐标系别名，同BD-09                            |\n| gcoord.AMap| [lng,lat] | 高德地图，同GCJ-02                                           |\n| gcoord.WebMercator| [x,y]    | Web Mercator投影，墨卡托投影，同EPSG3857，单位：米             |\n| gcoord.WGS1984| [lng,lat] | WGS-84坐标系别名，同WGS-84                                   |\n| gcoord.EPSG4326| [lng,lat] | WGS-84坐标系别名，同WGS-84                                   |\n| gcoord.EPSG3857| [x,y]    | Web Mercator投影，同WebMercator，单位：米                     |\n| gcoord.EPSG900913| [x,y]    | Web Mercator投影，同WebMercator，单位：米 |\n\n## 具体实现\n\n## 踩坑总结\n","tags":["cesium","高德地图API","poi搜索","路径规划"],"categories":["开发","前端"]},{"title":"二叉树","url":"/2024/07/19/algrithm/二叉树/","content":"\n# 二叉树\n## 二叉树分类\n\n## 二叉树遍历\n* 前序:根左右\n* 中序:左根右\n* 后序:左右根\n### 递归法\n递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！\n\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n```js\n前序方法1\nvar preorderTraversal = function(root) {\n  let res = []\n  const dfs = ()=>{\n    if (root === null) return\n    res.push(root.val)\n    dfs(root.left)\n    dfs(root.right)\n  }\n  //调用\n  dfs(root)\n  return res\n};\n前序方法2:\nvar preorderTraversal = function (root) {\n  return root\n    ? [\n        root.val,\n        ...preorderTraversal(root.left),\n        ...preorderTraversal(root.right)\n      ]\n    : []\n}\n```\n\n```js\n中序方法1:\nvar inorderTraversal = function(root) {\n  let res=[]\n  const dfs = (r)=>{\n    if (r===null) return\n    dfs(r.left)\n    res.push(r.val)\n    dfs(r.right)\n  }\n  dfs(root)\n  return res\n};\n中序方法2:\nvar inorderTraversal = function (root) {\n  return root\n    ? [\n        ...inorderTraversal(root.left),\n        root.val,\n        ...inorderTraversal(root.right)\n      ]\n    : []\n}\n```\n\n```js\n后序方法1\nvar postorderTraversal = function(root) {\n  let res = []\n  const dfs = (r)=>{\n    if (r===null) return\n    dfs(r.left)\n    dfs(r.right)\n    res.push(r.val)\n  }\n  dfs(root)\n  return res\n};\n后序方法2\nvar postorderTraversal = function (root) {\n  return root\n    ? [\n        ...postorderTraversal(root.left),\n        ...postorderTraversal(root.right),\n        root.val\n      ]\n    : []\n}\n```\n\n### 迭代法--栈\n![图 1](https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif)\n\n```js\n前序\n// 入栈 右 -> 左\n// 出栈 中 -> 左 -> 右\nvar preorderTraversal = function (root) {\n  let res = []\n  if (!root) return res\n  let queue = [root]\n  while(queue.length){\n    cur = queue.pop()\n    res.push(cur.val)\n    cur.right && queue.push(cur.right)\n    cur.left && queue.push(cur.left)\n  }\n  return res\n}\n```\n\n```js\n// 入栈 左 -> 右\n// 出栈 中 -> 右 -> 左 结果翻转\n后序\nvar postorderTraversal = function (root) {\n  let res = []\n  if (!root) return res\n  let stack = [root]\n  while(stack.length){\n    cur = stack.pop()\n    res.push(cur.val)\n    cur.left && stack.push(cur.left)\n    cur.right && stack.push(cur.right)\n  }\n  return res.reverse()\n}\n```\n\n```js\n中序\nvar inorderTraversal = function (root) {\n  // 入栈:左->右\n  // 出栈:左 中 右\n  let res = []\n  if (!root) return res\n  const stack = []\n  cur = root\n  while (cur || stack.length){\n    if (cur){\n      stack.push(cur)\n      cur = cur.left\n    }\n    else{\n      cur = stack.pop()\n      res.push(cur.val)\n      cur = cur.right\n    }\n  }\n  return res\n}\n```\n\n观察上述代码发现,前后序可以通过调整代码顺序,实现.但中序却喝前后序的方法不同,那有没有统一的迭代方法呢?\n\n我们以中序遍历为例，在二叉树：听说递归能做的，栈也能做！ (opens new window)中提到说使用栈的话，无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。\n\n那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。\n\n如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。\n\n```js\nvar inorderTraversal = function (root) {\n  // 入栈:左->右\n  // 出栈:左 中 右\n  let res = []\n  const stack = []\n  if (root) stack.push(root)\n  while (stack.length) {\n    const node = stack.pop()\n    if (!node) {\n      res.push(stack.pop().val)\n      continue\n    }\n    if (node.right) stack.push(node.right) // 右\n    stack.push(node) // 中\n    stack.push(null)\n    if (node.left) stack.push(node.left) // 左\n  }\n  return res\n}\n```\n","tags":["二叉树"],"categories":["算法","二叉树"]},{"title":"回文子串","url":"/2024/07/17/algrithm/动态规划回文子串/","content":"\n\n## 回文子串\n> https://leetcode.cn/problems/palindromic-substrings/description/\n\n![图 0](../../images/855e45a11cdf346aa3f9e6e2e8e85f0bc8d04287bf74697754f8185dacff8272.png)\n\n**思路**\n* 1、dp[i][j] 表示以i开始，j结尾的字符串是否是回文子串\n* 2、递推公式：\n  * if (s[i]==s[j])\n    * if (i==j) return true\n    * if (j-i==1) return true\n    * if (j-i>1) return dp[i+1][j-1]\n  * else dp[i][j] = false\n* 3、初始化：统统false\n* 4、遍历：i倒序，j正序\n\n\n```js\n超时了，129/132\nvar countSubstrings = function(s) {\n  let num = 0\n  function isHuiwen(t) {\n    let p = 0;q = t.length-1\n    while (p<q){\n      if (t[p] != t[q]){\n        return false\n      }\n      p++;\n      q--\n    }\n    return true\n  }\n  for (let i=0;i<s.length;i++){\n    for (let j=i+1;j<=s.length;j++){\n      console.log(isHuiwen(s.substring(i, j)))\n      if (isHuiwen(s.substring(i,j))) num ++\n    }\n  }\n  return num\n};\n```\n\n```js\n动态规划\nvar countSubstrings = function(s) {\n  let num = 0\n  let n = s.length\n  let dp = Array.from({length:n},()=>Array(n).fill(false))\n  for(let i=n-1;i>=0;i--){\n    //j是尾巴，尾巴j大于等于头i\n    for(let j=i;j<n;j++){\n      if (s[i]==s[j]){\n        if (j-i>1) {\n          dp[i][j] = dp[i+1][j-1]\n        }\n        else dp[i][j] = true\n      }\n      if (dp[i][j] === true) num++\n    }\n  }\n  console.log(dp)\n  return num\n};\n```\n\n\n## 最长回文子序列\n> https://leetcode.cn/problems/longest-palindromic-subsequence/description/\n\n![图 1](../../images/d464bbf67275c14d12b476bed87f1ae3870677a0778020862236da5b11584a47.png)\n\n**思路**\n* 1、dp[i][j]表示 以i开头j结尾的字符串中最长回文子序列的长度\n* 2、递推公式：\n  * if (s[i]==s[j]) dp[i][j] = dp[i+1][j-1]+2\n  * else max(dp[i+1][j],dp[i][j-1]),分别把s[j]和s[i]加入后的最长回文子序列的长度。\n* 3、初始化：\n* 遍历顺序，i倒序，j正序\n\n\n```js\nvar longestPalindromeSubseq = function(s) {\n  let n = s.length\n  let dp = Array.from({length:n},()=>Array(n).fill(0))\n  for (let i=0;i<n;i++){\n    dp[i][i] =1\n  }\n  for(let i=n-1;i>=0;i--){\n    for(let j=i+1;j<n;j++){\n      if (i==j) dp[i][j] = 1\n      if (s[i]==s[j]) dp[i][j] = dp[i+1][j-1] + 2\n      else dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1])\n    }\n  }\n  return dp[0][n-1]\n};\n```","tags":["动态规划"],"categories":["算法","动态规划"]},{"title":"编辑距离","url":"/2024/07/15/algrithm/其他动态规划题目/","content":"\n# 编辑距离类问题\n## 判断子序列\n> https://leetcode.cn/problems/is-subsequence/description/\n\n![图 6](../../images/3d3ef41aea313b4447b3fdb56d442739f95e750b531eb9eab2fa1bf37ccbee3a.png)\n\n**思路**\n这题和之前的最长公共子序列有什么关系呢？\n关系在于，这题的最长公共子序列长度和S1的长度相等说明有关系。\n\n**这也是编辑距离的入门题目**，下面是编辑距离的基本思路\n* 1、二维dp数组，dp[i][j]，以i-1结尾的s1和以j-1结尾的s2的最长公共子序列。\n* 2、递推公式：\n  * if (s1[i-1]==s2[i-2]) dp[i-1][j-1]+1;\n  * else dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n* 3、初始化：均为0\n* 4、遍历顺序：\n\n```js\nvar isSubsequence = function(s, t) {\n  let n = s.length\n  let m = t.length\n  let dp = Array.from({length:n+1},()=>Array(m+1).fill(0))\n  for (let i=1;i<=n;i++){\n    for(let j=1;j<=m;j++){\n      if(s[i-1]==t[j-1]) dp[i][j] = dp[i-1][j-1] + 1\n      else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])\n    }\n  }\n  if (dp[n][m] == n) return true\n  return false\n};\n```\n\n## 不同的子序列\n> https://leetcode.cn/problems/distinct-subsequences/description/\n\n![图 3](../../images/c781f811d08d55345f5043dec96303ff6f4a132f5affc87dd1ec523a0ce7d646.png)\n\n**思路**\n这道题目如果不是子序列，而是要求连续序列的，那就可以考虑用KMP。\n\n这道题目相对于72. 编辑距离，简单了不少，因为本题相当于只有删除操作，不用考虑替换增加之类的。\n\n**这道题可以理解为怎么删除元素可以由s变为t；**\n\n* 1、二维dp数组，dp[i][j]以i-1为结尾的s中以j-1为结尾的t的个数\n* 2、递推公式：\n  * if (s[i-1]==t[j-1]) dp[i][j] = dp[i-1][j-1] +dp[i-1][j],使用s[i-1]这个元素+不使用s[i-1]这个元素\n  * else dp[i][j] = dp[i-1][j],模拟删除当前元素，也就是不考录当前的元素。\n* 3、初始化：\n  * `dp[i][0] = 1`(); t是空字符串的话，把s中元素全部删除可以得到t\n  * `dp[0][j] = 0`; s为空字符串，t不可能出现在s中，所以未0\n  * `dp[0][0]= 1`; s和t都为空字符串的话，只有一种可能\n* 4、遍历顺序：\n\n```js\nvar numDistinct = function(s, t) {\n  let n = s.length\n  let m = t.length\n  let dp = Array.from({length:n+1},()=>Array(m+1).fill(0))\n  for (let i=0;i<=n;i++) {dp[i][0]=1}\n  for (let i=1;i<=n;i++){\n    for (let j=1;j<=m;j++){\n      //相等，可以选择使用s[i-1]或者不使用s[i-1]\n      if (s[i-1]==t[j-1]) dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n      else dp[i][j] = dp[i-1][j]  //不相等说明s[i-1]用不了得删掉。\n    }\n  }\n  return dp[n][m]\n};\n```\n\n## 两个字符串的删除操作\n> https://leetcode.cn/problems/delete-operation-for-two-strings/description/\n\n![图 4](../../images/76ca37b36905bf908fcc891bd48b17aeeb536531c574813a02c377627771591f.png)\n\n**思路1**\n求出最长公共子序列，然后用n+m-2x，n,m,s分别表示字符串1、字符串2和最长公共子字符串的长度。\n\n```js\nvar minDistance = function(word1, word2) {\n  let n = word1.length\n  let m = word2.length\n  let dp = Array.from({length:n+1},()=>Array(m+1).fill(0))\n  for (let i=1;i<=n;i++){\n    for(let j=1;j<=m;j++){\n      if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1] + 1\n      else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])\n    }\n  }\n  return n+m-2*dp[n][m]\n};\n```\n\n**思路2**\n* 1、二维dp数组，dp[i][j]以i-1为结尾的word1和以j-1为结尾的word2相同需要的最少操作。\n* 2、递推公式：始终记得dp数组的含义\n  * if (word1[i-1] == word2[i-1]) dp[i][j] = dp[i-1][j-1]，如果相等说明不需要操作。\n  * else dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+2)\n  * 由于dp[i][j-1]= dp[i-1][j-1]+1\n* 3、初始化：dp[i][0] = i,dp[0][j] = j,dp[0][0] = 0\n* 遍历顺序：\n\n```js\nvar minDistance = function(word1, word2) {\n  let n = word1.length\n  let m = word2.length\n  let dp = Array.from({length:n+1},()=>Array(m+1).fill(0))\n  //这两个for循环用于初始化dp数组\n  for (let i=0;i<=n;i++){\n    dp[i][0] = i\n  }\n  for (let j=0;j<=m;j++){\n    dp[0][j] = j\n  }\n  for (let i=1;i<=n;i++){\n    for(let j=1;j<=m;j++){\n      if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]\n      else dp[i][j] = Math.min(dp[i-1][j]+1,dp[i][j-1]+1)\n    }\n  }\n  return dp[n][m]\n};\n```\n## 编辑距离\n> https://leetcode.cn/problems/edit-distance/description/\n\n![图 5](../../images/320344977a78da29c28638deff52dc0fb2bae5dc678c73d0a6472ed8a9727030.png)\n\n\n\n**思路**\n看起来好复杂哦。\n\n题目要求讲word1转为word2的最少操作次数，但实际上我们可以从word2转为word3，或者word1和word2同时操作都可以\n\n* 1、dp[i][j]： 以i-1为结尾的word1和j-1为结尾的word2的最少的操作次数\n* 2、递推公式：\n  * if (word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1],相同不需要操作\n  * else dp[i][j] = min(dp[i][j-1] + 1,dp[i-1][j]+1,dp[i-1][j-1]+1)\n    * 上操作了\n    * 增：word2[i-1]增加一个字符, dp[i][j] = dp[i][j-1] + 1\n    * 删：删掉word1[i-1] ,dp[i][j] = dp[i-1][j]+1\n    * 替换：dp[i][j] = dp[i-1][j-1]+1\n    eg: word1 = 'ab' , word2 = 'a' , 可以是ab删掉b，也可以a增加b。dp数组如下图所示意的：\n\n    ```            a                         a     d\n      +-----+-----+             +-----+-----+-----+\n      |  0  |  1  |             |  0  |  1  |  2  |\n      +-----+-----+   ===>      +-----+-----+-----+\n    a |  1  |  0  |           a |  1  |  0  |  1  |\n      +-----+-----+             +-----+-----+-----+\n    d |  2  |  1  |\n      +-----+-----+\n    ```\n\n* 3、初始化：\n  * dp[i][0] = i\n  * dp[0][j] = j\n* 4、遍历顺序：\n\n\n```js\nvar minDistance = function(word1, word2) {\n  let n= word1.length\n  let m = word2.length\n  let dp = Array.from({length:n+1},()=>Array(m+1).fill(0))\n  for (let i=0;i<=n;i++){\n    dp[i][0] = i\n  }\n  for (let j=0;j<=m;j++){\n    dp[0][j] = j\n  }\n  for (let i=1;i<=n;i++){\n    for (let j=1;j<=m;j++){\n      if (word1[i-1]==word2[j-1]) dp[i][j] = dp[i-1][j-1]\n      else dp[i][j] = Math.min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1]+1)\n    }\n  }\n  return dp[n][m]\n};\n```\n\n","tags":["动态规划"],"categories":["算法","动态规划"]},{"title":"博客域名配置","url":"/2024/07/12/devlopment/博客域名配置/","content":"\n# 博客域名配置\n## 域名购买\n我在阿里云买了域名10元一个，因为我已经不是新用户了，呜呜呜呜\n### 1、注册并登录\n### 2、查询域名，挑一个喜欢的实惠的买下来。\n  直接这样操作下来就会发现付款的时候有提示说，没有实名认证。但也可以付款只不过要在付款后进行实名认证，认证成功后完成过户才正常使用。\n  * 认证的话跟着指引一步步来就行\n  * 过户的操作:进入我的域名控制台-->域名列表-->管理-->域名持有者信息修改（过户）-->提交申请，通过后会有短信提醒。\n  ![图 0](../../images/806713911f17eafc32fa2ebfc16e416ed1659e4702b40d133b7aaed8bd627a40.png)\n  ![图 1](../../images/a4d7274ca87fdb78cf416bd8586d33602c3a2586fb91447cd95d62da973e4d26.png)\n  ![图 2](../../images/6e48857d9b661e9e2c9288ed21f6371521b18d994c60a151348ce1a325ea0776.png)\n\n### 3、域名可以正常使用之后要取配置github pages和域名的解析\n#### 3.1、github pages:\n  打开仓库-->点击新建一个文件-->新建一个名为CNAME的为文件，文件内容为刚申请的域名-->保存修改后，打开设置-->修改名字（个人觉得这步可以去掉，只要后面解析的时候保证名字一样即可）-->点击左边导航栏的Pages-->在Custom domain中输入自己的域名。\n  不过这里肯定解析不出来啦，因为还没配置域名解析呢（见3.2）！\n  ![图 4](../../images/65dd9d1da0793a78e2e82b9b15c1f121f9869d7f19354078b356249020f34ec2.png)\n  ![图 5](../../images/c5ff78a4652c35dd08339f31dbf185b2b745ea481d6ec703a13c9a3a70ad5946.png)\n  ![图 3](../../images/db3361ffe13a97b72a58e9f0473a01cc8bbc05ba27e0f1ce14e1f1e4cb177089.png)\n  ![图 6](../../images/05ae15865a8c117e1c504ddc8c9d027866fd2932798aaafc41e47e6d62a23bf9.png)\n  ![图 8](../../images/25df808106f71db2791d7e9c094e31d7d8cf4ebfe94c9bc50c422fd3a02061e1.png)\n#### 3.2、配置域名解析\n  去阿里云平台，找到域名控制台的域名列表，点击解析；配置图见下面图2，图3的名字和图2中配置保持一致。然后再到pages页面稍等片刻就会发现DNS check成功了，说明可以直接通过域名访问博客了。\n  ![图 9](../../images/450f7b419806fdd571add880464417fdf75ec7e62570e74178ae533db6eeda8a.png)\n  ![图 10](../../images/874c2adee8b25ba7925d2c3196996f1ab8e2002ce1a2a740ef5307a8221b3233.png)\n  ![图 11](../../images/6c32d92a5ddfbdf1696049e71654f64243e954cec1250341a6ecaf0361aec785.png)\n  ![图 12](../../images/0b3a2f3485f20268662357b54d5c29c6755b787b1f259cb8b7b7eef1574274ad.png)\n  ![图 13](../../images/665e2b36dd8ce224cd785fc882afdf75bcfa3cb51918236a6e3baa1a7b89b3dd.png)\n\n\n**注意**\n为了防止每次hexo d都需要去github pages重新配置域名。需要在本地项目的source文件夹下新建一个CNAME去配置你的域名。\n\n![图 14](../../images/1528618f5908934c0aac80008815ed269c1951f296ff2c734d87da171870740d.png)\n","categories":["开发","前端"]},{"title":"子序列","url":"/2024/07/11/algrithm/最长递增子序列/","content":"\n# 子序列与动态规划问题\n## 最长递增子序列\n> https://leetcode.cn/problems/longest-increasing-subsequence/description/\n\n![图 0](../../images/81312fd110c5573ae2d44e392b1f7de1eadbea4914246d7b75ba6d6829a8eba2.png)\n\n\n**思路**\n本题也是代码随想录中子序列问题的第一题，如果没接触过这种题目的话，本题还是很难的，甚至想暴力去搜索也不知道怎么搜。 子序列问题是动态规划解决的经典问题，**当前下标i的递增子序列长度，其实和i之前的下表j的子序列长度有关系**，那又是什么样的关系呢。\n* 1、dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度\n  为什么一定表示 “以nums[i]结尾的最长递增子序” ，因为我们在做递增比较的时候，如果比较 nums[j] 和 nums[i] 的大小，那么两个递增子序列一定分别以nums[j]为结尾 和 nums[i]为结尾， 要不然这个比较就没有意义了，不是尾部元素的比较那么 如何算递增呢。\n* 2、状态转移方程\n  * `if (nums[i]>nums[j]) dp[i] = max(dp[i],dp[j]+1)`这里的含义是，取dp[j]+1的最大值。\n* 3、初始化，子序列的长度最短为1\n* 4、遍历顺序，外层遍历i(1 ~ n)，内层遍历j(0 ~ i-1)\n* 还要注意并不是dp[n-1]才是最终的值，最大值应该是**dp数组中的最大值**。\n\n```js\nvar lengthOfLIS = function(nums) {\n  let n = nums.length\n  let dp = Array(n).fill(1)\n  let result = 1\n  for(let i=1;i<n;i++){\n    for(let j=0;j<i;j++){\n      if (nums[i]>nums[j]) dp[i] = Math.max(dp[i],dp[j]+1)\n    }\n    if (dp[i]>result) result = dp[i]\n  }\n  return result\n};\n```\n\n## 最长递增子序列\n> https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/\n\n![图 1](../../images/aec13e165fe037950897965e642cadf2f8d7e8a9d8e53c7a795325ede09b61c0.png)\n\n**思路**\n这里的序列要连续，因此当前的状态要由前一个决定\n* 1、dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]\n* 2、if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1\n* 3、初始化dp[i]都等于1\n* 4、循环，只需要一层循环遍历i即可\n* 当然同样注意最终答案不是dp[n-1]，而是dp数组中的最大值\n\n```js\nvar findLengthOfLCIS = function(nums) {\n  let n = nums.length\n  let dp = Array(n).fill(1)\n  let result =1\n  for(let i=1;i<n;i++){\n    if(nums[i]>nums[i-1]) dp[i] = dp[i-1]+1\n    if (dp[i]>result) result = dp[i]\n  }\n  return result\n};\n```\n\n## 最长重复子数组\n> https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/\n\n![图 2](../../images/139fb0983f3e633d46d643eb3b45def6b403bce5076c6d9cf1bac27a15ec5fbc.png)\n\n**难点**\n动态数组怎么表示，又是什么含义\n\n**思路**\n如果要暴力破解的话，把每个数组的子数组遍历出来，然后两两比较，得出最长重复子数组\n* 1、二维`dp[i][j]`，以i-1为结尾的`nums[1]`和以j-1为结尾的`nums[2]`,的最长重复子数组的长度；本质上也是两两比较了，但是由于我记录了前一个状态的值，在进行下一个状态比较时，子需要对比一个数即可结合前一个状态得出现在状态的值。\n\n  * 为什么i，j表示下标为i-1和j-1呢？因为有`dp[i-1]`,`dp[j-1]`,因此i和j的最小值应该为1。dp数组遍历时候从1开始，但是nums数组要从0号元素开始比较。\n\n* 2、递推公式：`if(nums[i-1]==nums[j-1]) dp[i][j] = dp[i-1][j-1] +1`;\n  ![图 4](../../images/6765bbda2526cf76d1a7db50397df4f35f8ee77c4ded94a2cf79b9b67e91a1eb.png)\n\n* 3、初始化：`dp[i][0] = 0,dp[0][j] = 0`;因为i和j遍历时都从1开始\n* 4、遍历顺序：\n* 这题也是结果在过程中，而不是遍历完之后。\n\n```js\nvar findLength = function(nums1, nums2) {\n  let n = nums1.length\n  let m = nums2.length\n  let dp = Array.from({length:n+1},()=>Array(m+1).fill(0))\n  let result = 0\n  for (let i=1;i<=n;i++){\n    for(let j=1;j<=m;j++){\n      if(nums1[i-1] == nums2[j-1]) dp[i][j]=dp[i-1][j-1]+1\n      if (dp[i][j] > result) result = dp[i][j]\n    }\n  }\n  return result\n};\n```\n\n## 最长公共子序列\n> https://leetcode.cn/problems/longest-common-subsequence/description/\n\n![图 3](../../images/cd0bb2556e285ff0ad97a51419d05f5de8088d222c174327b899eca5ad663a1e.png)\n\n**思路**\n这道题就是可以不连续，可以不连续前面一维数组做过，不过现在dp需要时二维数组，因此这题主要突破点再递推公式上\n* 1、dp[i][j]表示以i-1为结尾的第一个字符串和j-1结尾的第二个字符串的最长公共子序列长度\n* 2、递推公式：主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同。\n  * if (text1[i-1]==text2[j-1]) dp[i][j] = dp[i-1][j-1]+1;\n  * else dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n\n* 3、初始化，均为0即可，\n* 4、遍历顺序，那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。\n  ![图 5](../../images/6a684733782f993681c27dafdd52df4dca1eb0f41e383c6d495bd107ae95cc58.png)\n\n\n```js\nvar longestCommonSubsequence = function(text1, text2) {\n  let n = text1.length\n  let m = text2.length\n  let dp = Array.from({length:n+1},()=> Array(m+1).fill(0))\n  for(let i=1;i<=n;i++){\n    for(let j=1;j<=m;j++){\n      if (text1[i-1]==text2[j-1]) dp[i][j] = dp[i-1][j-1]+1\n      else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])\n    }\n  }\n  return dp[n][m]\n};\n```\n## 不相交的线\n>https://leetcode.cn/problems/uncrossed-lines/description/\n\n![图 2](../../images/0950ea987d264f7e2ed1cc66431d89a66429350386479a5906e690a59d3552b6.png)\n\n**思路**\n其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）\n\n这么分析完之后，大家可以发现：本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！\n\n\n```js\nvar maxUncrossedLines = function(nums1, nums2) {\n  let n = nums1.length\n  let m = nums2.length\n  let dp = Array.from({length:n+1},()=>Array(m+1).fill(0))\n  for(let i = 1;i<=n;i++){\n    for(let j = 1;j<=m;j++){\n      if (nums1[i-1]==nums2[j-1]) dp[i][j] = dp[i-1][j-1]+1\n      else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])\n    }\n  }\n  return dp[n][m]\n};\n```\n\n\n\n","tags":["动态规划"],"categories":["算法","动态规划"]},{"title":"买卖股票","url":"/2024/07/09/algrithm/买卖股票/","content":"\n# 买卖股票\n## 买卖股票最佳时机（121）\n> https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/\n\n![图 0](../../images/db2d51550dac1ea77501bacace4beafc0db021f46a944fb8e7ea1887c6bcfd99.png)\n\n**思路**\n股票只能买卖一次\n* 1、`dp[i][0],dp[i][1]` 分别表示持有股票和不持有股票的现金最大值\n* 2、递推公式：\n  * `dp[i][0] = max(dp[i-1][0],-prices[i])` 维持前一天持有股票的状态或者买入今天的股票，这是因为只能买一次买一次所以是-prices[i]\n  * `dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])` 维持前一天不持有股票的状态，或者在今天卖出股票\n* 3、初始化，dp[0][0] = -prices[0]\n* 4、dp[i]的状态依赖dp[i-1]的状态因此从前往后遍历\n可以把二维dp数组压缩为一维如下代码所示\n\n```js\nvar maxProfit = function(prices) {\n  let dp = Array(2).fill(0)\n  dp[0] = -prices[0]\n  let n = prices.length\n  for(let i=1;i<n;i++ ){\n    let val0 = Math.max(dp[0],-prices[i])\n    let val1 = Math.max(dp[0]+prices[i],dp[1])\n    dp = [val0,val1]\n  }\n  return dp[1]\n};\n```\n\n## 买卖股票的最佳时机（122）\n>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/\n\n![图 1](../../images/50e4e66ec0df2bc60b233730d40950bbe9ff3011722c6898b3737550d55a80ec.png)\n\n\n**思路**\n股票只能买卖多次\n* 1、`dp[i][0],dp[i][1]` 分别表示持有股票和不持有股票的现金最大值\n* 2、递推公式：\n  * `dp[i][0] = max(dp[i-1][0],dp[i-1][1]-prices[i])` 维持前一天持有股票的状态或者买入今天的股票，(**今日买入手中的现金=前一天不持有的利益-今日股票价格**)\n  * `dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])` 维持前一天不持有股票的状态，或者在今天卖出股票\n* 3、初始化，dp[0][0] = -prices[0]\n* 4、dp[i]的状态依赖dp[i-1]的状态因此从前往后遍历\n可以把二维dp数组压缩为一维如下代码所示\n\n\n```js\nvar maxProfit = function(prices) {\n  let n = prices.length\n  let dp = Array(2).fill(0)\n  dp[0] = -prices[0]\n  for (let i = 1;i<n;i++){\n\n    let val0 = Math.max(dp[0],dp[1]-prices[i])\n    let val1 = Math.max(dp[0]+prices[i],dp[1])\n    dp = [val0,val1]\n    console.log(dp)\n  }\n  return dp[1]\n};\n```\n\n## 买卖股票的最佳时机（123）\n>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/\n\n![图 2](../../images/c13cf186c5106b49f9dcd7bf544a9e641a996f72dc21d0ca94ed014f2243d82b.png)\n\n\n**思路**\n关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖\n* 1、dp数组状态：`dp[i][0],dp[i][1],dp[i][2],dp[i][3],dp[i][4]`\n  * 0：没有操作\n  * 1：第一天持有股票\n  * 2：第一天不持有股票\n  * 3：第二次持有股票\n  * 4：第二次不持有股票\n* 2、递推公式\n  * dp[i][0] = dp[i-1][0]\n  * dp[i][1] = max(dp[i-1][1],dp[i-1][0]-prices[i]) 保持前一天持有状态，今天刚刚买入。\n  * max(dp[i-1][1] + prices[i],dp[i-1][2]) 延续前一天不持有的状态或者，前一天持有今天买了\n  * max(dp[i-1][3],dp[i-1][2]-prices[i])，延续前一天买入第二次股票的状态，前一天第一次不持有减去今天股票价格\n  * max(dp[i-1][4],dp[i-1][3]+prices[i])\n* 3、初始化：\n  * dp[0][0] = 0\n  * dp[0][1] = -prices[0]\n  * dp[0][2] = 0,同一天买卖，手里现金增加0\n  * dp[0][3] = -prices[0],第一天买入，卖出，又买入\n  * dp[0][4] = 0\n* 4、遍历：从前往后\n\n```js\nvar maxProfit = function(prices) {\n  let n = prices.length\n  let dp = Array(5).fill(0)\n  dp[1] = -prices[0]\n  dp[3] = -prices[0]\n  for(let i=1;i<n;i++){\n    let val0 = dp[0]\n    let val1 = Math.max(dp[0] - prices[i],dp[1])\n    let val2 = Math.max(dp[1]+prices[i],dp[2])\n    let val3 = Math.max(dp[3],dp[2]-prices[i])\n    let val4 = Math.max(dp[4],dp[3]+prices[i])\n    dp = [val0,val1,val2,val3,val4]\n  }\n  return dp[4]\n};\n```\n\n## 买卖股票最佳时机（188）\n> https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/\n\n![图 3](../../images/d7d4e53aa9bc7e5410f184a8e526feec965c337685fac5d754ae8c7f24c81a80.png)\n\n\n**思路**\n至多可以买卖**k**次\n从前面一道题可以看出规律，`dp[i][k]`的状态由`dp[i-1][k]`和`dp[i-1][k-1]`决定\n* 1、`dp[i][j]`,`(0<i<n;0<j<2*k)`,表示第i天的2k种状态，\n* 2、递推公式，`dp[i][j]`\n  * j是奇数，持有状态：`max(dp[i-1][j],dp[i-1][j-1]-prices[i])`\n  * j是偶数，不持有状态：`max(dp[i-1][j],dp[i-1[j]+prices[i]])`\n* 3、初始化，索引为奇数的元素全部初始化为-prices[0],其余全为0\n* 4、遍历，从前往后\n\n```js\nvar maxProfit = function(k, prices) {\n  let n = prices.length\n  let dp = Array(2*k+1).fill(0)\n  for (let i=1;i<2*k;i+=2){\n    dp[i] = -prices[0]\n  }\n  for(let i=1;i<n;i++){\n    let arr =[0]\n    for (let j=1;j<=2*k;j++){\n      if(j%2 === 1) arr.push(Math.max(dp[j],dp[j-1]-prices[i]))\n      else arr.push(Math.max(dp[j], dp[j - 1] + prices[i]))\n    }\n    dp = arr\n  }\n  return dp[2*k]\n};\n```\n\n## 买卖股票的最佳时机含冷冻期(309)\n> https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/\n\n![图 4](../../images/19b7a6f2c04846b266af427c3ede7f16e59e29f1add35bcd4192a6fb41b4ea2e.png)\n\n\n**思路**\n* 1、dp[j]表示当天股票状态，\n  * dp[0] 表示持有股票\n  * dp[1] 表示保持卖出股票的状态\n  * dp[2] 表示**当天**卖出股票的操作\n  * dp[3] 冷冻的期\n* 2、递推公式\n  * dp[0] = `max(dp[0],dp[3]-prices[i],dp[1]-prices[i])`\n  * dp[1] = `max(dp[1],dp[3])`\n  * dp[2] = `dp[0]+prices[i]`\n  * dp[3] = `dp[2]`\n* 3、初始化\n  * dp[0] = `-prices[i]`\n  * dp[1] = 0\n  * dp[2] = 0\n  * dp[3] = 0\n* 4、遍历顺序\n结果取最后一天状态1，2，3的最大值。\n\n```js\nvar maxProfit = function(prices) {\n  let n = prices.length\n  let dp = Array(4).fill(0)\n  dp[0] = -prices[0]\n  for(let i=0;i<n;i++){\n    let val0 = Math.max(dp[0],dp[3]-prices[i],dp[1]-prices[i])\n    let val1 = Math.max(dp[1],dp[3])\n    let val2 = dp[0]+prices[i]\n    let val3 = dp[2]\n    dp = [val0,val1,val2,val3]\n  }\n  return Math.max(dp[1],dp[2],dp[3])\n};\n```\n\n## 买卖股票的最佳时机含手续费(714)\n> https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/\n\n![图 5](../../images/8e3c255d58311466dd78deed2791f360d54a9baaa7de30a47be8572160573103.png)\n\n\n**思路**\n* 1、dp[j]表示每天的状态\n  * dp[0] 持有\n  * dp[1] 不持有\n* 2、递推公式\n  * dp[0] = max(dp[0],dp[1]-price[i]-fee) ,保持前一天的持有状态，或者在前一天不持有的状态下买入\n  * dp[1] = max(dp[1],dp[0]+prices[i]),保持前一天不持有的状态，或者在昨天持有股票的基础上卖出股票\n* 3、初始化\n  * dp[0] = -prices[0]-fee\n  * dp[1] = 0\n* 4、遍历\n\n\n```js\nvar maxProfit = function(prices, fee) {\n  let n = prices.length\n  let dp = Array(2).fill(0)\n  dp[0] = -prices[0]- fee\n  dp[1] = 0\n  for(let i=0;i<n;i++){\n    let val0 = Math.max(dp[0],dp[1]-prices[i]-fee)\n    let val1 = Math.max(dp[1],dp[0]+prices[i])\n    dp = [val0,val1]\n  }\n  return dp[1]\n};\n```","tags":["动态规划"],"categories":["算法","动态规划"]},{"title":"打家劫舍系列","url":"/2024/07/08/algrithm/打家劫舍/","content":"\n# 打家劫舍系列\n## 打家劫舍（198）\n>https://leetcode.cn/problems/house-robber/description/\n\n![图 0](../../images/38d2ecfaeba72862fa314d9494ec0356f1aa8a95f4cd1ea783ba9bc3221752c2.png)\n\n**思路**\n**五部曲**\n* 1、dp[i] 考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。\n* 2、递推公式：\n  偷：`dp[i] = dp[i-2] + num[i]`，不偷：`dp[i] = dp[i-1]`,因此`dp[i] = max(dp[i-2] + num[i],dp[i] = dp[i-1])`\n* 3、初始化：\n  从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]\n\n  从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);\n* 4、遍历：i从2到最后一个房间\n\n```js\nvar rob = function(nums) {\n  let n = nums.length\n  let dp = Array(n+1).fill(0)\n  dp[0] = nums[0]\n  dp[1] = Math.max(dp[0],nums[1])\n  for (let i=2;i<n;i++){\n    dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1])\n  }\n  return dp[n-1]\n};\n```\n\n### 打家劫舍（213）\n>https://leetcode.cn/problems/house-robber-ii/description/\n\n![图 1](../../images/447da8ab1503c19dedd2940ff580e2a8a699480c3fd19b46f19d706bb3f64b99.png)\n\n**思路**\n对于一个数组，成环的话主要有如下三种情况：\n* 1、首尾均不考虑\n* 2、考虑首，不考虑尾\n* 3、考虑尾，不考虑首\n  情况2和3包含了情况1，因此只需取情况2和3的最大值即可。\n\n```js\nvar rob = function(nums) {\n  let n = nums.length\n  if (n===1) result = nums[0]\n  else{\n    result1 = robRange(nums,1,n-1)\n    result2 = robRange(nums,0,n-2)\n    result = Math.max(result1,result2)\n  }\n  function robRange(nums,start,end){\n    let dp = Array(end-start+2).fill(0)\n    dp[start] = nums[start]\n    dp[start+1] = Math.max(nums[start],nums[start+1])\n    console.log(start,end)\n    for (let i=start+2;i<=end;i++){\n      dp[i] = Math.max(dp[i-2]+nums[i],dp[i-1])\n    }\n    console.log(dp)\n    return dp[end]\n  }\n  return result\n};\n```\n\n### 打家劫舍（337）\n> https://leetcode.cn/problems/house-robber-iii/description/\n\n![图 2](../../images/73c1441033a851a693041bb8914c0a10c887fe1be6a25518bae2e58ed67886ba.png)\n\n\n**思路**\n数据结构变成个二叉树了，投了父节点就不能考虑子节点了，而是要考虑孙子节点\n* 每个节点有一个一维dp数组，数组长度为2，dp[0]表示不偷所获金钱的最大值，dp[1]表示偷所获金钱的最大值。\n\n* 递归三部曲\n  * 确定参数，robtree(root)返回dp数组\n  * 终止条件，if(cur == null) return [0,0]\n  * 遍历顺序是后序遍历，因为父的值需要依靠孩子的值决定\n* 递归五部曲\n  * 1、dp[0]表示不偷所获金钱的最大值，dp[1]表示偷所获金钱的最大值。\n  * 2、递推公式`dp[0] = max(leftdp[0],leftdp[1]) + max(rightdp[0],rightdp[1]) `,`dp[1] = cur.val + leftdp[0] + rightdp[0]`\n  * 3、初始化均为0\n  * 4、遍历\n\n```js\nvar rob = function(root) {\n  //递归后续遍历二叉树\n  const robtree = (rootnode)=>{\n    let cur = rootnode\n    if(cur===null) return [0,0]\n    let leftdp = robtree(cur.left)\n    let rightdp = robtree(cur.right)\n    let val0 = Math.max(leftdp[0],leftdp[1]) + Math.max(rightdp[0],rightdp[1])\n    let val1 = cur.val + leftdp[0] + rightdp[0]\n    return [val0,val1]\n  }\n  //这里解构的时候容易出错\n  let [result0,result1] = robtree(root)\n  // console.log(result0,result1)\n  return Math.max(result0,result1)\n};\n```","tags":["动态规划"],"categories":["算法","动态规划"]},{"title":"完全背包","url":"/2024/07/01/algrithm/完全背包/","content":"\n# 完全背包\n## 什么是完全背包\n* 01背包，每个物品只能使用一次\n* 完全背包：每个物品可以使用无数次\n\n![图 0](../../images/d7247ac396e04aed85fc08d25c33bf98e7e888d2d499c5d6708386c052a5663a.png)\n\n\n## 01背包引出完全背包\n```js\nfor (let i=0;i<goodsNum;i++){\n  for (let j=weight[i];j<=bagWeight;j--){\n    dp[j] = max(dp[j],dp[j-weight[i]]+value[i])\n  }\n}\n```\n* 01背包使用一维滚动数组时，背包容量要倒序遍历，这样保证每个物品只是用一次。\n* 完全背包，物品可以使用无数次，因此将背包容量遍历的时候改为正序遍历，即可实现\n\n![图 1](../../images/2cfdb9d17230700b5f6b5632422bbef950171865a410509a5c1ffc11d1e825ab.png)\n\n\n```js\n//ACM模式\nlet readline = require('readline')\nconst rl = readline.createInterface({\n    input:process.stdin,\n    output:process.stdout\n});\nlet inputArr = []\n rl.on('line',function(line){\n     inputArr.push(line.split(' '))\n }).on('close',function(){\n     let n = parseInt(inputArr[0][0])\n     let v = parseInt(inputArr[0][1])\n     let weight = []\n     let value = []\n     for (let i = 1;i<=n;i++){\n         weight.push(parseInt(inputArr[i][0]))\n         value.push(parseInt(inputArr[i][1]))\n     }\n     let dp = Array(v+1).fill(0)\n     for (let i=0;i<=n;i++){\n      //这边这个循环要注意，总写错j的起始值\n         for(let j=weight[i];j<=v;j++){\n            dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i])\n         }\n     }\n     console.log(dp[v])\n })\n```\n\n## 题目\n### 零钱兑换\n> https://leetcode.cn/problems/coin-change-ii/description/\n\n\n![图 2](../../images/cc5b1802c7ea325e9e07a54cc82b80cbaed9ae7a142c120acf784b39e26b6115.png)\n\n**思路**\n这是一个统一方法数的题目，和之前价值不一样的递推公式。\n* bn找价值最高：`max(dp[j],dp[j]+dp[j-weight[i]]+value[i])`\n* 而找方法数：`dp[j]+=dp[j-weight[i]]`\n就比如硬币找零：找总额5元,有1，2，5三种硬币，那么`dp[5] = dp[4] + dp[3] + dp[0]`\n\n**五部曲**\n1、dp[j] 表示总和为j的找零方式；\n2、递推公式 dp[j] += dp[j-coins[i]]；\n3、初始化，dp[0] = 1,其他索引对应的值均为0,因为要加等于，如果都是零加起来也都是零；\n4、遍历，两个都是正序，因为完全背包，每种面额的钱有无数张。\n**如果求*组合数*就是外层for循环遍历物品，内层for遍历背包。**\n因为则何种情况下物品的遍历顺序是固定的，有{1,2}就没有被{2,1}\n```js\nvar change = function(amount, coins) {\n  let n = amount\n  let m = coins.length\n  let dp = Array(n+1).fill(0)\n  dp[0] = 1\n  for (let i=0;i<m;i++){\n    for(let j = coins[i];j<=n;j++){\n      dp[j] += dp[j-coins[i]]\n    }\n  }\n  return dp[n]\n};\n```\n\n### 组合总和IV\n>https://leetcode.cn/problems/combination-sum-iv/description/\n\n![图 3](../../images/9ccc0c74a1e04db6a99e39e3ffe175616000705afbfbd0849c4af3b4f75188ae.png)\n\n题目实际上是一个排列问题，元素有顺序的要求了，所以遍历顺序是解题关键\n\n**动规五部曲**\n1、dp[j]表示目标为j时的排列数量\n2、递推公式：算方法数dp[j] += dp[j-nums[i]]\n3、初始化，dp[0]=1,其他均为零\n4、遍历，先遍历背包后遍历物品这样物品就有顺序了\n\n\n```js\nvar combinationSum4 = function(nums, target) {\n  let n = target\n  let m = nums.length\n  let dp = Array(n+1).fill(0)\n  dp[0] = 1\n  // 背包\n  for (let i=0;i<=n;i++){\n    // 物品\n    for (let j=0;j<m;j++){\n      if (i-nums[j] >=0)  dp[i] += dp[i - nums[j]]\n    }\n  }\n  return dp[n]\n};\n```\n\n### 爬楼梯(进阶版)\n>https://kamacoder.com/problempage.php?pid=1067\n\n![图 4](../../images/b78f2df1472839bb85bb3622fa756618ae96755c5421e6ac543d3157820bd9bb.png)\n\n**思路**\n使用动规五部曲分析\n* 1、dp[i]表示爬到第i级台阶的方法数\n* 2、递推公式：dp[i] = dp[i-1] + dp[i-2] + ... +dp[i-m]\n* 3、初始化：\n  需要初始化dp[0]到dp[m]，但是m是变化的，不能直接赋值需要一步步递推。\n  以m为5的情况为例：\n  dp[1] = 1\n  dp[2] = dp[1] + 1\n  dp[3] = dp[2] + dp[1] + 1\n  dp[4] = dp[3] + dp[2] + dp[1] +1\n  dp[5] = dp[4] + dp[3] +dp[2] + dp[1] +1\n  根据上述规律不难想出，让dp[0] = 1\n  此外还可以看出这里的规律和递推公式是如出一辙\n  dp[j] = dp[j-1] + dp[j-2] + ... dp[j-m]\n* 4、遍历顺序：外层遍历爬上的太结束，内层遍历m\n综上得出如下面的代码。\n\n**总结**\n看了代码随想录的文档，惊觉这竟然是一个完全背包问题。其中要爬最终台阶个数为背包容量；而能爬的台阶个数1，2，... m是物品数量。\n\n每次爬的台阶数可以重复也就是物品可以重复放。\n\n```js\nconst readline = require('readline')\nconst rl = readline.createInterface({\n    input:process.stdin,\n    output:process.stdout\n});\n\nrl.on('line',function(line){\n    var tokens = line.split(' ')\n    let n = parseInt(tokens[0])\n    let m = parseInt(tokens[1])\n    let dp = Array(n+1).fill(0)\n    dp[0] = 1\n    for (let i=0;i<=n;i++){\n        for (let j=1;j<=m && i-j>=0;j++){\n            dp[i] += dp[i-j]\n        }\n    }\n    console.log(dp[n])\n})\n```\n\n### 零钱兑换（322）\n>https://leetcode.cn/problems/coin-change/description/\n\n![图 5](../../images/1d34ae0299dee572bcf86bb13b65d6d7b88325118221878210ac5b227db8bdf2.png)\n\n**思路**\n*1、dp[i] 表示兑换总额为i的金钱需要的最少硬币数\n*2、递推公式 dp[j] = min(dp[j],dp[j-coins[i]]+1)\n*3、初始化 dp[0] = 0,其余均为一个较大的正整数\n*4、遍历顺序：先遍历物品后遍历背包，背包容量从小到。\n\n**记错模块**\ndp数组及其下标的含义、递推公式以及初始化都是没有问题的，但是在遍历顺序上我搞反了，导致错误。组合问题还是要先遍历物品，这样物品有顺序。排列问题才需要物品顺序的变化，要先遍历背包。\n\n![图 6](../../images/af5dbd2a6fef413d76bc58fd7b3151e99d164340197ad838804644fc74ec4b7e.png)\n\n\n```js\nvar coinChange = function(coins, amount) {\n  let n = amount\n  let m = coins.length\n  let dp = Array(n+1).fill(Number.MAX_SAFE_INTEGER)\n  dp[0] = 0\n  for(let i=0;i<m;i++){\n    console.log(dp)\n    for(let j=coins[i];j<=n;j++){\n      dp[j] = Math.min(dp[j],dp[j-coins[i]]+1)\n\n    }\n  }\n  if (dp[n] == Number.MAX_SAFE_INTEGER) return -1\n  else return dp[n]\n};\n```\n\n### 完全平方数\n>https://leetcode.cn/problems/perfect-squares/description/\n\n![图 7](../../images/3b68c6e2c479dc486c7e125c7a8b59dc58c2ba2ab63c334614ccdf46fcec9080.png)\n\n\n**思路**\n感觉这个和前一道题也没啥区别，只不过需要自己简历完全平方数的数组而已。物品是一个个的完全平方数，背包就是和。\n*1、dp[i],表示组成和为i的完全平方数的个数\n*2、递推公式，dp[j] = min(dp[j],dp[j-nums[i]]+1)\n*3、初始化，dp[0] = 0,其他值为最大正整数\n*4、遍历顺序，先遍历物品，后遍历背包，背包正序遍历。\n\n```js\nvar numSquares = function(n) {\n  let m = Math.floor(Math.sqrt(n))\n  const num = Array.from({ length: m }, (_, i) => (i + 1) ** 2)\n  let dp = Array(n+1).fill(Number.MAX_SAFE_INTEGER)\n  dp[0] = 0\n  for(let i=0;i<m;i++){\n    for(let j = num[i];j<=n;j++){\n      dp[j] = Math.min(dp[j],dp[j-num[i]]+1)\n    }\n  }\n  return dp[n]\n};\n```\n\n\n### 单词拆分\n> https://leetcode.cn/problems/word-break/description/\n\n![图 8](../../images/cade5f64bde58fa61ce125aa3af982c55bdea8da251b3777e55e0b501d9b4c79.png)\n\n**思考**\n难点：背包是什么，背包装满怎么表示？\n背包是指字符串s，s能否用数组中的单词表示就是能否装满的意思。\n\n*1、dp[i]表示字符串s[0:i]能否由数组组成\n*2、递推公式：i表示背包，j表示物品索引\n    q = i-wordDict(j)\n    dp[i] = (dp[q] && s[q,i] === wordDictus[j])\n*3、初始化，dp[0] = true,其他为false\n*4、这本质上是一个求排列的问题，所以要先遍历背包i后后遍历物品j。\n\n**记错模块**\n直接在内循环中使用dp[i] = dp[q] && s.substring(q, i) === wordDict[j]\n则会么写的问题在于忽略了三个问题\n*首先i-wordDict[j]的大小是否大于0\n*每遍历一个单词dp[i]都要被修改，如果已经找到了单词满足条件，继续遍历，答案势必会错\n*substring的用法,应该是小括号\n\n\n\n```js\nvar wordBreak = function(s, wordDict) {\n  let n = s.length\n  let m = wordDict.length\n  let dp = Array(n+1).fill(false)\n  dp[0] = true\n  console.log(dp)\n  for(let i=0;i<=n;i++){\n    for(let j = 0;j<m;j++){\n      //这里忘记打.length了\n      let q = i-wordDict[j].length\n      if (q >= 0 && dp[q] && s.substring(q, i) === wordDict[j]) {\n        dp[i] = true;\n        break; // 找到匹配，无需继续检查其他单词\n      }\n      console.log(dp)\n    }\n  }\n  return dp[n]\n};\n```\n\n","tags":["动态规划","背包问题"],"categories":["算法","动态规划"]},{"title":"01背包","url":"/2024/06/14/algrithm/01背包/","content":"\n# 背包问题\n## 背包分类\n![图 0](../../images/d7247ac396e04aed85fc08d25c33bf98e7e888d2d499c5d6708386c052a5663a.png)\n## 01背包\n有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。\n\n![图 1](../../images/fafa40d3fa8f44afa33fe8beed7080336080a688775d6ad8bfcab034898e0c16.png)\n\n### 二维dp数组\n\n**五部曲**\n1、二维dp数组，`dp[i][j]`，i表示物品的编号，j表示背包重量，存储值表示价值\n`dp[i][j]` 表示从0-i的物品中拿总重量<=j的物品的最高价值。\n2、递推公式:`if j-weight[i] >= 0 dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i]) else dp[i][j] = dp[i-1][j]`\n如果符合条件，那么在拿i与不拿i的较大值中取，如果j小于i的重量，那只有一个选择，选择dp[i-1][j]\n3、初始化，dp[i][0] = 0,因为重量为0，能拿0个物品，价值为0\n   `dp[0][i]` 的值取决于`weight[i]`和`j`，如果 `weight[i]<=j` , `dp[0][i] = value[i]` 否则，`dp[0][j] = 0`\n4、遍历 `for(let i = 0;i<m;i++){ for(let j=1;j<=n;j++){}}`\n![图 2](../../images/d97f6438fdcf918ea7f288db7c0b05e1f675dbd7308182a2866ce0fa7d688ec8.png)\n\n```js\n// js node ACM模式\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\nconst inputArr = [];\nrl.on('line',function(line){\n    inputArr.push(line.split(' '))\n}).on('close',function(){\n    const m = parseInt(inputArr[0][0])\n    const n = parseInt(inputArr[0][1])\n    const weight = inputArr[1].map(Number)\n    const bag = inputArr[2].map(Number)\n    let dp = Array(m).fill().map(()=> Array(n+1).fill(0))\n    for(let i=0;i<m;i++){\n        for(let j=1;j<=n;j++){\n            if (i==0){\n                if(j>=weight[i]) dp[i][j]=bag[i]\n            }\n            else{\n                // 两种情况\n                if(j-weight[i]>=0) dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+bag[i])\n                else dp[i][j]  = dp[i-1][j]\n            }\n        }\n    }\n    console.log(dp[m-1][n])\n})\n\n```\n\n### 一维dp数组（滚动数组）\n对于背包问题其实状态都是可以压缩的。\n\n在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`;\n\n其实可以发现如果把`dp[i - 1]`那一层拷贝到`dp[i]`上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])`;\n\n与其把`dp[i - 1]`这一层拷贝到`dp[i]`上，不如只用一个一维数组了，只用`dp[j]`（一维数组，也可以理解是一个滚动数组）。\n\n这就是**滚动数组**的由来，**需要满足的条件是上一层可以重复利用，直接拷贝到当前层**。\n\n![图 3](../../images/9722b7cceb17c2257a056c264923ee508cb45511326ea97db8c7488588551391.png)\n\n**倒序遍历的原因：dp[j]的状态受dp[0~j-1]的状态的影响，因此需要倒序遍历。**\n\n![图 4](../../images/866133415574daff8f79f53ee5e427b694f324199b0d43266548e5d40d8b5782.png)\n\n```js\nconst readline = require('readline')\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n})\n\ninputArr = []\nrl.on('line',function(line){\n    inputArr.push(line.split(' '))\n}).on('close',function(){\n    const m = parseInt(inputArr[0][0])\n    const n = parseInt(inputArr[0][1])\n    const mArr = inputArr[1].map(Number)\n    const vArr = inputArr[2].map(Number)\n    let dp = Array(n+1).fill(0)\n    for(let i=0;i<m;i++){\n        for(let j=n;j>=mArr[i];j--){\n            dp[j] = Math.max(dp[j],dp[j-mArr[i]]+vArr[i])\n        }\n    }\n    console.log(dp[n])\n})\n```\n\n## 题目\n### 分割等和子集416\n> https://leetcode.cn/problems/partition-equal-subset-sum/description/\n\n![图 5](../../images/2f8203a2d136c3c1af669fa693d20100adc7a84403b6bf86e85a9be139345e9a.png)\n\n**思路**\n分成两个和相等的数组，只要有一个子集满足 `sum(arr)/2` 即可\n\n这里没有价值，以物品重量为价值，`weight = value` 背包装满到数组和的二分之一时，价值达到同样的值就算是成功了。\n`dp[target] = target`\n\n**五部曲**\n1、dp[j] 含义，容量为j的背包所能装的最大价值\n2、递推公式，dp[j] = max(dp[j],dp[j-nums[i]])\n3、初始化：dp = [0,0,0,...]\n4、遍历物品i正序，背包容量j逆序。\n\n![图 6](../../images/ddce32d2e50c75bb5ae00f12e9cece29fa6de840570f3f3de6204a0a335e13d0.png)\n\n```js\nvar canPartition = function(nums) {\n  // 数组求和\n  let sum= nums.reduce((acc, val) => acc + val, 0)\n  // sum如果是偶数可以继续，如果是奇数直接返回false\n  if (sum%2 != 0) return false\n  let target = sum/2\n  let dp = Array(target+1).fill(0)\n  for(let i=0;i<nums.length;i++){\n    for(let j=target;j>=nums[i];j--){\n      dp[j] = Math.max(dp[j],dp[j-nums[i]]+nums[i])\n    }\n  }\n  if (dp[target]==target) return true\n  return false\n};\n```\n\n### 最后一块石头的重量 II\n> https://leetcode.cn/problems/last-stone-weight-ii/description/\n\n![图 7](../../images/edbd2722973dbc4a467a9792f17372448ed2994feb8e87bf11c339f255c328bf.png)\n\n**思路**\n将石头分为两组，并尽可能使得两组石头重量尽可能相等\n最后剩余石头的重量 = 数组1总和 - 数组2总和\n`let target = Math.floor(sum/2)`, 由于向下取整`target<= sum-target`,  `sum - dp[target] >= dp[target]`\n\n\n**五部曲**\n1、`dp[j]`,表示石头放入容量为j的背包能达到的最大重量。\n2、递推公式：`dp[j] = Math.max(dp[j],dp[j-stones[i]+stones[i]])`\n3、初始化：`dp[0] = 0`，背包容量为0时能放的重量为0，其余位置也时0，因为递推公式是求最大值。石头的重量是正数，因此初始化为0，不影响结果。\n4、遍历顺序：石头正序，背包重量逆序\n\n```js\nvar lastStoneWeightII = function(stones) {\n  let sum = stones.reduce((acc,val)=> acc+val,0)\n  let target = Math.floor(sum/2)\n  let dp = Array(target+1).fill(0)\n  for(let i=0;i<stones.length;i++){\n    for(let j=target;j>=stones[i];j--){\n      dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i])\n    }\n  }\n  return sum-dp[target]-dp[target]\n};\n```\n\n### 目标和\n> https://leetcode.cn/problems/target-sum/description/\n\n![图 8](../../images/481b1cd92374b91006fd4fdf11167db8236c6f0d7ffc6a855603df1210f79e3d.png)\n\n**思路**\n讲确定两个数组的问题转换化简为确定一个数组，\n把整个数组可以被分成两个子数组，两个子数组中数字和分别为left和right，则有\n`left - right = target`\n`left + right = sum`\n可推导出：`left - sum + left = target`; `left = (sum + target)/2`\n问题转换为组合和为left的问题，可以用回溯暴力破解。\n\n这个问题转换为背包问题是求，装满容量为j的背包的方法。\n\n**五部曲**\n1、dp[j]表示装满容量为j的背包的方法数\n2、递推公式：dp[j] = dp[j-nums[i]],\n数组为[1,2,3,4,5]\neg：dp[5] = dp[4] + dp[3] + dp[2] + dp[1] + dp[0]\n3、初始化：dp[0] = 1\n4、遍历顺序：外层遍历数组（正序），内层遍历背包容量（倒序）\n\n```js\nvar findTargetSumWays = function(nums, target) {\n  let sum = nums.reduce((acc,val)=>acc+val,0)\n  if (Math.abs(target) > sum)  return 0\n  if ((sum + target) % 2 == 1) return 0\n  let left = (sum + target)/2\n  let dp = Array(left+1).fill(0)\n  dp[0] = 1\n  for (let i=0; i<nums.length; i++){\n    for(let j=left;j>=nums[i];j--){\n      dp[j] += dp[j-nums[i]]\n    }\n  }\n  return dp[left]\n};\n```\n\n### 一和零\n> https://leetcode.cn/problems/ones-and-zeroes/description/\n\n  ![图 10](../../images/73ff771ae0b57409474411d1340df988b4d4d8fd5d2d2bcb550e7db826a0ff38.png)\n\n\n背包容量发生一些变化的01背包，背包容量分为两部分，m用于存储0，n用于存储1\n\n**五部曲**\n1、dp[i][j] 表示0容量为i，1容量为j的背包所能存放的字符串的数量。\n2、递推公式：max(dp[i][j],dp[i-zeroNum][j-oneNum]+1); 实际上每一行是一个一维滚动数组\n3、初始化：都初始化为0\n4、遍历顺序：物品正序，ij逆序。因为是滚动数组\n\n```js\nvar findMaxForm = function(strs, m, n) {\n  let dp = Array.from(Array(m+1), () => Array(n+1).fill(0));\n  for (let str of strs) {\n    let zeroNum = 0, oneNum = 0;\n    for (let s of str) {\n      if (s === '1') oneNum++;\n      else zeroNum++;\n    }\n    for(let i = m; i >= zeroNum; i--) {\n      for (let j = n; j >= oneNum; j--) {\n        dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);\n      }\n    }\n  }\n  return dp[m][n];\n};\n```\n\n### 多重背包\n> https://kamacoder.com/problempage.php?pid=1066\n\n![图 0](../../images/b08ba20dddfd5104c363030b5e897b31b2d15aff0f20adc3c2d37f56b87a0fa6.png)\n\n\n\n```js\nlet readline = require('readline')\nconst rl = readline.createInterface({\n    input:process.stdin,\n    output:process.stdout99\n})\nlet inputArr = []\nrl.on('line',function(line){\n    inputArr.push(line.split(' '))\n}).on('close',function(){\n    let n = parseInt(inputArr[0][0])\n    let m = parseInt(inputArr[0][1])\n    let w = inputArr[1].map(Number)\n    let v = inputArr[2].map(Number)\n    let num = inputArr[3].map(Number)\n    let dp = Array(n+1).fill(0)\n    //遍历物品\n    for (let i=0;i<m;i++){\n      //背包\n        for(let j = n;j>=w[i];j--){\n            for(let k=1;k<=num[i] && k*w[i]<=j;k++){\n                dp[j] = Math.max(dp[j],dp[j-w[i]*k]+v[i]*k)\n            }\n        }\n    }\n    console.log(dp[n])\n})\n```\n","tags":["动态规划","背包问题"],"categories":["算法","动态规划"]},{"title":"动态规划","url":"/2024/05/26/algrithm/动态规划/","content":"\n# 动态规划\n## 动态规划基础\n动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。\n\n<div style=\"background-color:#D2F0F4; color:black;padding:5px;border-radius:5px;\"> 动态规划五部曲 </div>\n\n* 1、dp数组及其下标得含义\n* 2、递推公式\n* 3、dp数组如何初始化呢\n* 4、遍历顺序\n* 5、打印dp数组，为了查错。\n\n\n## 基础题目\n### 斐波那契数\n> https://leetcode.cn/problems/fibonacci-number/description/\n\n![图 0](../../images/01ae88554119b3f889e55d1eee58803122db2db04ea4e5a44272089280f61c19.png)\n\n### 思路\n* 1、dp数组表示什么，dp[i]：第i个斐波那契数的数值\n* 2、递推公式：dp[i] = dp[i-2] + dp[i-1]\n* 3、dp数组初始化：dp[0] = 1,dp[1] = 1\n* 4、遍历顺序：i从2遍历到n\n\n```javascript\nvar fib = function (n) {\n  let dp = new Array(n)\n  dp[0] = 0\n  dp[1] = 1\n  if (n == 0) return 0\n  if (n == 1) return 1\n  if (n > 1) {\n    for (let i = 2; i <= n; i++) {\n      dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n  }\n}\n```\n\n### 爬楼梯\n> https://leetcode.cn/problems/climbing-stairs/description/\n\n![图 1](../../images/9663ce6f69c8d4c7771f741f79648e2cae3932dab391f98185e3ceb6cada5a41.png)\n\n**五部曲解释**\n1、dp数组表示的是，到达第i+1个台阶的方法数\n2、递推公式dp[i] = dp[i-2] + dp[i-1]\n3、dp数组初始化，dp[0] = 1,dp[1] = 2; 上一个台阶一种方法，两个台阶两种方法\n4、遍历顺序从2~n-1\n\n\n```js\nvar climbStairs = function(n) {\n  let dp=[]\n  dp[0] = 1\n  dp[1] = 2\n  for(let i=2;i<n;i++){\n    dp[i] = dp[i-1]+dp[i-2]\n  }\n  return dp[n-1]\n};\n```\n\n### 使用最小花费爬楼梯\n> https://leetcode.cn/problems/min-cost-climbing-stairs/description/\n\n![图 2](../../images/5943d6b5ed2503039758190177210ef53582aba91ff956c76acddfb9efa90a97.png)\n\n**五部曲**\n1、dp数组，代表到达位置i时消耗的花费\n2、递推公式 dp[i] = dp[i-1]+cost[i-1]或者dp[i] = dp[i-2]+cost[i-2]，\n  dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])\n3、初始化，dp[0]=0;dp[1]=0，因为题意明确到达台阶不想上跳是没有花费的。而dp数组的含义是到达位置i的花费，所以dp[0]，dp[1]初始化都是0\n4、遍历：n是cost长度，顶部在n+1的位置\n\n```js\nvar minCostClimbingStairs = function(cost) {\n  let dp = []\n  dp[0]=0,dp[1]=0;\n  n = cost.length\n  for(let i=2;i<=n;i++){\n    dp[i] = Math.min(dp[i-1] + cost[i-1],dp[i-2] + cost[i-2])\n  }\n  return dp[n]\n};\n```\n### 不同路径\n> https://leetcode.cn/problems/unique-paths/description/\n\n![图 3](../../images/b4ad29a33821a889d530113de77f8defa2fdaa1dc5bb6ec751fcfabbcfa5b5b0.png)\n\n\n**五部曲**\n1、dp[i][j],从0，0，走到i，j的走法。\n2、dp[i][j] = dp[i-1][j] + dp[i][j-1]\n3、初始化：dp[0][j] = 1;dp[i][0] = 1\n4、遍历：\n5、\n\n```js\nvar uniquePaths = function (m, n) {\n  let dp = Array(m).fill().map(() => Array(n).fill(0))\n  dp[0][0] = 1\n  for (let i = 0; i < m; i++) dp[i][0] = 1\n  for (let i = 0; i < n; i++) dp[0][i] = 1\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    }\n  }\n  return dp[m - 1][n - 1]\n}\n```\n\n### 不同路径II\n> https://leetcode.cn/problems/unique-paths-ii/description/\n\n![图 4](../../images/daedea27b3b34f0f3f2dc3918470558e95ddeb6e144825cc9d4c4ee71bc9f157.png)\n\n有障碍物的地方路径数量设为0即可解决\n\n**五部曲**\n1、dp数组及下标含义：`dp[i][j]`表示到达i，j的路径数量\n2、递推公式：如果i，j处有障碍，`dp[i][j]=0`，没有障碍`dp[i][j] = dp[i-1][j] + dp[i][j-1]`\n3、初始化,dp数组全部填充为0，dp[0][0] = 1\n4、遍历方法，`i:0~m` `j:0~n`,这种遍历方式要搭配`if(i > 0) dp[i][j] += dp[i-1][j];`\n       `if(j > 0) dp[i][j] += dp[i][j-1];`\n```js\nvar uniquePathsWithObstacles = function(obstacleGrid) {\n  const m = obstacleGrid.length,n=obstacleGrid[0].length\n  let dp = Array(m).fill().map(() => Array(n).fill(0))\n  dp[0][0]=1\n  for(let i=0;i<m;i++){\n    for(let j=0;j<n;j++){\n      if (obstacleGrid[i][j] == 1) dp[i][j]=0\n      else{\n       if(i > 0) dp[i][j] += dp[i-1][j];\n       if(j > 0) dp[i][j] += dp[i][j-1];\n      }\n    }\n  }\n  return dp[m-1][n-1]\n};\n```\n\n### 整数拆分\n> https://leetcode.cn/problems/integer-break/description/\n\n![图 5](../../images/0973eeab5f164bc32658df7db791e2f9168c7c3f99d952b2af1b78f751790f8a.png)\n\n**五部曲**\n1、dp数组及其下标的含义：dp[i]表示i拆分的最大值。\n2、递推公式：\n![图 6](../../images/2705140cd07af477d10403287ff634282fc5501376557f23b3864348d7af5bd9.png)\n\n3、初始化：dp[2] = 1,其余均为0\n4、遍历顺序：按顺序拆，一定拆出1，拆能两个数和多个数；一定拆除2，拆出两个数和多个数...，求每一次拆的最大值。\n![图 7](../../images/4dab8ae9788c244aee65f25e65dc6bfdcada45ccdd33abeef3d12ed5576e1f8e.png)\n\n```js\nvar integerBreak = function(n) {\n  let dp = Array(n+1).fill(0)  //n+1因为dp数组下标的含义\n  dp[2]=1\n  for(let i=0;i<=n;i++){\n    for(let j=1;j<= Math.floor(i/2);j++){\n      dp[i] = Math.max(j*(i-j),j*dp[i-j],dp[i])\n    }\n  }\n  return dp[n]\n};\n```\n\n### 不同的二叉搜索树\n> https://leetcode.cn/problems/unique-binary-search-trees/description/\n\n![图 8](../../images/4be27ebd4649f009fa052403e16f156e0fcf1250222b86c31ba631cd1eb182b1.png)\n\n#### 二叉搜索树\n![图 9](../../images/5d1850b0b802c05b36ab40ea50315b37325ba0c6b60f8bff347de151ed0b5ced.png)\n\n**五部曲**\n1、`dp[i]` 表示i个结点的二叉搜索数的个数\n2、递推公式:`dp[i] += dp[j-1] * dp[i-j]`\n当头结点为j时，**左边一定有j-1个结点**。\n\n3、初始化：`dp[0] = 1`, `dp[1] = 1`, `dp[2]=2`\n4、遍历顺序，第一层for循环负责遍历dp[i]的下标，第二个for循环遍历**头节点的数值**\n![图 10](../../images/e0e2ae62ca4e224974883f439e9ca45f611b2258cf1b021880b79f55e185e9f3.png)\n\n\n\n```js\nvar numTrees = function(n) {\n  let dp = Array(n+1).fill(0)\n  dp[0]=1,dp[1]=1,dp[2]=2\n  for(let i=3;i<=n;i++){\n    for(let j=1;j<=i;j++){\n      dp[i] += dp[j-1]*dp[i-j]\n    }\n  }\n  return dp[n]\n};\n```","tags":["动态规划"],"categories":["算法","动态规划"]},{"title":"KMP算法","url":"/2024/05/24/algrithm/kmp算法/","content":"\n# KMP算法\n> 非常完整的思路https://www.programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF\n>\n三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP\n\n![图 1](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif)\n\n\n## 用途\nKMP主要应用在字符串匹配上。\n\nKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\n\n所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。\n\n## 为什么要用前缀表\n### 什么是前后缀\n**前缀**是指不包含最后一个字符的所有以第一个字符开头的连续子串；\n\n**后缀**是指不包含第一个字符的所有以最后一个字符结尾的连续子串。\n\n### 最长相等前后缀\n首先要了解文本字符串和模式字符串，前者是题目中提到的haystack，后者是needle。eg:'aabaabaaf'，'aabaaf'\n\n前缀表可以告诉我们应该跳转到哪里继续匹配。而不是从模式字符串的头部重新开始匹配。\n\n![图 0](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif)\n\n为什么到下表为5时b!=f，可以直接将模式字符串下标调整到2呢。因为最长前后缀相等。\n![图 1](../../images/7b2e19783ff3286a5c2a050168dba648b9cbb284664384be66b3c15e4993958f.png)\n\n### next实现过程\n![图 3](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B23.gif)\n\n```javascript\nconst getNext = (nextArr, s) => {\n    let j = 0 //i表示后缀末尾，j表示前缀末尾\n    nextArr[0] = 0\n    for (let i = 1; i < s.length; i++) {\n      //什么情况下要向左移动j\n      while (s[i] != s[j] && j > 0) {\n        j = nextArr[j - 1]\n      }\n      if (s[i] == s[j]) {\n        j++\n      }\n      nextArr[i] = j\n    }\n    return nextArr\n  }\n```\n## 使用next前缀表实现字符串匹配\n![图 4](https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B24.gif)\n\n```javascript\nvar strStr = function(haystack, needle) {\n  const getNext = (nextArr, s) => {\n    let j = 0 //i表示后缀末尾，j表示前缀末尾\n    nextArr[0] = 0\n    for (let i = 1; i < s.length; i++) {\n      while (s[i] != s[j] && j > 0) {\n        j = nextArr[j - 1]\n      }\n      if (s[i] == s[j]) {\n        j++\n      }\n      nextArr[i] = j\n    }\n    return nextArr\n  }\n  let Arr = new Array(needle.length)\n  let nextArr = getNext(Arr,needle)\n  let j=0\n  //使用next数组实现匹配的过程\n  for(let i=0;i<haystack.length;i++){\n    //j跳跃的条件\n    while(j>0 && j<needle.length && haystack[i] != needle[j]){\n      j=nextArr[j-1]\n    }\n    if(haystack[i] == needle[j]){\n      j++\n    }\n    // 找到匹配字符串的条件\n    if( j == needle.length){\n      return i-j+1\n    }\n  }\n  return -1\n}\n```\n\n\n## 重复的子字符串\n> https://leetcode.cn/problems/repeated-substring-pattern/description/\n\n![图 2](../../images/11f44157ea2756f208d80728d3a3890196e8fbe584bec3397288960f4ebf448d.png)\n\n\n### 思路1\n\ns+s去掉头和尾，如果s还能出现在其中说明符合题目要求。\n\n```javascript\nvar repeatedSubstringPattern = function (s) {\n  let ss = s + s\n  ss = ss.slice(1, ss.length)\n  ss = ss.slice(0, ss.length - 1)\n  if (ss.includes(s)) {\n    return true\n  } else {\n    return false\n  }\n}\n```\n### 思路2\n\nkmp算法，s.length - 最长相等前后缀，表示重复字符串的长度。\n\n如果能被s.length整除，说明符合条件。\n\n当然如果最长相等前后缀为0，纳智捷说明不符合要求。\n\n```javascript\nvar repeatedSubstringPattern = function(s) {\n  //最长相等前后缀\n  let nextArr = new Array(s.length)\n  nextArr[0] = 0\n  let j = 0\n  for (let i = 1; i < s.length; i++) {\n    while (j > 0 && s[i] != s[j]) {\n      j = nextArr[j - 1]\n    }\n    if (s[i] == s[j]) {\n      j++\n    }\n    nextArr[i] = j\n  }\n  //先判断nextArr[nextArr.length - 1] != 0是重要的\n  // 因为没有最长公共前后缀一定不符合题目要求。\n\n  if (\n    nextArr[nextArr.length - 1] != 0 &&\n    s.length % (s.length - nextArr[nextArr.length - 1]) === 0\n  ) {\n    return true\n  } else {\n    return false\n  }\n};\n```","tags":["KMP"],"categories":["算法","KMP"]},{"title":"翻转字符串中的单词、右旋转字符串","url":"/2024/05/23/algrithm/翻转字符串里的单词/","content":"\n# 翻转字符串中的单词\n> https://leetcode.cn/problems/reverse-words-in-a-string/description/\n\n![图 0](../../images/970e51973b1697f8f9bea71dc107eae947c9ac8028da50a69867ee9483929cc9.png)\n\n## 思路\n<div style=\"padding:15px; color:white; background-color:#f9906f\">\n1、首先需要去除多余的空格<br\neg：'  the  sky is blue    ' --> 'the sky is blue'</div>\n\n```javascript\n// 使用快慢指针，slowIndex,fastIndex\n1.1 先去除字符串首和重复出现的空格\nif (strArr[fastIndex] === ' ' && (fastIndex===0 || strArr[fastIndex-1] === ' '))\n\n1.2 去除字符串尾的空格\n// 长度 = 最后一位索引 + 1；整个循环结束后慢指针的指向是什么。\n// 判断慢指针-1指向的字符是不是空格，是说明原字符串尾部有空格，strArr长度应该是满指针当前位置-1。\n// 否说明原字符串尾部没有空格，strArr长度就是满指针所指的位置。\nstrArr.length = strArr[slowIndex-1] === ' '? slowIndex-1 : slowIndex\n```\n\n<div style=\"padding:15px; color:white; background-color:#f9906f\">\n2、将整个字符串进行翻转 <br>\neg：'the sky is blue' -->  'eulb si yks eht'\n</div>\n\n```javascript\n使用双指针\nwhile(left<right){\n  [strArr[left],strArr[right]] = [strArr[right],strArr[left]]\n  left++\n  right++\n}\n```\n<div style=\"padding:15px; color:white; background-color:#f9906f\">\n3、然后找到每一个单词，对该单词进行翻转<br>\neg：'eulb si yks eht'  --> 'blue is the sky'\n</div>\n\n```javascript\n// 分两步处理\n// 假设字符串中有n个单词，先处理前n个单词，再处理最后一个单词\n```\n\n## 求解\n\n```javascript\n\nvar reverseWords = function (s) {\n  let strArr = Array.from(s)\n  // 去除多余空格的函数\n  const removeBlank = (strArr) => {\n    // 移除前面和中间空格\n    let slowIndex = 0\n    let fastIndex = 0\n    while (fastIndex < strArr.length) {\n      // 去除最前面和中间多余的空格\n      if (\n        strArr[fastIndex] == ' ' &&\n        (fastIndex == 0 || strArr[fastIndex - 1] == ' ')\n      ) {\n        fastIndex++\n      } else {\n        strArr[slowIndex] = strArr[fastIndex]\n        slowIndex++\n        fastIndex++\n      }\n    }\n    strArr.length =\n      strArr[slowIndex - 1] === ' ' ? slowIndex - 1 : slowIndex\n  }\n  //翻转字符串的函数，参数1是字符串，参数2是待处理字符串的起点索引，参数3是待处理字符串的终点索引\n  const reverse_all = (arr, start, end) => {\n    let left = start\n    let right = end\n    while (left < right) {\n      ;[arr[left], arr[right]] = [arr[right], arr[left]]\n      left++\n      right--\n    }\n  }\n  removeBlank(strArr)\n  reverse_all(strArr, 0, strArr.length - 1)\n  let startIndex = 0\n  for (let i = 0; i < strArr.length; i++) {\n    if (strArr[i + 1] == ' ') {\n      reverse_all(strArr, startIndex, i)\n      startIndex = i + 2\n    }\n  }\n  reverse_all(strArr, startIndex, strArr.length - 1)\n  return strArr.join('')\n}\n```\n\n\n# 右旋转字符串\n> https://kamacoder.com/problempage.php?pid=1065\n\n![图 1](../../images/ff25915682b4730fdc7112109a53507a2240d37ecc990d3149be33eaea60bcde.png)\n\n## 思路\n同上一道题思路相似，先全部反转，然后再把两部分各进行一次反转。\n\n![图 3](../../images/059b0603bc14921999c63f2f10cb2f6c1706e7b319c715ad3914705e147aff25.png)\n\n## 代码\n```javascript\nvar right_circle_string = (s,k)=>{\n  let strArr = Array.from(s)\n  //反转函数\n  function reverse_word(sArr,start,end){\n    let left = start,right = end\n    while(left<right){\n      [sArr[left], sArr[right]] = [sArr[right], sArr[left]]\n      left++\n      right--\n    }\n    return sArr\n  }\n  strArr = reverse_word(strArr,0,strArr.length-1)\n  strArr = reverse_word(strArr,0,k-1)\n  strArr = reverse_word(strArr,k,strArr.length-1)\n  return strArr\n}\n```","tags":["双指针","字符串"],"categories":["算法","字符串"]},{"title":"划分字母区间","url":"/2024/05/20/algrithm/划分字母区间/","content":"\n# 划分字母区间\n> https://leetcode.cn/problems/partition-labels/description/\n\n![图 0](../../images/0de3969edf914a852c452928fe15486d6c6af9141385b5c9b26aa783763d78f3.png)\n\n## 思路\n1、使用哈希表将每个字符的最远位置记录下来\n2、从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点\n\n![图 1](../../images/c11652269aa5d7487328a016f8c5c22982e10caea9829ca4030f0f0d41d7e4d6.png)\n\n\n## 求解\n```javascript\nvar partitionLabels = function(s) {\n  let map = new Map()\n  for(let i=0;i<s.length;i++){\n    map.set(s[i],i)\n  }\n  let result = []\n  let left=0,right=0\n  for(let i=0;i<s.length;i++){\n    right = Math.max(right,map.get(s[i]))\n    // 找到分割点的标志。\n    if (right === i){\n      result.push(right-left+1)\n      left = i+1\n    }\n  }\n  return result\n};\n```\n","tags":["哈希表","贪心"],"categories":["算法","贪心"]},{"title":"单调递增的数字","url":"/2024/05/20/algrithm/单调递增的数字/","content":"\n# 单调递增的数字\n\n## 思路\n这个思路我是想不到，想到了就很容易实现了。\n\n一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9\n\n此时是从前向后遍历还是从后向前遍历呢？\n\n从前向后遍历的话，遇到strNum[i - 1] > strNum[i]的情况，让strNum[i - 1]减一，但此时如果strNum[i - 1]减一了，可能又小于strNum[i - 2]。\n\n这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。\n\n那么从**后向前遍历**，就可以重复利用上次比较得出的结果了，**从后向前遍历332的数值变化为：332 -> 329 -> 299**\n\n确定了遍历顺序之后，那么此时局部最优就可以推出全局，找不出反例，试试贪心。\n\n\n## 求解\n```javascript\nvar monotoneIncreasingDigits = function(n) {\n  let str = n.toString().split('')\n  for(let i=str.length-1;i>0;i--){\n    if (str[i]<str[i-1]){\n      str[i-1]--\n      for(let j=i;j<str.length;j++){\n        str[j] = 9\n      }\n    }\n  }\n  return parseInt(str.join(''))\n};\n```","tags":["贪心"],"categories":["算法","贪心"]},{"title":"根据身高重建队列","url":"/2024/05/20/algrithm/根据身高重建队列/","content":"\n# 根据身高重建队列\n> https://leetcode.cn/problems/queue-reconstruction-by-height/description/\n\n![图 0](../../images/630e27d9d09c2a2e776269eb7dc066179116172e8669e688483e73a14228b7fb.png)\n\n\n## 思路\n这里的队列顺序很明显取决于两个关键因素。h和k，因此现根据一个因素排序，接着再根据另外一个因素进行调整。\n\n如果先按照k进行排序，会发现k不符合条件，身高也不符合条件。\n因此需要先按照h进行排序，排序完成后在根据身高依次遍历每一个数组，并根据k调整位置即可。\n\n要注意第一次排序，身高降序排列，如果身高相同，根据k值升序排。这是为了后续调整插入队列时可以根据k直接确定位置。\n\n![图 1](../../images/ecd5185a529be597ff9eba1b72d73a3f74727a1814bf8007c75ae322759d87b0.png)\n\n按照身高排序之后，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。\n\n所以在按照身高从大到小排序后：\n\n**局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**\n\n**全局最优：最后都做完插入操作，整个队列满足题目队列属性**\n\n局部最优可推出全局最优，找不出反例，那就试试贪心。\n\n\n## 求解\n```javascript\nvar reconstructQueue = function (people) {\n  let queue = []\n  //这段代码的排序规则是：\n  //首先按照身高h降序排序，也就是说，身高高的人会排在身高低的人前面。\n  //如果身高h相同，那么按照k值升序排序，也就是说，k值小的人会排在k值大的人前面。\n  people.sort((a, b) => {\n    if (b[0] !== a[0]) {\n      return b[0] - a[0]\n    } else {\n      return a[1] - b[1]\n    }\n  })\n\n  for (let i = 0; i < people.length; i++) {\n    queue.splice(people[i][1], 0, people[i])\n  }\n  return queue\n}\n```\n\n\n\n## arr.splice()\nsplice() 是 JavaScript 中数组对象的一个方法，用于在**数组中添加、删除或替换元素。**\n\nsplice() 方法接受三个参数：\n\n* start：开始修改的位置（索引）。\n* deleteCount：要删除的元素数量。如果省略或大于 start 之后的元素数量，那么 start 之后的所有元素都会被删除。\n* item1, item2, ...：要添加到数组中的元素。这些元素将被添加到 start 参数指定的位置。如果省略这些参数，splice() 将只删除元素。\n\n\n\n如果你想在数组中插入元素，你可以使用splice()方法，并将要删除的元素数量设置为0，然后提供要插入的元素。例如：\n\n```javascript\nlet arr = [1, 2, 3];\narr.splice(1, 0, 'a');  // 在索引1的位置插入'a'\nconsole.log(arr);  // 输出：[1, 'a', 2, 3]\n```\n\n如果你想从数组中删除元素，你可以使用splice()方法，并提供要删除的元素的开始位置和数量，不需要提供要插入的元素。例如：\n\n```javascript\nlet arr = [1, 2, 3];\narr.splice(1, 1);  // 从索引1的位置删除1个元素\nconsole.log(arr);  // 输出：[1, 3]\n```\n\n如果你想替换数组中的元素，你可以使用splice()方法，并提供要替换的元素的开始位置和数量，以及要插入的新元素。例如：\n\n```javascript\nlet arr = [1, 2, 3];\narr.splice(1, 1, 'a');  // 从索引1的位置删除1个元素，并插入'a'\nconsole.log(arr);  // 输出：[1, 'a', 3]\n```\n","tags":["贪心","splice"],"categories":["算法","贪心"]},{"title":"监控二叉树","url":"/2024/05/20/algrithm/监控二叉树/","content":"\n# 监控二叉树\n> https://leetcode.cn/problems/binary-tree-cameras/description/\n\n![图 1](../../images/dd13ff2f4dc63dd62759f99aaf9ed1a09ee9566644137ab87bb6f71198a2ab70.png)\n\n\n## 思路\n此时这道题目还有两个难点：\n* 二叉树的遍历\n  前：根左右\n  中：左根右\n  **后：左右根**\n* 如何隔两个节点放一个摄像头\n  * 1、根据当前节点的左右节点的状态来确定，是否安装摄像头\n    0：无覆盖\n    1：有摄像头\n    2：有覆盖\n  * 2、具体的左右节点状态对应的行动\n    1、左右节点都**有一个没有覆盖**：安装摄像头，result++，return 1\n    2、左右节点**有一个安装了摄像头**，说明当前节点有覆盖，return 2\n    3、左右节点**都有覆盖**，当前节点不安装摄像头，return 0\n    4、最优如果**根节点状态为0**，为根节点安装摄像头。\n\n![图 2](../../images/b37c0b4521575c16a5b67ae350654f2c511625a2a36fbe4fc741236f3577180d.png)\n\n## 求解\n```javascript\nvar minCameraCover = function(root) {\n  let result = 0\n  //递归后序遍历\n  const dfs = (node)=>{\n    if(!node) return 2\n    let left = dfs(node.left)\n    let right = dfs(node.right)\n    if(left === 0 || right === 0){\n      result++\n      return 1\n    }\n    if(left === 1 || right === 1){\n      return 2\n    }\n    if(left === 2 && right === 2){\n      return 0\n    }\n  }\n  if(dfs(root) === 0){\n    result++\n  }\n  return result\n};\n```","tags":["贪心","二叉树"],"categories":["算法","贪心"]},{"title":"用最少的箭引爆箭头、无重叠区间、合并区间","url":"/2024/05/20/algrithm/用最少数量的箭引爆气球/","content":"\n# 用最少的箭引爆箭头\n> https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/\n\n![图 0](../../images/0b34c4757f72c3c9c277398e04210b06b3435bb0bea8612102bdc01351d11628.png)\n\n## 思路\n1、排序：将气球按照左边界升序排序\n\n2、什么情况箭数量要增加：points[i][0] > points[i-1][1]\n\n3、怎么判断多个气球是都重叠：更新当前气球有边界。\npoints[i] = min(points[i][1],points[i-1][1])\n\n## 求解\n```javascript\nvar findMinArrowShots = function(points) {\n  if( points.length === 0) return 0\n  let result = 1\n  points.sort((a,b)=>{\n    return a[0] - b[0]\n  })\n  for(let i=1;i<points.length;i++){\n    if (points[i][0]>points[i-1][1]){\n      result++\n    }\n    else{\n      points[i][1] = Math.min(points[i][1],points[i-1][1])\n    }\n  }\n  return result\n};\n```\n\n\n# 无重叠区间\n> https://leetcode.cn/problems/non-overlapping-intervals/description/\n\n![图 1](../../images/7f5cd46c416b177632f611316da3dab365d2f6c1445006413b9d12e23fac0e2a.png)\n\n## 思路\n基本思路和上一题一毛一样\n1、排序\n2、result = 重叠区间数\n\n## 求解\n```javascript\nvar eraseOverlapIntervals = function(intervals) {\n  if (intervals.length === 0) return 0\n  let count = 0\n  intervals.sort((a,b)=>{\n    return a[0] - b[0]\n  })\n  for(let i=1;i<intervals.length;i++){\n    if(intervals[i][0] < intervals[i-1][1]) {\n      count++\n      intervals[i][1] = Math.min(intervals[i][1], intervals[i - 1][1])\n    }\n  }\n  return count\n};\n```\n\n\n# 合并区间\n> https://leetcode.cn/problems/merge-intervals/description/\n\n![图 2](../../images/1caebbc18ff49a7e7114245cbb49c94b2d9d6ad5455f406ec00ce359cf76bf4f.png)\n\n\n## 思路\n判断 当前区间与前一个区间是否重叠，如果不重叠，将前一个区间加入结果中。如果重叠，修改当前区间的左（最小）右（最大）值。\n\n\n## 求解\n```javascript\nvar merge = function(intervals) {\n  if(intervals.length === 0) return []\n  let result = []\n  intervals.sort((a,b)=>{\n    return a[0]-b[0]\n  })\n  for(let i=1;i<intervals.length;i++){\n    if(intervals[i][0] > intervals[i-1][1]){\n      result.push(intervals[i-1])\n    }\n    else{\n      intervals[i][1] = Math.max(intervals[i][1],intervals[i-1][1])\n      intervals[i][0] = intervals[i-1][0]\n    }\n  }\n  result.push(intervals[intervals.length-1])\n  return result\n};\n```\n","tags":["贪心"],"categories":["算法","贪心"]},{"title":"分发糖果","url":"/2024/05/17/algrithm/分发糖果/","content":"\n# 分发糖果\n> https://leetcode.cn/problems/candy/description/\n\n![图 0](../../images/6947e9cae0913c5f0604af1b474d3f3a53fc168dfba8050a7a76ec7cf61820ee.png)\n\n## 思路\n题目要求和相邻的孩子比较，相邻的孩子有两个，左边的和右边的。\n\n**一次遍历解决两边的孩子，容易顾此失彼，所以可以分两次遍历**。\n\n**正序遍历时考虑左边的孩子（当前节点左边的）**，如果ratings[i]>ratings[i-1]，那么candys[i] = candys[i-1]+1。\n\n**逆序遍历考虑右边的孩子（当前节点右边的）**，如果ratings[i] > ratings[i+1]，那么\ncandys[i] = Math.max(candys[i], candys[i+1]+1)。\n\n正序遍历做的事儿和反序遍历做的事儿不能对调，**因为正序时，当前元素的左边元素一定时都处理过的**，这样不会出错。**反之逆序时，当前节点的右边节点也都处理过**，不会出错。\n\n## 求解\n```javascript\nvar candy = function(ratings) {\n  let candys = new Array(ratings.length).fill(1);\n  for(let i=1;i<ratings.length;i++){\n    if(ratings[i]>ratings[i-1]){\n      candys[i] = candys[i-1]+1;\n    }\n  }\n  for(let i=ratings.length-2;i>=0;i--){\n    if(ratings[i]>ratings[i+1]){\n      candys[i] = Math.max(candys[i],candys[i+1]+1)\n    }\n  }\n  return candys.reduce((a,b)=>a+b,0)\n};\n```","tags":["贪心"],"categories":["算法","贪心"]},{"title":"加油站","url":"/2024/05/17/algrithm/加油站/","content":"\n# 加油站\n> https://leetcode.cn/problems/gas-station/description/\n\n![图 0](../../images/f58fadec507a407ede6e6a498b59554764de78562ecc94f828909613b5f721f6.png)\n\n## 思路\n1、首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。\n\n2、每一站的剩余油量rest[i] = gas[i]-cost[i]\n\n3、i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。\n\n![图 1](../../images/6eb4386e752bc6c014f81c0fe9757add570c0f8e506b047de21277bdbd775a11.png)\n\n4、那么为什么一旦[0，i] 区间和为负数，起始位置就可以是i+1呢，i+1后面就不会出现更大的负数？如果出现更大的负数，就是更新i，那么起始位置又变成新的i+1了。\n\n那有没有可能 [0，i] 区间 选某一个作为起点，累加到 i这里 curSum是不会小于零呢？ 如图：\n![图 2](../../images/c37b1e66c0071c3bd0857644455b32fa1c32e3440ce6622f756721984952b383.png)\n\n如果 curSum<0 说明 区间和1 + 区间和2 < 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2>0。\n\n区间和1 + 区间和2 < 0 同时 区间和2>0，只能说明区间和1 < 0， 那么就会从假设的箭头初就开始从新选择其实位置了。\n\n那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。\n\n局部最优可以推出全局最优，找不出反例，试试贪心！\n\n## 求解\n```javascript\nvar canCompleteCircuit = function(gas, cost) {\n  let rem = []\n  for(let i=0;i<gas.length;i++){\n    rem.push(gas[i]-cost[i])\n  }\n  let sum = rem.reduce((a,b)=>a+b,0)\n  if (sum<0) return -1\n  let cursum = 0\n  let start = 0\n  for(let i=0;i<rem.length;i++){\n    cursum += rem[i]\n    if (cursum<0){\n      start = i+1\n      cursum = 0\n      continue\n    }\n  }\n  return start\n};\n```\n\n```javascript\n// 更优解，ai根据我上面的代码做的简化，只需一层for循环\nvar canCompleteCircuit = function(gas, cost) {\n  let total = 0, sum = 0, start = 0;\n  for(let i = 0; i < gas.length; i++){\n    total += gas[i] - cost[i];\n    sum += gas[i] - cost[i];\n    if(sum < 0){\n      start = i + 1;\n      sum = 0;\n    }\n  }\n  return total < 0 ? -1 : start;\n};\n```\n","tags":["贪心"],"categories":["算法","贪心"]},{"title":"买卖股票的最佳时机II","url":"/2024/05/14/algrithm/买卖股票的最佳时机II/","content":"\n# 买卖股票的最佳时机II\n> https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/\n\n## 思路\n这道题目可能我们只会想，选一个低的买入，再选个高的卖，再选一个低的买入.....循环反复。\n\n如果想到其实最终利润是可以分解的，那么本题就很容易了！\n\n如何分解呢？\n\n假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。\n\n**相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。**\n\n此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！\n\n那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。\n\n如图：\n\n![图 0](../../images/4ca1d61d6948fbfe77deb4793459309e18e600f9b347655c38f629a17f9a3b0a.png)\n\n\n## 求解\n```javascript\nvar maxProfit = function(prices) {\n  let result = 0;\n  for(let i=0;i<prices.length-1;i++){\n    if(prices[i+1]>prices[i]){\n      result += prices[i+1] - prices[i]\n    }\n  }\n  return result\n};\n```","tags":["贪心"],"categories":["算法","贪心"]},{"title":"最大子数组和","url":"/2024/05/14/algrithm/最大子数组和/","content":"\n# 最大子数组和\n> https://leetcode.cn/problems/maximum-subarray/description/\n\n![图 0](../../images/1a9a299cc0c4df2921f88f1e0650741e5e56caced81e94277f394af673f7ae8f.png)\n\n## 思路\n贪心的思路是，如果+nums[i]后子数组和为负数，那么以nums[i+1]为起始点进行遍历\n\n![图 1](https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif)\n\n卡哥说初始result要是计算机能表示的**最小的整数**，刚开始我不理解。现总结这样做的目的。\n\n首先我们有两个变量result和count，**result负责保存最终的结果，count保存遍历过程中子数组的和**。\n\n如果数组中有正整数，那么其实没必要result为最小整数。但我们不能保证数组中一定有正整数。 想一个极端的例子，**数组中全是负数的情况**。\n\n在遍历到第1个负数的时候，result就被赋值为当前这个负数，此时count为负数，那么放弃这个起点，以第2个数为起点。如果第二个数大于第一个数，那么result被赋值为第2个负数。以此类推，**result会是数组中最大的负数**。\n\n\n## 求解\n```javascript\nvar maxSubArray = function(nums) {\n  //是为了解决数组中全是负数的情况。\n  result = Number.MIN_SAFE_INTEGER\n  sum = 0\n  for(let i=0;i<nums.length;i++){\n   sum += nums[i]\n   if(sum>result){\n     result = sum\n   }\n   if(sum<0){\n    sum = 0\n   }\n  }\n  return result\n};\n```","tags":["贪心"],"categories":["算法","贪心"]},{"title":"跳跃游戏","url":"/2024/05/14/algrithm/跳跃游戏/","content":"\n# 跳跃游戏\n> https://leetcode.cn/problems/jump-game/description/\n\n![图 0](../../images/1fad9bcd4dd23a245b7b29dc6e22ed5f7f67c5e8af6ac87a2b4a6978f1a667a8.png)\n\n## 思路\n刚看到本题一开始可能想：当前位置元素如果是 3，我究竟是跳一步呢，还是两步呢，还是三步呢，究竟跳几步才是最优呢？\n\n其实跳几步无所谓，关键在于可跳的覆盖范围！\n\n不一定非要明确一次究竟跳几步，每次取最大的跳跃步数，这个就是可以跳跃的覆盖范围。\n\n这个范围内，别管是怎么跳的，反正一定可以跳过来。\n\n那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！\n\n每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。\n\n贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。\n\n局部最优推出全局最优，找不出反例，试试贪心！\n\n如图：\n\n![图 1](../../images/139885f5ec9eee87a7d1fb9d91bc5c9f4debb9a333348921fabff9a7f396ce3b.png)\n\n\n## 求解\n```javascript\nvar canJump = function(nums) {\n  let max = 0;\n  for(let i=0;i<=max;i++){\n    if (i+nums[i]>max) max = i+nums[i]\n    if(max>=nums.length-1) return true\n  }\n  return false\n};\n```\n\n求解过程中，写过一个错误版本，就是给max赋值之前没有判断。有一部分例子没法通过。\n\n当时没通过的案例是[3,0,8,0,0,2],在这个案例中，如果不做判断那么覆盖范围max会卡在 1+0\n\n# 跳跃游戏II\n> https://leetcode.cn/problems/jump-game-ii/description/\n\n![图 2](../../images/d3556952d6d1908fc868fc2054b8e15d4c5e8b18c4bdac00d7b72943c65850a1.png)\n\n## 思路\n本题相对于55.跳跃游戏 (opens new window)还是难了不少。\n\n但思路是相似的，还是要看最大覆盖范围。\n\n本题要计算最少步数，那么就要想清楚什么时候步数才一定要加一呢？\n\n贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。\n\n思路虽然是这样，但在写代码的时候还不能真的能跳多远就跳多远，那样就不知道下一步最远能跳到哪里了。\n\n**所以真正解题的时候，要从覆盖范围出发，不管怎么跳，覆盖范围内一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最少步数！**\n\n**这里需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。**\n\n如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。\n\n如图：\n![图 3](../../images/c9ad75a771370be7f6125b038f956400f64cc4077e3d2afb4d619d9626e7a492.png)\n\n**图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！（不用管具体怎么跳，反正一定可以跳到）**\n\n## 求解\n\n```javascript\nvar jump = function(nums) {\n  let cover = 0\n  let step = 0\n  let last = 0\n  for(let i=0;i<nums.length-1;i++){\n    cover = Math.max(cover,i+nums[i])\n    // 走了step步还没到终点，说明步数需要+1，\n    // last记录的是当前覆盖范围的最后一个位置\n    if(i === last){\n      last = cover\n      step++\n    }\n  }\n  return step\n};\n```\n\n\n\n","tags":["贪心"],"categories":["算法","贪心"]},{"title":"Array.sort()","url":"/2024/05/14/es6/sort/","content":"\n# sort()\nES6 中的 `Array.prototype.sort()` 方法有以下几个特点：\n\n1、原地排序：`sort()` 方法会在原数组上进行排序，而不是创建一个新的排序后的数组。\n\n2、默认的排序顺序是按照字符串的 `Unicode` 码点顺序：如果在 `sort()` 方法中没有提供比较函数，那么数组元素会先被转换为字符串，然后再按照字符的 `Unicode` 码点顺序进行排序。例如，数字数组 `[10, 2, 11]` 会被排序为 `[10, 11, 2]`。\n\n3、可以接受一个比较函数作为参数：你可以提供一个比较函数来自定义排序顺序。比较函数应该接受两个参数，返回一个负数、零或正数，来表示第一个参数应该排在第二个参数的前面、与第二个参数相等或后面。\n\n4、稳定排序：从 ES2019 开始，`Array.prototype.sort()` 是稳定的。这意味着如果两个元素相等，它们的原始顺序会被保留\n\n<div style=\"background-color:#d07a82; padding:20px; color:white; margin-bottom:20px;\">\n我一直对这个方法有误解，我以为sort((a,b) => a-b)，参数为负数表示倒序，参数为正表示顺序。\n实则不然，它确定排序的方法在于a,b。\n\n在 sort() 方法的比较函数 ((a, b) => a - b) 中，a 和 b 是数组中的两个元素。\n\n当 sort() 方法执行排序时，它会遍历数组，每次选择两个元素，然后传递给比较函数。比较函数的任务是决定这两个元素的顺序。\n\n例如，如果你有一个数组 [3, 1, 4] 并且你调用 sort((a, b) => a - b)，那么在排序过程中，a 和 b 可能会是 (3, 1) 或者 (1, 4) 等等。\n\n比较函数的返回值决定了 a 和 b 的排序顺序：\n\n如果比较函数返回一个小于 0 的值，那么 a 会被排在 b 的前面。\n如果比较函数返回 0，那么 a 和 b 的顺序不变。\n如果比较函数返回一个大于 0 的值，那么 b 会被排在 a 的前面。\n所以在 ((a, b) => a - b) 中，如果 a 小于 b，那么返回值是负数，a 会被排在 b 的前面，这就实现了升序排序。\n\n</div>\n\n结论是:b-a降序, a-b升序\na-b时，if a-b>0, b排前面，升序；if a-b<0,  a排在前面，升序。\nb-a时，if b-a>0, b排前面,降序；if b-a<0,  a排在前面，降序。\n\n\n```javascript\nlet arr2 = [8,1,5,9,3,4,2,6,7]\nconsole.log(arr2.sort((a,b)=>b-a))\n// [9, 8, 7, 6, 5, 4, 3, 2, 1]\n\nlet arr2 = [1,8,5,9,3,4,2,6,7]\nconsole.log(arr2.sort((a,b)=>b-a))\n// [9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n\nlet arr2 = [8,1,5,9,3,4,2,6,7]\nconsole.log(arr2.sort((a,b)=>a-b))\n//[1,2,3,4,5,6,7,8,9]\n\nlet arr3 = [1, 8, 5, 9, 3, 4, 2, 6, 7]\nconsole.log(arr3.sort((a, b) => a - b))\n//[1,2,3,4,5,6,7,8,9]\n\n```","tags":["排序"],"categories":["基础","Array"]},{"title":"摆动序列","url":"/2024/05/13/algrithm/摆动序列/","content":"\n\n# 摆动序列\n> https://leetcode.cn/problems/wiggle-subsequence/description/\n\n![图 0](../../images/4bdb52616df1c35068c7d292fa79e40533c2f61aa7a5240165290b4d077b7cd4.png)\n\n贪心算法思路：\n1、找到峰值，prediff和currdiff一正一负。prediff = nums[i] - nums[i-1],currdiff = nums[i+1] - nums[i]。\n\n**(prediff > 0 && currdiff < 0) || (prediff < 0 && currdiff > 0)**\n\n![图 1](../../images/2bfc9f434c24e0977c5b74fb1079a99a2f53be4f236dbbb1164a48cb13ad459f.png)\n\n\n\n2、特殊情况，遇到平坡的情况\n这种坡的特点是坡是峰位。那么我们可以把相同的数字删除到只剩一个，即可得到正确答案，这里选择只保留平坡最右边的元素。也就是说prediff可以等于0。\n\n**(prediff >= 0 && currdiff < 0) || (prediff <= 0 && currdiff > 0)**\n\n![图 2](../../images/03fe2e2fabfc95a5969cbda309fc5edb39648d4a0d853cf02bafad1896947f5f.png)\n\n\n3、首尾元素\n题目中说了，如果只有两个不同的元素，那摆动序列也是 2。如果只有两个元素，但元素是相同的，那么摆动序列只有一个。\n因此可以简单的做判断，确定result。\n\n**当然可以想的更正规一点，更科学一点。**\n\n可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？\n\n之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff < 0 或者 >0 也记为波谷。\n\n那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0，如图：\n\n![图 3](../../images/48d15df2d0df794dea16aa17576f86425f2c1f019965d712bd49fe833c772d36.png)\n\n\n4、情况四单调坡度有平坡\n只考虑上述的三种特殊情况的话，我们忽略了一种情况，即 如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]，如图：\n\n图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。\n\n之所以会出问题，是因为我们实时更新了 prediff。**那么我们应该什么时候更新 prediff 呢？**\n\n我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。\n\n![图 4](../../images/4811a957db1ed06a492a2ac327fdbbde0107d03c0410066ca20f5479dd925741.png)\n\n\n```javascript\nvar wiggleMaxLength = function(nums) {\n  if (nums.length < 2) {\n    return 1;\n  }\n  result = 1\n  prediff = 0\n  currdiff = 0\n  for(let i=0;i<nums.length-1;i++){\n    currdiff = nums[i + 1] - nums[i]\n    if((prediff<=0 && currdiff>0) || (prediff>=0 && currdiff<0)){\n      result++\n      prediff = currdiff\n    }\n  }\n  return result\n};\n```","tags":["贪心"],"categories":["算法","贪心"]},{"title":"分发饼干","url":"/2024/05/12/algrithm/分发饼干/","content":"\n# 分发饼干\n> https://leetcode.cn/problems/assign-cookies/\n\n![图 0](../../images/cc11d9d50ce2347e3c3e7bb675ab027e84cb17d6c0107e1978b03bd484b9f6bf.png)\n\n策略：size大的饼干给胃口大的小孩。\n![图 1](../../images/c30e858ead6f3fb797f368e2d8a290d150ff96af99c65e4fe55cbefcf5f3a256.png)\n\n\n步骤：\n1、两个数组进行排序\n2、外循环遍历小孩胃口\n3、内循环遍历饼干\n\n```javascript\nvar findContentChildren = function(g, s) {\n  s.sort((a,b)=>a-b);\n  g.sort((a,b)=>a-b);\n  let count = 0;\n  //遍历小孩胃口\n  let j = s.length-1;\n  for(let i=g.length-1;i>=0;i--){\n    //遍历饼干，如果饼干满足要求，count+1，然后跳出while循环，考虑下一个小孩\n    while(s[j]>=g[i]){\n      count++;\n      j--\n      break;\n    }\n  }\n  return count;\n};\n```","tags":["贪心"],"categories":["算法","贪心"]},{"title":"贪心算法理论基础","url":"/2024/05/12/algrithm/贪心算法/","content":"\n\n# 贪心算法\n## 什么是贪心\n**贪心的本质是选择每一阶段的局部最优，从而达到全局最优。**\n\n这么说有点抽象，来举一个例子：\n\n例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？\n\n指定每次拿最大的，最终结果就是拿走最大数额的钱。\n\n每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。\n\n再举一个例子如果是 有一堆盒子，你有一个背包体积为n，如何把背包尽可能装满，如果还每次选最大的盒子，就不行了。这时候就需要动态规划。动态规划的问题在下一个系列会详细讲解。\n\n## 贪心的两个极端\n很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。\n\n**说实话贪心算法并没有固定的套路。**\n\n所以唯一的难点就是如何通过局部最优，推出整体最优。\n\n那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？\n\n**不好意思，也没有！** 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。\n\n有同学问了如何验证可不可以用贪心算法呢？\n\n**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。**\n\n可有有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。\n\n一般数学证明有如下两种方法：\n\n数学归纳法\n反证法\n看教课书上讲解贪心可以是一堆公式，估计大家连看都不想看，所以数学证明就不在我要讲解的范围内了，大家感兴趣可以自行查找资料。\n\n**面试中基本不会让面试者现场证明贪心的合理性，代码写出来跑过测试用例即可，或者自己能自圆其说理由就行了。**\n\n举一个不太恰当的例子：我要用一下1+1 = 2，但我要先证明1+1 为什么等于2。严谨是严谨了，但没必要。\n\n虽然这个例子很极端，但可以表达这么个意思：**刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心。**\n\n**例如刚刚举的拿钞票的例子，就是模拟一下每次拿做大的，最后就能拿到最多的钱，这还要数学证明的话，其实就不在算法面试的范围内了，可以看看专业的数学书籍！**\n\n所以这也是为什么很多同学通过（accept）了贪心的题目，但都不知道自己用了贪心算法，因为贪心有时候就是常识性的推导，所以会认为本应该就这么做！\n\n**那么刷题的时候什么时候真的需要数学推导呢？**\n\n例如这道题目：链表：环找到了，那入口呢？ (opens new window)，这道题不用数学推导一下，就找不出环的起始位置，想试一下就不知道怎么试，这种题目确实需要数学简单推导一下。\n\n## 贪心的套路\n想到局部最优是什么，然后想不出来反例，就可以用贪心算法了。\n看了卡哥视频，就是要多刷题，见过套路才会写，没见过套路的一些比较难的题目很难通过总结规律做出来，因为每道题的规律都不同。\n\n\n\n## 题目：k次取反后最大化的数组和\n> https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/\n\n![图 0](../../images/b38a9ea792d092f4064b8a1f89bf12dc0f4e509bafce126ec722a5dea3583e05.png)\n\n\n```javascript\nvar largestSumAfterKNegations = function(nums, k) {\n  // 这里必须是降序，因为前面的负数越大，越能减小和\n  nums.sort((a,b)=>Math.abs(b)-Math.abs(a));\n  let sum = 0\n  for(let i=0;i<nums.length;i++){\n    if (nums[i]<0 && k>0){\n      nums[i] = -nums[i];\n      k--\n    }\n    sum += nums[i];\n  }\n  if (k%2 === 1){\n    sum -= 2*nums[nums.length - 1];   // 2到-2差是4，所以减去2倍最小值\n  }\n  return sum;\n};\n我整错了，我刚开始竟然升序对绝对值进行了排序，可恶了。\n```","tags":["贪心"],"categories":["算法","贪心"]},{"title":"四数之和","url":"/2024/05/10/algrithm/四数之和/","content":"\n# 四数之和\n> https://leetcode.cn/problems/4sum/\n\n\n## 思路\n四数之和和三数之和的思路是一脉相承的，只不过三数之和是一层for循环，每次遍历一个数。四数之和可以用双层for循环。\n\n剪枝的思路与三数之和有些不同呢，三数之和的目标值是0，而四数之和的目标值是不固定的，如果遇到负数情况会有所不同。num>target不能直接退出，如果后面加负数的话，target会变小。\n* （看整体动态的过程）这个逻辑不影响right和left的变化，因为right--，sum会减小是必然，left++sum会增大也是必然。\n* （看静态的遍历到num[i]的时候，左右指针还没动的时候）变化的点在于，num[i] > target,如果target是0，那么num[i]之后的数都必然大于0。 而当target<0时情况便有所不同了，num[i]>target,如果num[i+1]<0,num[i]+num[i+1]一定小于num[i]。\n## 代码\n```javascript\nvar fourSum = function(nums, target) {\n  let res = [];\n  nums.sort((a,b)=>a-b);\n  for(let i=0;i<nums.length-3;i++){\n    //去重\n    if(i>0 && nums[i]===nums[i-1]) continue;\n    //剪枝\n    if(num[i]>0 && num[i] > target) continue;\n    for(let j=i+1;j<nums.length-2;j++){\n      //去重\n      if(j>i+1 && nums[j]===nums[j-1]) continue;\n      //剪枝\n      if(nums[i]+nums[j]>0 && nums[i]+nums[j] > target) continue;\n      let left = j+1;\n      let right = nums.length-1;\n      while(left<right){\n        let sum = nums[i] + nums[j] + nums[left] + nums[right];\n        if (sum > target) right--;\n        if (sum < target) left++;\n        if(sum === target){\n          res.push([nums[i],nums[j],nums[left],nums[right]]);\n          while(left<right && nums[left] === nums[left+1]) left++;\n          while(left<right && nums[right] === nums[right-1]) right--;\n          left++;\n          right--;\n        }\n      }\n    }\n  }\n  return res;\n};\n```","tags":["哈希表"],"categories":["算法","哈希表"]},{"title":"三数之和","url":"/2024/05/09/algrithm/三数之和/","content":"\n# 三数之和\n> https://leetcode.cn/problems/3sum/description/\n\n## 双指针法\n### 思路\n![图 0](https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)\n\n1、拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。\n\n2、依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a = nums[i]，b = nums[left]，c = nums[right]。\n\n3、接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。\n\n4、如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。\n\n### 去重\n* a去重逻辑\n 当前遍历元素和前一个元素重复是，跳过\n\n* b和c去重逻辑\n  - 如果当前left元素和left++对一个的元素相同，left++跳过。同理right和right--元素对比。\n  - 当然如果不相同，left++的同时right--\n\n```javascript\nvar threeSum = function(nums) {\n  let res = [];\n  nums.sort((a,b)=>a-b);\n  for(let i=0;i<nums.length-2;i++){\n    //剪枝\n    if (nums[i] > 0) return\n    //a去重逻辑，如果当前元素和前一个元素相同，跳过\n    if(i>0 && nums[i]===nums[i-1]) continue;\n    let left = i+1;\n    let right = nums.length-1;\n    while(left<right){\n      let sum = nums[i] + nums[left] + nums[right];\n      if (sum > 0) right--;\n      if (sum < 0) left++;\n      if(sum === 0){\n        res.push([nums[i],nums[left],nums[right]]);\n        //bc去重逻辑,如果left和right的元素和前一个元素相同，跳过\n        while(left<right && nums[left] === nums[left+1]) left++;\n        while(left<right && nums[right] === nums[right-1]) right--;\n        left++;\n        right--;\n      }\n    }\n  }\n  return res;\n};\n```\n\n## 回溯算法\n我的初始想法是用回溯算法，但是这个方法在处理较长的数组时会超时。\n```javascript\n// 回溯算法\nvar threeSum = function(nums) {\n  let res = [];\n  let path =[];\n  nums = nums.sort((a,b)=>a-b);\n  const  backTraking = (nums,startIndex)=>{\n    if(path.length === 3){\n      if(path[0]+path[1]+path[2] === 0){\n        res.push([...path])\n      }\n      return;\n    }\n    // 剪枝\n    if (path.length === 0 && nums[startIndex] > 0) return;\n    if (path.length === 1 && nums[startIndex]+path[0] > 0) return;\n    if (path.length === 2 && nums[startIndex]+path[0]+path[1]>0) return;\n    for(let i=startIndex;i<nums.length;i++){\n      if(i>startIndex && nums[i] === nums[i-1]){\n        continue;\n      }\n      path.push(nums[i]);\n      backTraking(nums,i+1);\n      path.pop();\n    }\n  }\n  backTraking(nums,0);\n  return res\n};\n```\n\n\n","tags":["哈希表","回溯"],"categories":["算法","哈希表"]},{"title":"四数相加II","url":"/2024/05/09/algrithm/四数相加/","content":"\n# 四数相加II\n> https://leetcode.cn/problems/4sum-ii/description/\n\n<div style=\"background-color:#426666; padding:20px; color:white; margin-bottom:20px;\">\n有四个数组，将前两个数组中的值相加a+b。将值存放在map中的key，出现次数为相应key的value，然后遍历后两个数组两两相加的值，如果0-nums3[i]-nums4[j]在map中，则count+= 出现次数\n</div>\n\n\n**本题解题步骤：**\n\n* 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。\n* 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。\n* 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。\n* 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。\n* 最后返回统计值 count 就可以了\n\n\n```javascript\nvar fourSumCount = function(nums1, nums2, nums3, nums4) {\n  let map = new Map()\n  //前两个数组中的数两两相加，所以是双层for循环。\n  for(let i=0;i<nums1.length;i++){\n    for(let j=0;j<nums2.length;j++){\n      if (map.has(nums1[i]+nums2[j])){\n        map.set(nums1[i]+nums2[j], map.get(nums1[i]+nums2[j])+1)\n      }\n      else{\n        map.set(nums1[i]+nums2[j],1)   //注意这里是1\n      }\n    }\n  }\n  let count = 0\n  for(let i=0 ;i<nums3.length;i++){\n    for(let j=0;j<nums4.length;j++){\n      if (map.has(-nums3[i]-nums4[j])){\n        // 这里不是+1，而是要加这个数出现的次数。\n        count += map.get(-nums3[i]-nums4[j])\n      }\n    }\n  }\n  return count\n};\n```","tags":["哈希表"],"categories":["算法","哈希表"]},{"title":"反转链表","url":"/2024/05/02/algrithm/删除链表的倒数第N个结点/","content":"\n# 删除链表的倒数第N个结点\n> https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/\n\n## 两次遍历(我的解决方案)\n\n```javascript\nvar removeNthFromEnd = function(head, n) {\n  // 使用两次遍历，确定链表长度,然后找到被删除的位置\n  let dummy = new ListNode(0, head);\n  cur = dummy\n  let len = 0;\n  while(cur.next){\n    len++;\n    cur = cur.next;\n  }\n  cur = dummy;\n  for(let i=0;i<len-n;i++){\n    cur = cur.next;\n  }\n  cur.next = cur.next.next;\n  return dummy.next;\n};\n```\n\n## 只使用一次遍历\n* 首先使用虚拟结点，方便处理实际的头结点逻辑，也就是说包括头结点在内的所有结点，处理逻辑是一致的。\n* 定义快慢指针，fast和slow\n![图 0](../../images/d55784b390c9afae414ec6ba847f206154e872d074a9908fe65c97a2b66a3529.png)\n* fast比slow先走n+1步，这样当fast走到最后节点的下一个结点null的时候，slow正好指向将被删除结点的上一个结点。\n![图 1](../../images/c4fefbd8c3abf4716e14cb4ebc349fe208096aac020154261fff32b38591af0e.png)\n* fast和slow同时移动指向末尾\n![图 2](../../images/cd98c56bb782f607184bcfdd2d23b178d21451443e00894898b99d0e218c3c57.png)\n\n* 删除slow指向的下一个结点\n![图 3](../../images/d8d2f6213793df6a51007889c196a91542285e373e5791de870344e2238f5a14.png)\n\n\n\n```javascript\nvar removeNthFromEnd = function(head, n) {\n  // 一次遍历\n  let dummy = new ListNode(0, head);\n  let slow = dummy;\n  let fast = dummy;\n  while(fast){\n    if(n+1>0){\n      fast = fast.next\n      n--\n    }\n    else{\n      fast = fast.next\n      slow = slow.next\n    }\n  }\n  slow.next = slow.next.next\n  return dummy.next\n};\n```","tags":["链表"],"categories":["算法","链表"]},{"title":"环形链表II","url":"/2024/05/02/algrithm/环形链表II/","content":"\n# 环形链表II\n## 逻辑\n### 快慢指针可以找到环形链表的原因\n<div style=\"background-color:#ef7a82; padding:20px; color:white; margin-bottom:20px;\">\n快慢指针是一种常用的解决链表问题的方法，特别是对于环形链表的问题。这种方法的基本思想是使用两个指针，一个快指针和一个慢指针，同时从链表的头部开始遍历。快指针每次移动两个节点，而慢指针每次移动一个节点。\n<br></br>\n如果链表中存在环，那么快指针和慢指针最终会在环中的某个位置相遇。这是因为快指针移动的速度是慢指针的两倍，所以即使快指针进入环后，慢指针还没有进入环，快指针也会在环中继续移动，最终追上慢指针。\n</div>\n\n![图 0](../../images/d08758873ec7e8ca55b4a427d59d1ee74996b7a42fa191c59c58eafed1a26583.png)\n\n<div style=\"background-color:#D4F2E7; padding:20px; color:#50616d; margin-bottom:20px;\">\n假设链表的头部到环的入口的距离为x，环的入口到快慢指针相遇点的距离为y，相遇点到环的入口的距离为z。\n<br></br>\n当快慢指针相遇时，慢指针走过的距离是x+y，快指针走过的距离是x+y+n(z+y)。因为快指针的速度是慢指针的两倍，所以2*(x+y) = x+y+n(z+y)，先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。当 n为1的时候解这个等式可以得到x=z。\n\n这就意味着，从链表的头部到环的入口的距离等于从快慢指针相遇点到环的入口的距离。所以，当快慢指针相遇后，我们可以将一个指针移动到链表的头部，然后两个指针同时移动，当它们再次相遇时，就是环的入口。\n\n这就是使用快慢指针可以找到环形链表的数学原理。\n</div>\n\n![图 1](https://code-thinking.cdn.bcebos.com/gifs/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif)\n\n\n```javascript\nvar detectCycle = function(head) {\n    let slow = head, fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            let ptr = head;\n            while (ptr !== slow) {\n                ptr = ptr.next;\n                slow = slow.next;\n            }\n            return ptr;\n        }\n    }\n    return null;\n};\n```\n\n\n\n","tags":["链表","快慢指针","环形链表"],"categories":["算法","链表"]},{"title":"链表相交","url":"/2024/05/02/algrithm/链表相交/","content":"\n# 链表相交\n## 好神奇的方法\n<div style=\"background-color:#ef7a82; padding:20px; color:white; margin-bottom:20px;\">\n这段代码是用来找出两个链表的交点的。它使用了两个指针 pA 和 pB，分别从链表 headA 和 headB 的头部开始遍历。\n\n在每一步，pA 和 pB 都会向前移动一步。如果 pA 到达了链表 headA 的末尾，那么将它重置到链表 headB 的头部；同样，如果 pB 到达了链表 headB 的末尾，那么将它重置到链表 headA 的头部。\n\n这样，pA 和 pB 就会同时遍历两个链表。如果两个链表有交点，那么 pA 和 pB 就会在交点处相遇，此时 pA === pB，循环结束，返回 pA（或 pB）即可。如果两个链表没有交点，那么 pA 和 pB 就会同时到达两个链表的末尾，此时 pA === pB === null，循环结束，返回 pA（或 pB，此时为 null）。\n\n这个算法的时间复杂度是 O(N)，空间复杂度是 O(1)，其中 N 是两个链表的总长度。\n</div>\n\n<div style=\"background-color:#f05654; color:white;padding:20px; \">\n这个规律的关键在于，当两个链表的长度不同时，通过将指针在到达链表末尾后切换到另一个链表的头部，可以消除长度差异。\n\n假设链表A的长度为a+c，链表B的长度为b+c，其中c是两个链表共享的部分的长度。当我们从链表A的头部和链表B的头部同时开始遍历，到达各自链表末尾时，我们已经遍历了a+c和b+c个节点。此时，如果我们将指针切换到另一个链表的头部继续遍历，那么当两个指针相遇时，它们都已经遍历了a+b+c个节点。\n\n因此，无论两个链表的长度如何，当两个指针相遇时，它们都已经遍历了相同数量的节点。如果两个链表有交点，那么这个交点就是两个指针的相遇点；如果两个链表没有交点，那么两个指针就会在遍历了a+b+c个节点后同时到达链表的末尾，此时pA和pB都为null，循环结束。\n\n这就是为什么这个规律可以找出两个链表的交点，或者确定两个链表没有交点的原因\n</div>\n\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n  let pA = headA, pB = headB;\n  while(pA !== pB){\n    pA = pA === null ? headB : pA.next;\n    pB = pB === null ? headA : pB.next;\n  }\n  return pA;\n};\n```\n\n## 复杂度更高的方法\n* 首先确定两个链表的长度\n\n* 对齐：这个过程用图片示意如下；较短的那个位置是关键。\n![图 0](../../images/003fd3ec0ed3cd059875af765a5bdfd27a36654850cc95120a04fcaa1d5361a3.png)\n* 找到相同的结点返回即可\n\n```javascript\nvar getIntersectionNode = function(headA, headB) {\n  var getListLen = (head) => {\n    let len = 0;\n    while (head) {\n      head = head.next;\n      len++;\n  }\n  return len;\n  }\n  let lenA = getListLen(headA);\n  let lenB = getListLen(headB);\n  if(lenA>lenB){\n    for(let i = 0; i < lenA-lenB; i++){\n      headA = headA.next;\n    }\n  }\n  else{\n    for(let i = 0; i < lenB-lenA; i++){\n      headB = headB.next;\n    }\n  }\n  while(headA){\n    if(headA === headB){\n      return headA;\n    }\n    headA = headA.next;\n    headB = headB.next;\n};\n  return null;\n}\n```","tags":["链表","快慢指针"],"categories":["算法","链表"]},{"title":"两两交换链表中的结点","url":"/2024/04/29/algrithm/两两交换链表中的节点/","content":"\n# 两两交换链表的结点\n> https://leetcode.cn/problems/swap-nodes-in-pairs/description/\n\n![图 1](../../images/0ee07672c0f220a8b29aa76e721b81b54794b7334150a77146a4afd0a186b001.png)\n\n\n```javascript\nvar swapPairs = function(head) {\n  // 创建虚拟结点，从虚拟结点开始，每次处理下面的两个结点。然后向后跳转两个结点。\n  let dummy = new ListNode(0)\n  dummy.next = head\n  //prev是当前结点\n  let prev = dummy\n  while(prev.next && prev.next.next){\n    let node1 = prev.next\n    let node2 = prev.next.next\n    //整个交换逻辑在这里\n    prev.next = node2\n    node1.next = node2.next\n    node2.next = node1\n    prev = node1\n  }\n  return dummy.next\n};\n```","tags":["链表"],"categories":["算法","链表"]},{"title":"反转链表","url":"/2024/04/29/algrithm/反转链表/","content":"\n# 反转链表\n**比较验单，理清逻辑注意细节**\n\n![图 0](https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)\n\n```javascript\nvar reverseList = function(head) {\n  let prev = null\n  let cur = head\n  while(cur){\n    // 这一步我忘记了，没有把next的值保存下来，直接给cur.next赋值了\n    const next = cur.next\n    cur.next = prev\n    prev = cur\n    cur = next\n  }\n  return prev\n};\n```","tags":["链表"],"categories":["算法","链表"]},{"title":"移除链表元素","url":"/2024/04/29/algrithm/移除链表元素/","content":"\n# 移除链表元素\n> https://leetcode.cn/problems/remove-linked-list-elements/description/\n\n<div style=\"background-color:#03650f; color:white; padding:10px\">\n逻辑：分情况讨论\n\n- 情况1：链表头部元素和val相同\n- 情况2：链表非头部元素和val相同\n\n<div style=\"color:yellow\">\n两种情况统一的方法：在链表头部加一个虚拟节点，从虚拟节点开始，每次对当前节点的 next 元素进行判断。即可统一两种情况\n</div>\n<br>\n如果cur.next.val == val  让cur的next指向cur.next.next\n否则cur = cur.next\n</div>\n\n```javascript\nvar removeElements = function(head, val) {\n  //虚拟节点，虚拟节点的next指向传入链表的头\n  const dummy = new ListNode(0);\n  dummy.next = head;\n  // dummy用于返回最终结果的头部，因此不能改动。只需将其赋值给另一个变量\n  let cur = dummy;\n  while(cur.next){\n    if(cur.next.val == val){\n      cur.next =cur.next.next;\n    }\n    else{\n      cur = cur.next;\n    }\n  }\n  return dummy.next;\n};\n```\n\n**我抽象的将这个过程想象为一个继承的过程，如果`cur.next.val == val`,那么它没有继承`cur`的资格，直接找`cur.next.next`过来进行资格审查。如果通过继承`cur`。每一代`cur`都要找继承人，直到最后没人可选。**","tags":["链表"],"categories":["算法","链表"]},{"title":"设计链表","url":"/2024/04/29/algrithm/设计链表/","content":"\n# 设计链表\n> https://leetcode.cn/problems/design-linked-list/description/\n## 单链表\n对链表的操作有两种方式：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html#%E6%80%9D%E8%B7%AF\n - 直接使用原来的链表进行操作\n - 设置一个虚拟头结点进行操作\n\n**按照索引添加和删除**结点要注意遍历得到**关键结点**应该是index前面的结点\n**根据索引get对应元素时**，遍历得到的**关键结点**应该是index这个结点\n\n```javascript\n\nvar MyLinkedList = function () {\n  this.val = null\n  this.next = null\n}\n\n/**\n * @param {number} index\n * @return {number}\n */\nMyLinkedList.prototype.get = function (index) {\n  let cur = this\n  for (let i = 0; i <= index; i++) {\n    if (cur.next) {\n      cur = cur.next\n    } else {\n      return -1\n    }\n  }\n  return cur.val\n}\n\n/**\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtHead = function (val) {\n  const newNode = new MyLinkedList()\n  newNode.val = val\n  newNode.next = this.next\n  // 从这一行可以清楚的看出，这是添加虚拟节点的操作方式\n  this.next = newNode\n}\n\n/**\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtTail = function (val) {\n  const newNode = new MyLinkedList()\n  newNode.val = val\n  newNode.next = null\n  let cur = this\n  while (cur.next) {\n    cur = cur.next\n  }\n  cur.next = newNode\n}\n\n/**\n * @param {number} index\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtIndex = function (index, val) {\n  const newNode = new MyLinkedList()\n  newNode.val = val\n  let cur = this\n  for (let i = 0; i < index; i++) {\n    if (cur.next) {\n      cur = cur.next\n    } else {\n      return\n    }\n  }\n  newNode.next = cur.next\n  cur.next = newNode\n}\n\n/**\n * @param {number} index\n * @return {void}\n */\nMyLinkedList.prototype.deleteAtIndex = function (index) {\n  let cur = this\n  for (let i = 0; i < index; i++) {\n    if (cur.next) {\n      cur = cur.next\n    } else {\n      return\n    }\n  }\n  if (!cur.next) return\n  cur.next = cur.next.next\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index,val)\n * obj.deleteAtIndex(index)\n */\n\n```\n\n## 双链表\n**双链表多了一个prev要处理**\n\n```javascript\nvar MyLinkedList = function () {\n  this.prev = null\n  this.val = null\n  this.next = null\n}\n\n\nMyLinkedList.prototype.get = function (index) {\n  let cur = this\n  for (let i = 0; i <= index; i++) {\n    if (cur.next) {\n      cur = cur.next\n    } else {\n      return -1\n    }\n  }\n  return cur.val\n}\n\n/**\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtHead = function (val) {\n  const newNode = new MyLinkedList()\n  newNode.val = val\n  newNode.next = this.next\n  newNode.prev = this\n  this.next = newNode\n}\n\n/**\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtTail = function (val) {\n  const newNode = new MyLinkedList()\n  newNode.val = val\n  newNode.next = null\n  let cur = this\n  while (cur.next) {\n    cur = cur.next\n  }\n  newNode.prev = cur\n  cur.next = newNode\n}\n\n/**\n * @param {number} index\n * @param {number} val\n * @return {void}\n */\nMyLinkedList.prototype.addAtIndex = function (index, val) {\n  const newNode = new MyLinkedList()\n  newNode.val = val\n  let cur = this\n  for (let i = 0; i < index; i++) {\n    if (cur.next) {\n      cur = cur.next\n    } else {\n      return\n    }\n  }\n  newNode.next = cur.next\n  newNode.prev = cur\n  cur.next = newNode\n}\n\n/**\n * @param {number} index\n * @return {void}\n */\nMyLinkedList.prototype.deleteAtIndex = function (index) {\n  let cur = this\n  for (let i = 0; i < index; i++) {\n    if (cur.next) {\n      cur = cur.next\n    } else {\n      return\n    }\n  }\n  if (!cur.next) return\n  cur.next.prev = cur\n  cur.next = cur.next.next\n}\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * var obj = new MyLinkedList()\n * var param_1 = obj.get(index)\n * obj.addAtHead(val)\n * obj.addAtTail(val)\n * obj.addAtIndex(index,val)\n * obj.deleteAtIndex(index)\n */\n```\n\n\n\n","tags":["链表"],"categories":["算法","链表"]},{"title":"有序数组的平方","url":"/2024/04/28/algrithm/有序数组的平方/","content":"\n# 有序数组的平方\n![图 0](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)\n\n\n```javascript\nvar sortedSquares = function(nums) {\n  // 初始化两个指针\n  let left =0;\n  let right = nums.length - 1;\n  // 初始化存放结果的数组\n  let res = new Array(nums.length);\n  // 从后往前依次填满res\n  let point = right\n  while(left <= right){\n    if(nums[left]**2 > nums[right]**2){\n      res[point] = nums[left]**2;\n      left++;\n    }\n    else{\n      res[point] = nums[right]**2;\n      right--;\n    }\n    point--\n  }\n  return res\n};\n```","tags":["双指针","数组"],"categories":["算法","数组"]},{"title":"长度最小的有序数组","url":"/2024/04/28/algrithm/长度最小的子数组/","content":"\n# 长度最小的有序数组\n>https://leetcode.cn/problems/minimum-size-subarray-sum/description/\n\n![图 0](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)\n\n\n```javascript\nvar minSubArrayLen = function(target, nums) {\n  //初始化\n  const n = nums.length;\n  let ans = Number.MAX_SAFE_INTEGER;\n  let left = 0; right = 0;\n  // 核心部分\n  while(right<n){  //终止条件\n    target -= nums[right];\n    while(target <= 0){ // 满足条件的情况\n      ans = Math.min(ans, right-left+1);\n      target += nums[left];\n      left++;\n    }\n    right++\n  }\n  return ans === Number.MAX_SAFE_INTEGER ? 0 : ans;\n};\n```\n\n\n","tags":["数组","滑动窗口"],"categories":["算法","数组"]},{"title":"移除元素","url":"/2024/04/26/algrithm/移除元素/","content":"\n# 移除元素\n> https://leetcode.cn/problems/remove-element/description/\n\n## 单指针法\n![图 0](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif)\n\n```javascript\nvar removeElement = function (nums, val) {\n  // 单指针\n  let size = nums.length\n  let i = 0\n  while (i < size) {\n    if (nums[i] === val) {\n      for (let j = i; j < size; j++) {\n        nums[j] = nums[j + 1]\n      }\n      size--\n    } else {\n      i++\n    }\n  }\n  return size\n}\n```\n<div style=\"background-color:#80f180;padding:10px \">\n由于题目没有要求顺序问题，所以不一定要和上面一样，把所有数字往前移。\n核心逻辑，发现和目标值一样的数，用数组的最后一位代替当前数，然后数组size--\n</div>\n\n```javascript\nvar removeElement = function(nums, val) {\n  // 单指针\n  let size = nums.length\n  let i=0\n  while(i<size){\n    if (nums[i] === val){\n      nums[i] = nums[size-1]\n      size--\n    }\n    else{\n      i++\n    }\n  }\n  return size\n};\n```\n\n## 双指针法\n![图 1](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)\n\n\n> 双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n\n定义快慢指针\n快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组\n慢指针：指向更新 新数组下标的位置\n\n\n```javascript\nvar removeElement = function (nums, val) {\n  // 双指针法\n  let slow =0;\n  let fast = 0;\n  while(fast < nums.length){\n    if(nums[fast] !== val){\n      nums[slow] = nums[fast];\n      slow++;\n    }\n    fast++;\n  }\n  return slow;\n}\n```","tags":["双指针","数组"],"categories":["算法","数组"]},{"title":"螺旋矩阵II","url":"/2024/04/26/algrithm/螺旋矩阵II/","content":"\n# 螺旋矩阵II\n> https://leetcode.cn/problems/spiral-matrix-ii/description/\n\n## 循环不变量\n每次循环处理的区间是有规律的\n左闭右开\n```\no . . . 1 o\n1 . . . . .\n. . . . . .\n. . . . . .\n. . . . . 1\no 1 . . . o\n```\n## 解题\n\n```javascript\nvar generateMatrix = function(n) {\n  // 初始化行列位置\n  let startx = 0, starty = 0;\n  let end = n-1;\n  count = 1;\n  let matrix = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  while(Math.floor(n/2)){\n    // 这里面的四个for循环戴白哦这上节示意图中的一个o-1的过程\n    // 要想通这里的控制过程，并且知道startx，starty，和end的意思，以及他们在每一次循环中如何变化，n如何变化。\n    for (let j=starty;j<end;j++){\n      matrix[startx][j] = count++;\n    }\n    for(let i = startx;i<end;i++){\n      matrix[i][end] = count++;\n    }\n    for(let j=end;j>starty;j--){\n      matrix[end][j] = count++;\n    }\n    for(let i=end;i>startx;i--){\n      matrix[i][starty] = count++;\n    }\n    end--;\n    startx++;\n    starty++;\n    n-=2;\n  }\n  //应对n为奇数的情况\n  if (n) {\n    matrix[startx][starty] = count;\n  }\n  return matrix;\n};\n```","tags":["数组","循环不变量"],"categories":["算法","数组"]},{"title":"回文字符串","url":"/2024/04/25/algrithm/回文字符串/","content":"\n# 回文字符串\n## 什么是回文字符串\n<div style=\"background-color:black; color:white;\">回文字符串：是一个正读和反读都一样的字符串。</div>\n\n## 判断回文字符串的方法\n### 双指针法\n> 这是最直观的方法。我们可以设置两个指针，一个从字符串的开始位置开始，一个从字符串的结束位置开始，然后同时向中间移动。在移动的过程中，如果两个指针指向的字符不相等，那么这个字符串就不是回文字符串。如果两个指针都移动到了中间位置，那么这个字符串就是回文字符串。\n\n```javascript\nlet str = 'abba';\nlet str2 = 'abdc';\n\nfunction isPalindrome(s) {\n  let left = 0,right = s.length-1\n  while(left<right){\n    if(s[left] != s[right]){\n      return false\n    }\n    left++\n    right--\n  }\n  return true\n}\n\nconsole.log(isPalindrome(str)) // true\nconsole.log(isPalindrome(str2)) // false\n```\n\n### 反转字符串\n> 我们可以将字符串反转，然后比较反转后的字符串和原字符串是否相等。如果相等，那么这个字符串就是回文字符串。\n\n```javascript\nlet str = 'abba';\nlet str2 = 'abdc';\n\nfunction isPalindrome(s) {\n  // 反转字符串\n  let reverseStr = s.split('').reverse().join('')\n  return s === reverseStr\n}\nconsole.log(isPalindrome(str)) // true\nconsole.log(isPalindrome(str2)) // false\n```\n\n### 递归\n> 我们可以递归地判断一个字符串是否为回文字符串。如果字符串的首字符和尾字符相等，并且去掉首字符和尾字符后的字符串仍然是回文字符串，那么这个字符串就是回文字符串。\n\n```javascript\nlet str = 'abba';\nlet str2 = 'abdc';\n\nfunction isPalindrome(s) {\n  if (s.length <= 1) {\n    return true;\n  }\n  if (s[0] !== s[s.length - 1]) {\n    return false;\n  }\n  return isPalindrome(s.slice(1, s.length - 1));\n}\n\nconsole.log(isPalindrome(str)) // true\nconsole.log(isPalindrome(str2)) // false\n```","tags":["回文字符串"],"categories":["算法","字符串"]},{"title":"滑动窗口","url":"/2024/04/22/algrithm/滑动窗口/","content":"\n# 滑动窗口\n## 算法题应用场景\n满足***条件的（计算结果、出现次数），包含最长/最短  子串/子数组/子序列\n\n## 滑动窗口的思路\n![图 0](../../images/0ac4d489fab45c2896264c65cf465c17efc4abd6bf5c61c14c76ec463b798029.png)\n\n## 滑动窗口模板\n```javascript\n// 找最长的模板\n// 初始化left，right，result，bestresult\nwhile(右指针到达结尾处){\n  窗口逐渐扩大，加入right对应元素，更新result\n  while(result不满足要求){\n    窗口缩小、移除left对应元素，left右移\n  }\n  更新最优结果bestresult\n  right++\n}\n```\n\n```javascript\n// 找最短模板\n// 初始化left，right，result，bestresult\nwhile(右指针到达结尾处){\n  窗口扩大，加入right对应元素，更新result\n  while(result满足条件){\n    更新最优结果bestresult\n    窗口缩小，移除left对应元素，left右移\n  }\n  right++\n}\n```\n\n## 题目\n### 无重复字符串的子串\n> https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/\n\n**重点在于如何判断无重复字符串**\n\n判断是否有重复字符串,使用字典map和调整left位置实现无重复子串。\n\n![图 3](../../images/ec7328295bca2d70a3e51c23a4155e8875fd3dba1bc430a99e4d769e9a783397.png)\n\n```javascript\nvar lengthOfLongestSubstring = function(s) {\n  // 初始化\n  let p=0;q=0;max=0;\n  let map = new Map();\n  // 右指针逐渐向结尾处移动\n  while(q<s.length){\n    // 当结果不满足条件\n    if(map.has(s[q])){\n      p = Math.max(map.get(s[q])+1,p)\n    }\n    map.set(s[q],q);\n    max = Math.max(max,q-p+1);\n    q++;\n  }\n}\n```\n\n### 串联所有单词的子串\n>https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/\n\n```javascript\nvar findSubstring = function(s, words) {\n  let res = []\n  let wordLen = words[0].length\n  let wordNum = words.length\n  let wordMap = new Map()\n  for (let word of words) {\n    wordMap.set(word, wordMap.has(word) ? wordMap.get(word) + 1 : 1)\n  }\n  // 这里i的设置比较难理解，但是如果理解了后面while中的逻辑，就懂了\n  // 从i开始，right直接到最后可能的位置，也就是for中的一次遍历可以找到0或多个res，而不是1个\n  for (let i = 0; i < wordLen; i++){\n    let left = i\n    let right = i\n    let window = new Map()\n    let count = 0\n    while (right + wordLen <= s.length) {\n      let w = s.slice(right, right + wordLen)\n      right += wordLen\n      if (!wordMap.has(w)) {\n        window.clear()\n        count = 0\n        left = right\n      } else {\n        window.set(w, window.has(w) ? window.get(w) + 1 : 1)\n        count++\n        while (window.get(w) > wordMap.get(w)) {\n          let l = s.slice(left, left + wordLen)\n          left += wordLen\n          window.set(l, window.get(l) - 1)\n          count--\n        }\n        if (count === wordNum) {\n          res.push(left)\n        }\n      }\n    }\n  }\n  return res\n}\n```\n```Plain Text\n这段代码的主要逻辑是使用滑动窗口来遍历字符串 s，并检查每个窗口是否包含 words 中的所有单词。\n\n1、let left = i 和 let right = i：初始化滑动窗口的左右边界。\n2、let window = new Map()：创建一个哈希映射 window 来存储当前窗口中每个单词出现的次。\n3、let count = 0：初始化一个计数器 count 来存储当前窗口中的单词总数。\n4、while (right + wordLen <= s.length)：当窗口的右边界加上单词的长度不超过字符串 s 的长度时，继续循环。\n5、let w = s.slice(right, right + wordLen)：获取窗口右边界的单词 w。\n6、right += wordLen：将窗口的右边界向右移动一个单词的长度。\n7、if (!wordMap.has(w))：如果 w 不在 wordMap 中，那么清空 window，重置 count，并将窗口的左边界移动到 right。\n8、else：如果 w 在 wordMap 中，那么更新 window 和 count，并检查 window 中 w 的数量是否超过了 wordMap 中 w 的数量。如果超过了，那么从窗口的左边移除单词，直到 window 中 w 的数量不超过 wordMap 中 w 的数量。\n9、if (count === wordNum)：如果 count 等于 wordNum，那么将窗口的左边界添加到结果数组 res 中。\n\n这个滑动窗口的策略确保了我们能够有效地遍历字符串 s，并找出所有包含 words 中所有单词的子串的起始索引。\n```","tags":["双指针","滑动窗口"],"categories":["算法","滑动窗口"]},{"title":"两数相加","url":"/2024/04/20/algrithm/两数相加/","content":"\n# 链表的定义和分类\n## 单链表\n![图 0](../../images/accbd96d790954bc505d7824ef65f78ebf4a64aaa6eff145ea5894527eccdacb.png)\n\n```javascript\n自定义链表节点\nfunction ListNode(val,next){\n  this.val = (val===undifined ? 0 : val)\n  this.next = (next === undefined ? 0 : val)\n}\n\nclass ListNode{\n  val;\n  next = null;\n  constructor(value){\n    this.val = value;\n    this.next = null\n  }\n}\n```\n\n```typescript\nclass ListNode{\n  public val : number;\n  public next : ListNode|null = null\n  constructor(value:number){\n    this.val = value;\n    this.next = null;\n  }\n}\n```\n\n## 双链表\n![图 1](../../images/0a0987fbc837d9e0af023a81c4ffe161aabed529d3205591a90127b984508789.png)\n\n## 循环链表\n![图 2](../../images/d8f6790b371e6f67eb9d8f7adba1a8ce35aca9830ba7e21ea60d92690076e8b2.png)\n\n\n# 链表相关题目\n## 两数相加\n> https://leetcode.cn/problems/add-two-numbers/description/\n\n```javascript\nvar addTwoNumbers = function(l1, l2) {\n// 首先新建一个节点\n  let res = new ListNode(0)\n  // 将节点赋值给变量curr，最终返回res.next就是链表的头，\n  // p和q分别是第一个和第二个链表的头\n  let curr = res, p = l1, q = l2\n  //进位的时候需要的carry\n  let carry = 0\n  //循环终止的条件是两个链表元素都被遍历完\n  while(p != null || q != null){\n    // 将长度较短的链表后面补0，直到达到较长链表的长度\n    let x = (p === null) ? 0 : p.val\n    let y = (q === null) ? 0 : q.val\n    // 求对应位置两数的和\n    let sum = x + y + carry\n    // 和大于0说明需要进位，进位数为sum/2\n    carry = Math.floor(sum/10)\n    // 保存在链表中的应该是余数，且应该创建一个ListNode\n    curr.next = new ListNode(sum%10)\n    // 让curr指向curr.next\n    curr = curr.next\n    // p和q都指向下一个结点\n    if (p != null) p = p.next\n    if (q != null) q = q.next\n  }\n  // 最后有可能出现两数的和的长度大于两数最长的哪个数的位数\n  if (carry > 0){\n    curr.next = new ListNode(carry)\n  }\n  return res.next\n};\n```","tags":["链表"],"categories":["算法","链表"]},{"title":"Array.form","url":"/2024/04/12/js/数组方法/","content":"\n# Array.form用法\nArray.from() 是一个静态方法，它从类数组或可迭代对象创建一个新的数组实例。\n以下是一些使用 Array.from() 的例子：\n\n从字符串创建数组：\n```javascript\nlet str = 'hello';\nlet arr = Array.from(str);\nconsole.log(arr); // 输出：['h', 'e', 'l', 'l', 'o']\n```\n从 Set 创建数组：\n```javascript\nlet set = new Set(['a', 'b', 'c']);\nlet arr = Array.from(set);\nconsole.log(arr); // 输出：['a', 'b', 'c']\n```\n从 Map 创建数组：\n```javascript\nlet map = new Map([[1, 'a'], [2, 'b'], [3, 'c']]);\nlet arr = Array.from(map);\nconsole.log(arr); // 输出：[[1, 'a'], [2, 'b'], [3, 'c']]\n```\n从类数组对象创建数组：\n```javascript\nlet obj = {0: 'a', 1: 'b', 2: 'c', length: 3};\nlet arr = Array.from(obj);\nconsole.log(arr); // 输出：['a', 'b', 'c']\n```\n使用映射函数：\n```javascript\nlet arr = Array.from([1, 2, 3], x => x * x);\nconsole.log(arr); // 输出：[1, 4, 9]\n```\n在你的代码中，Array.from({length:n},()=>Array.from({length:n},()=>'.')) 创建了一个 n x n 的二维数组，所有元素都被初始化为 '.'。\n\n\n","tags":["数组"]},{"title":"回溯算法","url":"/2024/04/01/algrithm/回溯算法/","content":"\n# 回溯算法\n## 回溯算法基本理论\n### 是什么：\n\n回溯采用是错得方法解决问题，一旦发现当前步骤失败，回溯算法就会返回上一个步骤\n### 解决哪些问题：\n* 组合问题（组合不强调顺序，而排列强调）\n* 切割问题\n* 子集问题\n* 排列问题\n* 棋盘问题\n### 如何理解回溯法\n\n回溯法都可以抽象为一个树形结构。一个n叉树\n\n![图 0](../../images/dd3f30de3f45400b6c63e949a71208803cfe7fbcab8ddece53ad61ff75f7d99c.png)\n\n### 回溯法的模板\n\n```c\n// 递归函数没有返回值\nvoid backtrading(参数){\n  // 递归终止条件\n  if (终止条件){ //通常在叶子节点\n    //收集结果\n    return\n  }\n  // 单层搜索\n  for (集合得元素集){ //遍历集合中的每一个元素\n    // 处理节点\n    // 递归函数\n    // 回溯\n  }\n  return\n}\n```\n### 回溯算法剪枝\n剪枝一般都是在for循环的i的范围上做文章，例如下面的组合题目，确定i至多从哪里开始。\n![图 4](../../images/c517379694dc1a179d76813af40c76fa8b0a6a71624be19a736f39ad89789dd0.png)\n\n\n\n## 回溯算法题目\n### 组合问题\n> 题目：https://leetcode.cn/problems/combinations/description/\n\n![图 2](../../images/a988b9d018a3861e33a75f4146152bfbd8bd00b0ca0f1da93aff1ecf3fae8c22.png)\n\n> 未剪枝\n```javascript\nvar combine = function(n, k) {\n  var path = [];  // 用来存放每一个结果\n  var res = [];  //存放所有结果的数组\n  //确定参数\n  const backTrading = (n, k, startIndex) => { //startIndex搜索的起始位置\n    //终止条件\n    if(path.length === k){\n      //注意这里要深拷贝一下path，因为path是引用类型，后续的操作会改变path的值\n      res.push([...path]); //将path的值push到res中\n      return;\n    }\n    // 单层递归逻辑\n    for(let i = startIndex; i <= n; i++){\n      path.push(i);\n      backTrading(n, k, i + 1); //递归,起始位置+1\n      path.pop(); //回溯的过程，弹出最后一个元素\n    }\n  }\n  backTrading(n, k, 1); //调用backTrading函数,第一次竟然忘了这一步\n  return res;\n};\n```\n\n> 剪枝\n```javascript\n// path.length 已选取的元素的大小\n// k-path.length 还需要的元素\n// n-(k-path.length)+1 i的至多从该位置开始取\nvar combine = function(n, k) {\n  var path = [];  // 用来存放每一个结果\n  var res = [];  //存放所有结果的数组\n  //确定参数\n  const backTrading = (n, k, startIndex) => { //startIndex搜索的起始位置\n    //终止条件\n    if(path.length === k){\n      //注意这里要深拷贝一下path，因为path是引用类型，后续的操作会改变path的值\n      res.push([...path]); //将path的值push到res中\n      return;\n    }\n    // 单层递归逻辑\n    //剪枝在for循环停止的位置做文章\n    for(let i = startIndex; i <= (n-(k-path.length)+1); i++){\n      path.push(i);\n      backTrading(n, k, i + 1); //递归,起始位置+1\n      path.pop(); //回溯的过程，弹出最后一个元素\n    }\n  }\n  backTrading(n, k, 1); //调用backTrading函数,第一次竟然忘了这一步\n  return res;\n};\n```\n### 组合总和 III\n> https://leetcode.cn/problems/combination-sum-iii/description/\n\n![图 5](../../images/e4d7a5ab00c4ec9ecdc0070abd3bdd8cad12d8f125c45eb95ede13e5efc740cb.png)\n\n![图 6](../../images/e6430eeda8014bf3946082137eafac460dbbac8a026b0e076155b1a1cd93a356.png)\n\n```javascript\n//加了剪枝操作\nvar combinationSum3 = function(k, n) {\n  let path = []   //一维数组，用来存放符合条件的组合\n  let res = []    //二维数组，用来存放符合条件的组合数组\n  const backTrading = (n,k,sum,startIndex)=>{ //sum是当前path数组的和\n    if(sum>n) return  //这是一个剪枝操作\n    if(path.length ===k){\n      if(sum === n){\n        res.push([...path])\n      }\n      return\n    }\n  // i的边界的控制也是剪枝操作\n  for(let i = startIndex;i<=(9-(k-path.length)+1);i++){\n    sum += i\n    path.push(i)\n    backTrading(n,k,sum,i+1) //这里是深入分支\n    sum -= i    //回溯，这里是广度的遍历，挨个遍历每一个元素\n    path.pop()\n  }\n}\n  backTrading(n,k,0,1)\n  return res\n};\n```\n\n### 电话号码的字母组合\n> https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/\n\n解题思路\n* 先做数字和字母的映射\n* 通过树形结构梳理思路\n\n![图 7](../../images/edfd77890201623dccb4331ed561e00e8fd5225de18b559dbd323f365a74acfb.png)\n\n```javascript\nvar letterCombinations = function(digits) {\n  //先做一个映射表\n  const map = new Map()\n  map.set('2','abc')\n  map.set('3','def')\n  map.set('4','ghi')\n  map.set('5','jkl')\n  map.set('6','mno')\n  map.set('7','pqrs')\n  map.set('8','tuv')\n  map.set('9','wxyz')\n  let str = ''   //收获单个结果\n  let res = []\n  const backTrading = (digits,index)=>{\n    if(!digits) return\n    if(index === digits.length){  //终止条件\n      res.push(str)\n      return\n    }\n    //单层逻辑\n    let digit = digits[index]  //找到数字\n    let letters = map.get(digit)   // 根据数字在映射表中找到对应的字母\n    for(let i=0;i<letters.length;i++){\n      str += letters[i]\n      backTrading(digits,index+1)\n      str = str.slice(0,str.length-1) //回溯\n    }\n  }\n  backTrading(digits,0)\n  return res\n};\n```\n\n### 组合总和\n> https://leetcode.cn/problems/combination-sum/description/\n\n数组中没有0且没有重复数字。\n\n![图 8](../../images/221b346b6cd70a86544ba5967926404a876ff371c02263c1ce472915e529f3c5.png)\n\n```javascript\nvar combinationSum = function(candidates, target) {\n  //递归终止条件\n  let path = []\n  let res = []\n  const backTraking = (candidates,target,sum,startIndex)=>{\n    if (sum > target) return\n    if (sum === target) {\n      res.push(path.slice())  //深拷贝\n      return\n    }\n    for(let i = startIndex;i<candidates.length;i++){\n      path.push(candidates[i])\n      sum += candidates[i]\n      backTraking(candidates,target,sum,i) //可以重复i不加1喽\n      sum -= candidates[i]\n      path.pop()\n    }\n  }\n  backTraking(candidates,target,0,0)\n  return res\n};\n```\n剪枝\n![图 9](../../images/acba2374fdc01492a032d09ed524fa7db8b96de25871adc1ae4b68a7f7b40370.png)\n\n```javascript\nvar combinationSum = function(candidates, target) {\n  //递归终止条件\n  let path = []\n  let res = []\n  const backTraking = (candidates,target,sum,startIndex)=>{\n    // if (sum > target) return\n    if (sum === target) {\n      res.push(path.slice())  //深拷贝\n      return\n    }\n    for(let i = startIndex;i<candidates.length;i++){\n      if (candidates[i] + sum > target) continue; //剪枝\n      path.push(candidates[i])\n      sum += candidates[i]\n      backTraking(candidates,target,sum,i) //可以重复i不加1喽\n      sum -= candidates[i]\n      path.pop()\n    }\n  }\n  backTraking(candidates,target,0,0)\n  return res\n};\n```\n\n### 组合总和 II\n> https://leetcode.cn/problems/combination-sum-ii/description/\n\n难点在于：结果中不能有重复的结果[1,7],[7,1]。但是能原数组中有两个1，有可以有[1,1,6]。\n\n![图 10](../../images/24586565c63601ccb7d0b9374471f5658ed41f6c9f68a622163e940ce0941619.png)\n\n**树层去重**和**树枝去重**\n> https://www.programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF\n\n\n\n```javascript\nvar combinationSum2 = function(candidates, target) {\n  let path = []\n  let res = []\n  // 进行排序\n  candidates.sort((a,b)=>a-b)\n  const backTracking = (candidates,target,sum,startIndex,used)=>{\n    if (sum === target){\n      res.push(path.slice())\n      return\n    }\n    for(let i = startIndex;i<candidates.length;i++){\n      if (sum + candidates[i] > target) continue  //剪枝\n      // i>0是为了保证i-1有意义\n      // used[i-1]=false，说明此时处于树层的状态，即同一树层上的前一个元素已经被撤销，所以此时可以继续使用\n      if (i > 0 && candidates[i] === candidates[i-1] && !used[i-1]) continue  //数层去重的而过程，前提是数组有序\n      path.push(candidates[i])\n      sum += candidates[i]\n      used[i] = true  //标记使用过\n      backTracking(candidates,target,sum,i+1,used)\n      //回溯\n      sum -= candidates[i]\n      path.pop()\n      used[i] = false\n    }\n  }\n  backTracking(candidates,target,0,0,new Array(candidates.length).fill(false))\n  return res\n};\n```\n\n### 分割回文子串\n> https://leetcode.cn/problems/palindrome-partitioning/description/\n\n![图 11](../../images/e49bbd0d73fa2dd370d3d0f41eb8fa9bb9595d19ae061716077a9120ad62a5a9.png)\n\n难点：\n* 切割问题和组合是一样的，之前选择的元素下标，相当于这里的切割线\n* 如何表示切割的字串[startIndex,i]\n\n```javascript\nvar partition = function(s) {\n  let path = [] //一维数组，用来存放每一次的结果\n  let res = [] //二维数组，用来存放所有的结果、\n  const backTraking = (s,startIndex)=>{\n    if(startIndex >= s.length){  //到了叶子就节点了，将结果放入res中\n      res.push(path.slice())\n      return\n    }\n    // 单层搜索逻辑\n    for(let i=startIndex;i<s.length;i++){\n      // 如果是回文子串，才添加到path中，否则直接continue\n      if(isPlalindrome(s,startIndex,i)){\n        path.push(s.substring(startIndex,i+1))\n        backTraking(s,i+1)\n        path.pop()\n      }\n    }\n  }\n  const isPlalindrome = (s,left,right)=>{\n    //判断是否是回文串的函数\n    while(left<right){\n      if(s[left] !== s[right]) return false\n      left++\n      right--\n    }\n    return true\n  }\n  backTraking(s,0)\n  return res\n};\n```\n\n### 复原IP地址\n> https://leetcode.cn/problems/restore-ip-addresses/description/\n\n合法的IP地址：有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。\n\n![图 12](../../images/06508832b4dd283b8fc1a9b820dc3a9a5f401e00c610c2725185c7bcabab9f9a.png)\n\n\n```javascript\nvar restoreIpAddresses = function(s) {\n  let path = []\n  let res = []\n  const backTracking = (s,startIndex)=>{\n    if(path.length === 4 && startIndex === s.length){\n      res.push(path.join('.'))\n      return\n    }\n    //剪枝了，如果path的长度已经是4了，但是startIndex还没有到s的长度，那么就不用再继续了\n    if(path.length === 4 && startIndex < s.length) return\n    // 剪枝了，如果path的长度不是4了，但是startIndex已经到s的长度了，那么也不用再继续了\n    for(let i= startIndex;i<s.length && i<= startIndex+3;i++){\n      if (isValid(s,startIndex,i)){\n        path.push(s.substring(startIndex,i+1))\n        backTracking(s,i+1)\n        path.pop()\n      }\n    }\n  }\n  const isValid = (s,startIndex,i)=>{\n    if(s[startIndex] === '0' && i !== startIndex) return false\n    if(parseInt(s.substring(startIndex,i+1)) > 255) return false\n    return true\n  }\n  backTracking(s,0)\n  return res\n};\n```\n\n<div style=\"background-color:green; color:white;\">前面的一系列都是在叶子节点收获结果，终止条件的写法基本一致</div>\n\n---\n\n<div style=\"background-color:green; color:white;\">后面开始要从每一个节点收获结果，终止条件的写法发生变化。</div>\n\n### 子集\n> https://leetcode.cn/problems/subsets/description/\n\n![图 13](../../images/b15ccd262d3cefe8263e588cbe18040b07c0353a4cfd53a6504136d34874301b.png)\n\n```javascript\nvar subsets = function(nums) {\n  let path = []\n  let res = []\n  const backTraking = (nums,startIndex)=>{\n    // 每个节点都收获一次、如果终止条件改为>，这一句要放在if的下面，单层搜索逻辑的上面。\n    res.push([...path])\n    //终止条件是，到了叶子节点\n    if(startIndex >= nums.length){\n      return //剩余元素为空时，也就是startIndex到达了nums的长度\n    }\n\n    for(let i=startIndex;i<nums.length;i++){\n      path.push(nums[i])\n      backTraking(nums,i+1)\n      path.pop()\n    }\n  }\n  backTraking(nums,0)\n  return res\n};\n```\n### 子集II\n树层去重：确定当前在树层used[i-1]===fasle,当前元素与前一元素相等，i>0\n\n> https://leetcode.cn/problems/subsets-ii/description/\n\n![图 14](../../images/1b7fd45a6d51b877075f4713beb3bab118a8da9d87e5dbfa8a65052edbb2bb12.png)\n\n\n```javascript\nvar subsetsWithDup = function(nums) {\n  let path = []\n  let res = []\n  used = new Array(nums.length).fill(false)\n  // 排序\n  nums.sort((a, b) => a - b)\n  const backTraking = (nums, startIndex, used) => {\n    res.push([...path])\n    if (startIndex >= nums.length) {\n      return\n    }\n    for (let i = startIndex; i < nums.length; i++) {\n      // i>0是为了保证i-1有意义\n      // used[i-1]=false，说明此时处于树层的状态，即同一树层上的前一个元素\n      // 已经被撤销，所以此时可以继续使用\n      if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {\n        continue\n      }\n      path.push(nums[i])\n      used[i] = true\n      backTraking(nums, i + 1, used)\n      path.pop()\n      used[i] = false\n    }\n  }\n  backTraking(nums, 0, used)\n  return res\n};\n```\n\n### 递增子序列\n> https://leetcode.cn/problems/non-decreasing-subsequences/\n\n<div style=\"background-color:pink; padding:10px; \">去重方法：由于不能排序，所以这里的树层去重和之前有所差别\n<br>\n之前的题目基本使用used来记录事都使用过某一元素，因为是有序的，只需判断used[i-1] ，nums[i-1]===nums[i]\n<br>\n现在得到题目是无序的，使用set，每次循环判断当前数字是否在set中，如果在，跳过，否则将数字放入set，实现去重。</div>\n<br>\n\n```javascript\nvar findSubsequences = function(nums) {\n  let path = []\n  let res = []\n  // 回溯算法函数\n  const backTraking = (nums,startIndex)=>{\n    // 收获结果的地方\n    if (path.length > 1){\n      res.push([...path])\n    }\n    // 终止条件\n    if (startIndex >= nums.length){\n      return\n    }\n    //单层搜索逻辑\n    let set = new Set()\n    for(let i=startIndex;i<nums.length;i++){\n      // 当前元素小于path最后的元素，跳过. 但是如果path为空，不跳过\n      if (nums[i] < path[path.length-1] || !path ){\n        continue\n      }\n      // 树层去重\n      if(set.has(nums[i])){\n        continue\n      }\n      else{\n        set.add(nums[i])\n      }\n      path.push(nums[i])\n      backTraking(nums,i+1)\n      path.pop()\n    }\n  }\n  backTraking(nums,0)\n  return res\n};\n```\n### 全排列\n> https://leetcode.cn/problems/permutations/description/\n>\n**首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。**\n\n可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。\n\n但排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:\n![图 15](../../images/2fbbaf3d6bc3c8eff8499d438206a20f1f5291abeb6249c8aed65be6d0097336.png)\n\n\n```javascript\nvar permute = function(nums) {\n  let path =[]\n  let res = []\n  let used = new Array(nums.length).fill(false)\n  const backTracking = (nums)=>{\n    if(path.length === nums.length){\n      res.push([...path])\n      return\n    }\n    for(let i=0; i<nums.length; i++){\n      if(used[i]){\n        continue\n      }\n      used[i] = true\n      path.push(nums[i])\n      backTracking(nums)\n      path.pop()\n      used[i] = false\n    }\n  }\n  backTracking(nums)\n  return res\n};\n```\n\n### 全排列II\n> https://leetcode.cn/problems/permutations-ii/description/\n\n加一个数层去重\n```javascript\nvar permuteUnique = function(nums) {\n  let path = []\n  let res = []\n  // 用于排列\n  let used = new Array(nums.length).fill(false)\n  // 用于数层去重\n  let used1 = new Array(nums.length).fill(false)\n  nums.sort((a,b)=>a-b)\n  const backTracking = (nums)=>{\n    // 终止条件\n    if(path.length === nums.length){\n      res.push([...path])\n      return\n    }\n    for(let i=0; i<nums.length; i++){\n      if (used[i]){\n        continue\n      }\n      //树层去重\n      if(i>0 && nums[i] === nums[i-1] && !used1[i-1]){\n        continue\n      }\n      used[i] = true\n      used1[i] = true\n      path.push(nums[i])\n      backTracking(nums)\n      path.pop()\n      used[i] = false\n      used1[i] = false\n    }\n  }\n  backTracking(nums)\n  return res\n};\n```\n\n### 重新安排行程\n> https://leetcode.cn/problems/reconstruct-itinerary/description/\n\n\n\n### N皇后\n> https://leetcode.cn/problems/n-queens/\n\n![图 16](../../images/d7351e571763559b09ec6ae9df1ddb857711fb9fe58e1f026bd596d0cfc15d8d.png)\n\n\n```javascript\nvar solveNQueens = function(n) {\n  let res = []\n  // Array.from() 是一个静态方法，它从类数组或可迭代对象创建一个新的数组实例。\n  let checkboard = Array.from({length:n},()=>Array.from({length:n},()=>'.'))\n  const isVaild = (row,col,checkboard,n)=>{\n    // 检查列,只需要检查当前行上面的行\n    for(let i=0;i<row;i++){\n      if(checkboard[i][col] === 'Q'){\n        return false\n      }\n    }\n    // 检查左上方45度对角线\n    for(let i= row-1,j=col-1;i>=0 && j>=0;i--,j--){\n      if(checkboard[i][j] === 'Q'){\n        return false\n      }\n    }\n    // 检查右上方45度对角线\n    for(let i=row-1,j=col+1;i>=0 && j<n;i--,j++){\n      if(checkboard[i][j] === 'Q'){\n        return false\n      }\n    }\n    return true\n  }\n\n  const backTraking = (checkboard,n,row)=>{\n    if(row==n){\n      res.push(checkboard.map(row=>row.join('')))\n      return\n    }\n    for (let col=0;col<n;col++){\n      //判断放在这里是否符合要求\n      if (isVaild(row,col,checkboard,n)){\n        checkboard[row][col] = 'Q'\n        backTraking(checkboard,n,row+1)\n        checkboard[row][col] = '.'\n      }\n    }\n  }\n  backTraking(checkboard,n,0)\n  return res\n};\n```\n\n### 解数独\n> https://leetcode.cn/problems/sudoku-solver/\n> https://www.programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\n```javascript\nvar solveSudoku = function (board) {\n  function isValid(row, col, val, board) {\n    let len = board.length\n    // 行不能重复\n    for (let i = 0; i < len; i++) {\n      if (board[row][i] === val) {\n        return false\n      }\n    }\n    // 列不能重复\n    for (let i = 0; i < len; i++) {\n      if (board[i][col] === val) {\n        return false\n      }\n    }\n    // 3*3的格子不能重复\n    let startRow = Math.floor(row / 3) * 3 // 0,3,6\n    let startCol = Math.floor(col / 3) * 3 // 0,3,6\n\n    for (let i = startRow; i < startRow + 3; i++) {\n      for (let j = startCol; j < startCol + 3; j++) {\n        if (board[i][j] === val) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  function backTracking() {\n    for (let i = 0; i < board.length; i++) {\n      for (let j = 0; j < board[0].length; j++) {\n        if (board[i][j] !== '.') continue\n        for (let val = 1; val <= 9; val++) {\n          if (isValid(i, j, `${val}`, board)) {\n            board[i][j] = `${val}`\n            if (backTracking()) {\n              return true\n            }\n\n            board[i][j] = `.`\n          }\n        }\n        return false\n      }\n    }\n    return true\n  }\n  backTracking(board)\n  return board\n};\n```","tags":["回溯"],"categories":["算法","回溯"]},{"title":"LCR 121寻找目标值","url":"/2024/03/29/algrithm/寻找目标值-二维数组/","content":"\n# LCR 121寻找目标值\n## 我的思路\n我的思路，很混乱。因为有两个方向，向下向右都增大，我就不知道该向下还是向右了。然后设计了很多情况，最后发现条件都理不顺。哭了\n\n## 转变成树的思路\n把数组旋转45度，他就变成了树，节点的左节点比根小，右节点比根大。问题就得到了解决\n\n![图 0](../../images/a34aa5c23112f19f9ef774119a41d394996c5784eccf2d0e68d12d57f532b168.png)\n\n解题思路如下：\n* 确定根节点，以右上角为根节点，设置索引`i=0,j=plants[0].length`\n* 当 `plants[i][j] > target`那么找左子节点，即`j--`\n* 当 `plants[i][j] < target`那么找右子节点，即`i++`\n* 当 `plants[i][j] = target` `return true`\n* 若行索引或列索引越界，表示没找到目标值，返回false\n* 最后补充注意点，测试时发现有的用例是**空数组**，所以要在函数中判断这种情况，遇到直接`return false`\n\n```javascript\nvar findTargetIn2DPlants = function (plants, target) {\n  //特殊情况判断，空数组，return false\n  if (plants.length === 0) return false;\n\n  const r = plants.length;\n  const c = plants[0].length;\n  // 通过i,j确定根节点为右上角\n  let i = 0;\n  let j = c - 1;\n  // 从右上角开始查找\n  while (i < r && j >= 0) {\n    if (plants[i][j] === target) {\n      return true;\n    } else if (plants[i][j] > target) {\n      j--;\n    } else {\n      i++;\n    }\n  }\n  return false;\n};\n```","tags":["二维数组"],"categories":["算法","数组"]},{"title":"LCR 128.库存管理","url":"/2024/03/29/algrithm/库存管理/","content":"\n# 库存管理(寻找旋转排序数组最小值)\n## 题目\n![图 0](../../images/3718bfbc2fb45417b65d21a94724a60a7aa8d99133030cb4728822e85bbf6270.png)\n![图 1](../../images/40068076264ba097151802c228680a165784b05be6d7a1185bab32338573604b.png)\n\n## 解题\n### 我的思路\n我知道最小值的位置的特点是，该位置的数小于其前一个位置的数，当然这里存在一个特殊点是当这个位置为0时，没有前一个数字。\n\n```javascript\n//没写出来\nvar findMin = function(nums) {\n    // 特点在于，目标数的前一位大于目标数\n    //特殊情况是目标数的下表为0，说明旋转了0次\n    let left = 0,right = nums.length\n    while(left<right){\n        let mid = left + Math.floor((right - left)/2)\n        if(mid === 0) return nums[mid]\n        else{\n            if(nums[mid] < nums [mid-1]) return nums[mid]\n            else if()\n        }\n\n    }\n};\n```\n### 正确思路\n我们可以认为这个数组是由重复值的。那么一个经过旋转之后的数组可视化后如下图所示。数组中最后一个元素的大小为`x`，如图中虚线所示。\n\n它具如下的特点：\n\n* 最小值右边的元素均小于等于x\n* 最小值左边的元素均大于等于最小值\n> 基于上述特性才使得本题可以使用二分查找法解决。\n\n![图 3](../../images/7818c547aded4ebdf5b189b1e2e84f21a07aa9144e61db1ea98aa9efc3091ce5.png)\n\n\n**二分查找的情况可以分为3类**\n在二分查找的每一步中，左边界为 `low`，右边界为 `high`，区间的中点为 `pivot`，最小值就在该区间内。我们将中轴元素 `nums[pivot]`与右边界元素 `nums[high]`进行比较，可能会有以下的三种情况：\n\n1、nums[pivot] > nums[high],说明最小值在`pivot`与`high`之间。`low = pivot + 1`\n\n![图 4](../../images/94161ce340b1bed48a36c8a4348990d1584c52d6c2d2203ad0c57148730ddb51.png)\n\n2、nums[pivot] < nums[high],说明最小值不在在`pivot`与`high`之间。`high = pivot - 1`\n\n![图 5](../../images/42dac3dd65f28f5f9ef2b26660fe88a13c9e108a62beb0228905eb8834e2af48.png)\n\n3、`nums[pivot] === nums[high]`,这是由于存在重复值。`high=high-1`\n\n![图 6](../../images/5e3babc66c4742ea53d5cee74d209f291dfbdbb7f2bf3ee4be099011114972bd.png)\n\n当二分查找结束时，我们就得到了最小值所在的位置。\n\n```javascript\nvar stockManagement = function(stock) {\n  let low = 0;\n    let high = stock.length - 1;\n    while (low < high) {\n        const pivot = low + Math.floor((high - low) / 2);\n        if (stock[pivot] < stock[high]) {\n            high = pivot;\n        } else if (stock[pivot] > stock[high]) {\n            low = pivot + 1;\n        } else {\n            high -= 1;\n        }\n    }\n    return stock[low];\n};\n```","tags":["二分查找"],"categories":["算法","二分"]},{"title":"LCR 127.跳跃训练","url":"/2024/03/29/algrithm/跳跃训练/","content":"\n# 跳跃训练\n## 题目\n![图 0](../../images/d84569d42687bd9e95a7e15c465ddc1991a45b92f7895d0b2088259af1438cdd.png)\n\n## 我的求解\n这道题我很有印象，和爬楼梯是同一个意思。就是要用到动态规划。逻辑在于我要到达第`n`个格子的方法，等于我要到达第`n-1`个格子的方法加到达`n-2`个格子的方法。\n\n```javascript\nvar trainWays = function(num) {\n  //和爬楼梯很像，是动态规划的题目\n  //dp[i]表示跳到第i个台阶的方法数\n  let dp = new Array(num + 1).fill(0)\n  dp[0] = 1\n  dp[1] = 2\n  //这里有一些特殊情况，第一种是在程序提交不同过的例子中发现的，\n  if (num === 0) return dp[0]\n  //第二种就是只有一个格子\n  if (num === 1) return dp[0]\n  //第三种只有两个格子的情况。\n  if (num === 2) return dp[1]\n  else {\n    for (let i = 2; i < num; i++) {\n      //别忘了题目要求的取模\n      dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007\n    }\n    return dp[num - 1]\n  }\n};\n```\n","tags":["动态规划"],"categories":["算法","动态规划"]},{"title":"合并两个有序数组","url":"/2024/03/28/algrithm/合并两个有序数组/","content":"\n# 合并两个有序数组\n## 题目\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n\n算法的时间复杂度应该为 O(log (m+n)) 。\n\n示例 1：\n\n>输入：nums1 = [1,3], nums2 = [2]\n输出：2.00000\n解释：合并数组 = [1,2,3] ，中位数 2\n\n示例 2：\n>输入：nums1 = [1,2], nums2 = [3,4]\n输出：2.50000\n解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5\n\n## 求解\n> https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/258842/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/\n\n\n```javascript\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nvar findMedianSortedArrays = function(nums1, nums2) {\n  // 保证nums1的较短数组\n  if (nums1.length > nums2.length) {\n    [nums1, nums2] = [nums2, nums1];\n  }\n  //m为较短数组的长度,n为较长数组的长度\n  let m = nums1.length; // Add missing variable declaration for m\n  let n = nums2.length; // Add missing variable declaration for n\n  // 左边元素的个数\n  let totalLeft = Math.floor((m + n + 1) / 2);\n  // 在nums1的[0,m]中找合适的分割线\n  // 使得nums1[i-1] <= nums2[j] && nums2[j-1] <= nums1[i]\n  let left = 0, right = m;\n  // 二分查找\n  while(left < right){ // Fix the loop condition\n    let i = left + Math.floor((right - left + 1) / 2);\n    let j = totalLeft - i;\n    if(nums1[i-1] > nums2[j]){\n      //下一轮搜索区间在[left,i-1]\n      right = i-1;\n    }\n    else{\n      //下一轮搜索区间在[i,right],注意当这个区间只有两个元素时，会陷入死循环，因此在二分的时候要+1\n      left = i\n    }\n  }\n  //退出循环后找到了想要的分割线\n  let i = left;\n  let j = totalLeft - i;\n  // 定义左右两边的四个值,还是为了适应特殊情况\n  // 如果 i 等于 0，说明 nums1 的左侧没有元素，所以左侧最大值设为负无穷 -Infinity。否则，左侧最大值就是 nums1[i-1]。\n  //左侧找最大值，右侧找最小值\n  let nums1LeftMax = i === 0 ? -Infinity : nums1[i-1];\n  let nums1RightMin = i === m ? Infinity : nums1[i];\n  let nums2LeftMax = j === 0 ? -Infinity : nums2[j-1];\n  let nums2RightMin = j === n ? Infinity : nums2[j];\n  // 如果总长度是奇数\n  if((m + n) % 2 === 1){\n    return Math.max(nums1LeftMax, nums2LeftMax);\n  }\n  else{\n    return (Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin)) / 2;\n  }\n};\n```\n\n## 二分查找\n> 一看就会，一写就废。问题出在边界无法掌握，一不小心就死循环了，因此要掌握二分查找的边界\n> https://blog.csdn.net/qq_45978890/article/details/116094046\n### 二分查找的条件\n* 有序\n* 只找一个\n\n### 二分查找的边界\n* 1、[左闭，右闭]\n```javascript\nconst search1 = (arr, target) => {\n  let left = 0, right = arr.length - 1;\n  // 二分查找,闭区间\n  while (left <= right) {  // 因为是闭区间，所以left 要小于等于right\n    let mid = left + Math.floor((right - left) / 2);\n    if (arr[mid] < target) { // 目标值在右边\n      left = mid + 1;  //应为是左闭右闭，所以不用担心，边界mid+1后mid+1不能被比较\n    }\n    else if (arr[mid] > target) { // 目标值在左边\n      right = mid - 1;\n    } else {\n      // 找到目标值\n      return mid;\n    }\n  }\n  return -1;\n}\n//犯个错误，第二个else if，我用了if，然后下面用了else，导致第二个if和最后的else成了组合，不再能表示所有情况。\nconsole.log(search([1,2,3,4,5,6,7,8,9], 5)) // 4\n```\n* 2、[左闭，右开)\n```javascript\nconst search = (arr, target) => {\n  let left = 0, right = arr.length; // 左闭右开区间\n  while (left < right) { //终止条件\n    let mid = left + Math.floor((right - left) / 2);\n    if (arr[mid] < target) { // 目标值在右边\n      left = mid + 1; // 更新左边界\n    } else if (arr[mid] > target) {  // 目标值在左边\n      right = mid; // 更新右边界\n    } else {\n      return mid;\n    }\n  }\n}\n```\n\n* 3、(左开，右闭]\n```javascript\n//左开右闭区间\nconst search = (arr, target) => {\n  let left = -1, right = arr.length - 1; // 左开右闭区间\n  while (left < right) { //终止条件\n    let mid = left + Math.floor((right - left + 1) / 2);\n    if (arr[mid] < target) { // 目标值在右边\n      left = mid; // 更新左边界\n    } else if (arr[mid] > target) {  // 目标值在左边\n      right = mid - 1; // 更新右边界\n    } else {\n      return mid;\n    }\n  }\n}\n```\n\n* 4、开区间写法\n\n```javascript\nconst search4 = (arr, target) => {\n  let left = -1, right = arr.length; // 开区间\n  while (left + 1 < right) { //终止条件\n    let mid = left + Math.floor((right - left) / 2);\n    if (arr[mid] < target) { // 目标值在右边\n      left = mid; // 更新左边界\n    } else if (arr[mid] > target) {  // 目标值在左边\n      right = mid; // 更新右边界\n    } else {\n      return mid;\n    }\n  }\n}```\n","tags":["数组","二分查找"],"categories":["算法","二分"]},{"title":"ref和reactive的区别","url":"/2024/03/20/vue/ref和reactive的区别/","content":"# ref和reactive的区别\n1、ref适合监听基本数据类型，reactive监听复杂数据类型，如果让reactive监听基本数据类型，需要将其写对象模式，浪费空间。\n2、reactive通过Proxy返回一个代理对象实现响应,ref通过defineProperty实现。\n\n## vue2中ref和vue3中ref的区别\n在vue2中，ref主要是用来标识结点和组件的，相当于dom里面的id\n在vue3中，vue团队重写了ref,主要通过ref来创建响应式元素，并且继承了vue2中的标识作用\n\n在Vue 2中，ref的主要作用是在模板中获取DOM元素或组件实例。在Vue 3中，除了可以获取DOM元素或组件实例，还可以将一个基本类型的变量转换成响应式的数据，并且不用再通过复杂的步骤来访问响应式数据。Vue 3的ref还支持对象属性和数组索引来访问组件属性或DOM元素。\n\n在Vue 2中，ref是一个帮助我们在模板中访问DOM元素或组件实例的API。例如，我们可以使用ref来访问一个表单输入框的值或组件实例的方法。在Vue 2中，ref还可以用于在父子组件之间进行通信，通过在父组件中使用ref为子组件创建引用来访问子组件实例。\n\n在Vue 3中，ref的用途和Vue 2中一样，但它还有一些重要的新功能。在Vue 3中，ref可以包含更多类型的值，例如普通的Javascript变量、响应式的数据和一个函数。此外，Vue 3中的ref还可以用作类似于reactive函数的入口，将一个基本数据类型转换为响应式数据。而且Vue 3中的ref在访问响应式数据时，会自动进行解包和提取值，免去了Vue 2中通过$refs访问的繁琐步骤。最后，Vue 3中的ref还可以通过对象属性和数组索引来访问组件的属性或组件内的DOM元素。\n\n>原文链接：https://blog.csdn.net/qq_68805187/article/details/130856718","tags":["ref","reactive"],"categories":["基础","vue"]},{"title":"defineProperty和proxy的区别","url":"/2024/03/20/vue/defineProperty和proxy的区别/","content":"\n# defineProperty和proxy的区别\n## 响应式的目的\n当对象属性被读取后，被修改后，我要介入进行一些操作。\n属性值的读和修改变成函数\n\n## defineProperty\n他是针对属性的监听，所以对obj下的每个属性(深度遍历)进行监听。\n天生缺陷：深度遍历效率缺失；由于遍历，新增属性他是没有被监听的；\n\n```javascript\nconst obj = {\n  a:1,\n  b:2,\n  c:{\n    d:3,\n    e:4\n  },\n}\nfunction _isObject(v){\n  return typeof v==='object' && v != null\n}\nfunction observe(obj){\n  for(const k in obj){\n    let v = obj[k]\n    if (_isObject(v)){\n      observe(v)\n    }\n    Object.defineproperty(obj,'a',{\n    get(){\n      console.log('a','读取')\n      return v\n    },\n    set(newval){\n      if(v != newval){\n        v = newval\n        console.log('a','更改')\n      }\n    }\n  })\n  }\n}\n```\n\n## proxy监听整个对象\nProxy返回一个新的代理对象，不动原数据\n监听的是整个对象，所以不需要遍历，新增时可以收到通知\n```javascript\nconst obj = {\n  a:1,\n  b:2,\n  c:{\n    d:3,\n    e:4\n  },\n}\nfunction _isObject(v){\n  return typeof v==='object' && v != null\n}\n\nfunction observe(obj){\n  const proxy = new Proxy(obj,{\n    get(target,k){\n      let v = target[k]\n      if(_isObject(v)){ //这里是有递归，但只有v被读到才会触发。\n        observe(v)\n      }\n      console.log(k,'读取')\n      return v\n    },\n    set(target,k,val){\n      if(target[k] != val){\n        target[k] = val\n      }\n    }\n  })\n  return proxy\n}\n\nconst proxy = new Proxy(obj,{\n  get(target,k){\n    let v = target[k]\n    console.log(k,'读取')\n    return v\n  },\n  set(target,k,val){\n    if(target[k] != val){\n      target[k] = val\n    }\n  }\n})\n```","tags":["proxy","defineproperty"],"categories":["基础","vue"]},{"title":"26.删除有序数组中的重复项","url":"/2024/03/14/algrithm/删除有序数组中的重复项/","content":"\n# 删除有序数组中的重复项\n\n> 题目：https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/\n\n![图 0](../../images/6d151833728effb6b13d5cf8dac4fbaf30c26d4483c1f2176e227b44fb42e2db.png)\n\n\n```javascript\n// 方法一：遍历数组，splice删除重复项\nvar removeDuplicates = function(nums) {\n  for(let i = 0; i<nums.length; i++){\n    let j = i+1\n    while(nums[i] == nums[j]){\n      nums.splice(i, 1)    //我一直再写j++，其实没必要，因为数据已经被删除了\n    }\n  }\n};\n\n//方法二：双指针\nvar removeDuplicates = function(nums) {\n  let p=0,q=1   //前后指针\n  while(q<nums.length){\n    if(nums[p] != nums[q]){\n      nums[p+1] = nums[q]\n      p++\n    }\n   q++\n  }\n  return p+1\n};\n```","tags":["双指针","数组"],"categories":["算法","数组"]},{"title":"Mock的使用","url":"/2024/03/14/devlopment/mock的使用/","content":"\n# Mock的使用\n\n#### Mock是什么\n> Mock（模拟）是一种常用的测试手段。Mocking 是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚假的对象来创建以便测试的方法。 <br>\n你可能有一个函数，它需要从数据库中获取数据。在测试这个函数时，**你可能不想真的去连接数据库**，因为这会使测试变得复杂并且慢。这时，你可以创建一个 Mock 对象来模拟数据库的行为。你可以预设这个 Mock 对象的行为，让它返回你想要的数据，然后在测试中使用这个 Mock 对象，而不是真正的数据库。\n\n> Mockjs官网 https://github.com/nuysoft/Mock/wiki/Getting-Started\n>\n#### Mock安装与配置\n##### 安装\n```javascript\npnpm install -D vite-plugin-mock mockjs\n```\n##### 配置vite.config.js文件\n```javascript\nimport { UserConfigExport, ConfigEnv } from 'vite'\nimport { viteMockServe } from 'vite-plugin-mock'\nimport vue from '@vitejs/plugin-vue'\nexport default ({ command })=> {\n  return {\n    plugins: [\n      vue(),\n      viteMockServe({  //保证开发期间可以使用访问mock提供的数据\n        localEnabled: command === 'serve',\n      }),\n    ],\n  }\n}\n```\n\n在整个项目的根路径新建一个mock文件夹，在此文件夹中新建一个用户文件user.ts\n\n#### Mock模拟数据和接口\n```javascript\n//用户信息数据\n//createUserList函数执行会返回一个数组，数组里面包含两个用户信息\nfunction createUserList() {\n    return [\n        {\n            userId: 1,\n            avatar:\n                'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif',\n            username: 'admin',\n            password: '111111',\n            desc: '平台管理员',\n            roles: ['平台管理员'],\n            buttons: ['cuser.detail'],\n            routes: ['home'],\n            token: 'Admin Token',\n        },\n        {\n            userId: 2,\n            avatar:\n                'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif',\n            username: 'system',\n            password: '111111',\n            desc: '系统管理员',\n            roles: ['系统管理员'],\n            buttons: ['cuser.detail', 'cuser.user'],\n            routes: ['home'],\n            token: 'System Token',\n        },\n    ]\n}\n\nexport default [\n    // 用户登录接口\n    {\n        url: '/api/user/login',//请求地址\n        method: 'post',//请求方式\n        response: ({ body }) => {\n            //获取请求体携带过来的用户名与密码\n            const { username, password } = body;\n            //调用获取用户信息函数,用于判断是否有此用户\n            const checkUser = createUserList().find(\n                (item) => item.username === username && item.password === password,\n            )\n            //没有用户返回失败信息\n            if (!checkUser) {\n                return { code: 201, data: { message: '账号或者密码不正确' } }\n            }\n            //如果有返回成功信息\n            const { token } = checkUser\n            return { code: 200, data: { token } }\n        },\n    },\n    //对外暴露一个数组，\n    //数组中包含登录假接口\n    //还有一个获取用户信息得到假的接口\n    {\n        url: '/api/user/info',\n        method: 'get',\n        response: (request) => {\n            //获取请求头携带token\n            const token = request.headers.token;\n            //查看用户信息是否包含有次token用户\n            const checkUser = createUserList().find((item) => item.token === token)\n            //没有返回失败的信息\n            if (!checkUser) {\n                return { code: 201, data: { message: '获取用户信息失败' } }\n            }\n            //如果有返回成功信息\n            return { code: 200, data: {checkUser} }\n        },\n    },\n]\n```","tags":["mock"],"categories":["开发","前端"]},{"title":"vue 的响应式框架 （1.0）","url":"/2024/03/14/vue/vue的响应式思路/","content":"# vue 的响应式框架 （1.0）\n\n>**思路：属性发生变化时，调用依赖这些属性的函数**\n\n#### 一、实现的过程需要解决以下一些问题\n- 1.如何追踪属性发生了变化\n- 2.如何知道该属性被哪些依赖使用\n- 3.如何执行依赖的函数\n- 4.如何避免重复执行依赖的函数\n\n#### 二、基础知识\n>object.defineProperty(obj, prop, descriptor)方法介绍\n\n```javascript\n//定义一个对象\nvar obj = {\n  name: '张三',\n  age : 20\n}\n\nobject.defineProperty(obj,name){\n  get:function(){\n    console.log('有人读取了name属性')\n    return obj.name\n  }\n  set function(val){  //obj中的name发生那个变化后，会调用set函数。因此可在这里调用其依赖函数\n    obj.name = val\n    console.log('有个家伙在给name属性赋值')\n  }\n}\n```\n>去重\n\n```javascript\n//方法一：Set集合，可以判断，如果当前的值和之前的值相同，则不执行依赖函数\nlet funcs = new Set()\n//方法二：ES6中的includes方法，判断当前的值是否在数组中，如果在，则不执行依赖函数\nlet funcs = []\nif (!funcs.includes(func)) {\n  funcs.push(func)\n}\n```\n#### 三、难点\n> 此时我们已经解决了问题1和问题4，也知道了依赖函数应该在set中执行。那么如何知道属性被哪些依赖使用呢？\n\n```javascript\n// 不直接运行函数，而是使用定义一个全局变量，这样只要使用这个统一变量的名称运行函数，就能拿到函数了\nwindow.__func = func1\n  func1()\nwindow.__func = null\n//这样只需在get中添加window.__func到数组即可\n```\n\n#### 四、实现\n\n```javascript\n//首先新建一个js，在这个新的js中实现上述代码\n//定义一个观察者，监视对象的属性\nfunction Observer(obj) {\n  for (const key in obj){\n    let intervalValue = obj[key]\n    let observers = new Set()    //用来保存相关依赖\n    //使用Object.defineProperty()方法，给obj的key属性添加get和set方法\n    defineProperty(obj, key, obj[key]){\n      get: function(){\n        if (window.__func){  //存在说明有函数在运行，是哪个函数呢，那个函数名使用window.__func可以访问到\n          observers.add(window.__func)\n        }\n        return intervalValue\n      },\n      set: function(val){\n        console.log('有人修改了' + key + '属性，我要去通知我的订阅者了')\n        obj[key] = val\n        //通知所有的订阅者,重新运行\n        observers.forEach(observer => observer())\n      }\n    }\n  }\n}\n\n// 定义一个统一执行函数的函数\nfunction autoRun(fn){\nwindow.__func = fn\nfn()\nwindow.__func = null\n  }\n\n//函数调用时用autoRun不要直接运行\nautoRun(func1())\nautoRun(func2())\n```","tags":["vue","响应式数据"],"categories":["基础","vue"]},{"title":"git多人合作","url":"/2023/09/07/devlopment/git多人协作/","content":"\n# git实现多人合作\n## 整体思路\n* 1、首先需要新建一个组织，组织中新建一个仓库，组织中新建一个team。\n* 2、队员们frok组织中的仓库，此时队员自身账号中的仓库是fork仓库，而组织中的仓库为原仓库\n* 3、队员们clone自己的fork仓库到本地目录\n* 4、在本地目录`git remote add upstream <组织仓库名>`\n* 5、队员修改文件后，通过`git add` `git commit` `git push`到自己的仓库\n* 6、队员申请`pull request`\n* 7、仓库合并队员的分支\n* 8、其他队员`git pull upstream main`，将仓库中的最新文件合并到本地目录\n\n### 详细过程\n> https://www.cnblogs.com/thousfeet/p/7840932.html\n> https://www.cnblogs.com/eyunhua/p/13215936.html\n\n### 原理\n\n![图 0](../../images/136b897d9b2367b76a9056204bd462706f66f376ba7dcf06d6ca2bca3b9f3355.png)","tags":["git","fork"],"categories":["开发","前端"]},{"title":"数据获取与删除前后端","url":"/2023/04/08/devlopment/数据获取与删除前后端/","content":"# 数据获取与删除前后端\n## 数据获取\n下图所示页面是页面挂载时的场景，场景值为0；\n所以当页面挂载前（onBeforeMount），和监听（watch）到场景切换为0的时候需要进行数据获取。\n\n![图 0](../../images/b2e9f82224018dea5156e6a487f62e02b9c8b949f9abcdfd9cbc8773e32ebab0.png)\n\n实现思路\n* 后端创建view用于获取数据，并设置urls\n* 在组件中定义一个数组类型的变量名为dataShowVar，用于存储需要展示的数据\n* 封装获取数据的api\n* 在组件中定义获取数据的函数getData\n* 在watch监听scene中和onBeforeMount中调用GetData函数\n* 在table中设置:data=\"dataShowVar\",设置el-table-column的prop属性\n>要注意前端通过api传给后端的数据要和后端设置好的数据格式一致，eg后端要求传入json格式，前端需要加工好需要的json，然后让如请求体传给后端。\n\n### 后端代码\n* view定义视图\n* urls定义访问接口\n```python\n# 获取数据\n@csrf_exempt\ndef get_data(request):\n  if request.method == 'GET':\n    data = AnomalyData.objects.all()\n    data_list = []\n    for item in data:\n      data_list.append({\n        'id': item.id,\n        'name': item.name,\n        'type': item.type,\n        'date': item.date,\n        'intensity_file': item.intensity_file.url,\n        'impact_file': item.impact_file.url,\n        'attribute_file': item.attribute_file.url\n      })\n    return JsonResponse({'status': 'success', 'code': 200, 'data': data_list})\n  return JsonResponse({'status': 'fail', 'code': 400, 'message': 'Invalid request method'})\n```\n![图 2](../../images/d147c93d4297bd34193d826276256f764e475248876139c4ad48dabbccd1027b.png)\n\n### 前端代码\n```javascript\n//el-table展示数据，关键在于:data属性，prop属性\n<el-table stripe :data=\"dataShowVar\">\n      <el-table-column label=\"序号\" type=\"index\" align=\"center\" width=\"90px\"></el-table-column>\n        <el-table-column prop=\"name\" label=\"异常名称\" width=\"180\" ></el-table-column>\n        <el-table-column prop=\"type\" label=\"异常类型\" width=\"180\" ></el-table-column>\n        <el-table-column prop=\"date\" label=\"发生时间\" ></el-table-column>\n</el-table>\n//定义数组，必须是数组，因为el-table的:data属性接受的是Array类型\nlet dataShowVar = ref<any[]>([{\n  name:'',\n  type:'',\n  date:'',\n  intensity_file:'',\n  impact_file:'',\n  attribute_file:''\n}])\n\n// 获取数据的函数\n// 其中reqGetData是封装好的api\nconst getData = async()=>{\n  const res = await reqGetData()\n  if (res.code === 200){\n    dataShowVar.value = res.data\n  }\n  else{\n    console.log('获取数据失败')\n  }\n}\n// 场景切换为0时获取数据，更新表格\nwatch(scene, (newVal)=>{\n  if (newVal === 0){\n    getData()\n  }\n})\n// 挂载之前获取数据\nonBeforeMount(()=>{\n  getData()\n})\n```\n## 删除某一条数据\ntable中的每一行都有一个删除按钮，点击该按钮删除对应的一条数据\n* 首先实现后端，删除操作。实质是根据id删除数据库中的一条记录\n* 前端封装删除请求的api\n* 前端要传给后端id，注意传入的格式要和后端要求一致\n> 由于使用的是el-table，还需要使用插槽，才能将每一条记录的id传入。以下是使用方法的介绍\n\n```\n使用了 Vue 的插槽（slot）特性。插槽是 Vue 组件中的一个重要特性，它允许你在组件模板中定义可替换的内容。\n\n在这段代码中，<el-table-column> 组件使用了一个名为 # 的插槽。这个插槽接收一个参数 row，这个参数表示当前行的数据。然后，这个插槽的内容（即 <el-button> 和 <el-popconfirm> 组件）会被插入到 <el-table-column> 组件的模板中。\n\n<el-button> 组件是一个按钮，它有一个 icon 属性，这个属性定义了按钮的图标。这个按钮没有 @click 事件处理器，所以点击这个按钮不会有任何效果。\n\n<el-popconfirm> 组件是一个弹出确认框，它有一个 :title 属性，这个属性定义了确认框的标题。这个标题是一个模板字符串，它包含了 row.attrName 的值。这个组件还有一个 @confirm 事件处理器，这个处理器会在用户点击确认按钮时被调用。这个处理器调用了 deleteData 函数，并传递了 row.id 作为参数。\n\n<el-popconfirm> 组件还使用了一个名为 reference 的插槽。这个插槽的内容（即 <el-button> 组件）会被插入到 <el-popconfirm> 组件的模板中。这个按钮有一个 icon 属性，这个属性定义了按钮的图标。点击这个按钮会弹出确认框。\n\n总的来说，这段代码定义了一个表格，这个表格的每一行都有一个删除按钮。点击这个按钮会弹出一个确认框，确认框的标题包含了当前行的 attrName 属性的值。点击确认按钮会删除当前行的数据。\n```\n\n### 后端代码\n```python\n# views.py\n@csrf_exempt\ndef delete_data(request):\n  if request.method == 'POST':\n    data = json.loads(request.body)\n    id = data.get('id')\n    if not id:\n      return JsonResponse({'status': 'fail', 'code': 400, 'message': 'Missing required fields'})\n    AnomalyData.objects.filter(id=id).delete()\n    response_data = {\n      'status': 'success',\n      'code': 200,\n      'args': data,  # 请求参数\n      'headers': dict(request.headers),  # 请求头\n      'url': request.build_absolute_uri(),  # 请求的完整 URL\n    }\n    return JsonResponse(response_data)\n  return JsonResponse({'status': 'fail', 'code': 400, 'message': 'Invalid request method'})\n\n# urls.py\nurlpatterns = [\n    re_path(r'^deletedata/?$', views.delete_data, name='anomaly'),\n]\n```\n\n### 前端代码\n\n```javascript\n// 使用了插槽\n<el-table stripe :data=\"dataShowVar\">\n      <el-table-column label=\"序号\" type=\"index\" align=\"center\" width=\"90px\"></el-table-column>\n        <el-table-column prop=\"name\" label=\"异常名称\" width=\"180\" ></el-table-column>\n        <el-table-column prop=\"type\" label=\"异常类型\" width=\"180\" ></el-table-column>\n        <el-table-column prop=\"date\" label=\"发生时间\" ></el-table-column>\n        <el-table-column prop=\"operator\" label=\"操作\">\n          <!-- 定义一个名为#的插槽，插槽接受参数row，代表当前行的数据 -->\n          <template #=\"{ row }\">\n            <el-button\n              size=\"small\"\n              icon=\"Monitor\"\n              @click=\"\"\n            >综合</el-button>\n            <!--使用了泡泡，确定是否删除-->\n            <el-popconfirm\n              :title=\"`确定要删除${row.attrName}属性吗？`\"\n              width=\"250px\"\n              @confirm=\"deleteData(row.id)\"\n            >\n              <template #reference>\n                <el-button\n                  size=\"small\"\n                  icon=\"Delete\"\n                >删除</el-button>\n              </template>\n            </el-popconfirm>\n            <el-button size=\"small\" icon=\"View\"  @click=\"scene=2\">展示</el-button>\n          </template>\n        </el-table-column>\n</el-table>\n// 删除函数\n// reqDeleteData是封装好的删除请求\nconst deleteData = async(row : any) => {\n  console.log('row',row)\n  //删除输入的数据要符合后端要求的格式\n  const body_json = {'id': row}\n  const res = await reqDeleteData(body_json)\n  if (res.code === 200){\n    console.log('删除成功')\n    getData()\n  }\n  else{\n    console.log('删除失败')\n  }\n}\n```\n\n## 参考文档\n> https://cn.vuejs.org/api/composition-api-lifecycle.html\n> https://element-plus.org/zh-CN/component/table.html\n","tags":["Django","Element Plus","插槽"],"categories":["开发","前端","Django"]},{"title":"文件上传和表单提交的前后端构建","url":"/2023/04/06/devlopment/文件上传和表单提交的前后端构建/","content":"# 文件上传和表单提交的前后端构建\n## 前端的结构\n* 定义一个upload组件\n* 在父组件中引入三个upload组件\n* 在父组件中用ref获取每一个upload组件\n* 每个upload组件中定义fileList 和uploadFlag属性，并暴露(defineExpose)\n* upload中使用:http-request=自定义上传函数（后端有对应view）,书写上传逻辑\n* 上传成功后fileList等一些列属性收集到值\n* 在父组件中点击submit，收集表单数据，包括name、type、date和三个upload组件中的fileList值，并发起提交请求。\n* 当然在api文件夹中封装请求，在组件中直接调用请求即可\n\n### upload组件\n>使用Element-Plus的组件upload  https://element-plus.org/zh-CN/component/upload.html\n\nupload中的逻辑\n```javascript\n<template>\n  <!-- upload组件 -->\n  <!-- action字段中的值是后端提供的 -->\n  <!-- :http-request=\"uploadData\"，其中uploadData是自定义的上传函数 -->\n  <el-upload\n    v-model:fileList=\"fileList\"\n    accept=\".zip\"\n    class=\"divBoxofUpload\"\n    action=\"http://127.0.0.1:8000/upload\"\n    multiple\n    :show-file-list=\"true\"\n    :on-preview=\"handlePreview\"\n    :on-remove=\"handleRemove\"\n    :before-remove=\"beforeRemove\"\n    :limit=\"1\"\n    :on-exceed=\"handleExceed\"\n    :on-change=\"handleChange\"\n    :on-success=\"handleSuccess\"\n    :http-request=\"uploadData\"\n    >\n    <el-button size=\"default\" type=\"primary\" style=\"margin-right:10px;\">点击上传压缩包</el-button>\n  </el-upload>\n</template>\n\n<script setup lang=\"ts\">\n  import { ref, toRaw } from 'vue'\n  import { ElMessage, ElMessageBox } from 'element-plus'\n  import{ reqUploadFile } from '@/api/map/index'\n  import type { UploadProps } from 'element-plus'\n\n  let fileList = ref<any[]>([])\n  let uploadFlag = ref(false)\n  const handleRemove: UploadProps['onRemove'] = (file, uploadFiles) => {\n    console.log(file, uploadFiles)\n  }\n  // 自定义上传函数的处理逻辑，将请求后返回的文件url，和文件name赋值给fileList，再由组件传给其父组件。\n  const uploadData: UploadProps['httpRequest'] = async(uploadData) => {\n    const res = await reqUploadFile(uploadData)\n    if (res.code === 200) {\n      console.log(res.data.name,res.data.file_url)\n      fileList.value = [{name:res.data.name , url:res.data.file_url}]\n\n      console.log('fileList',toRaw(fileList.value))\n      uploadFlag.value = true\n    } else {\n      ElMessage.error('Upload failed')\n    }\n  }\n  //暴露出父组件要访问的两个字段。\n  defineExpose({\n        fileList,\n        uploadFlag\n      })\n</script>\n\n<style scoped>\n.divBoxofUpload {\n  padding-left: 10px;\n  display: flex;\n  align-items: center;\n}\n</style>\n```\n### upload的父组件中的逻辑\nupload的父组件中有一个表单，也就是场景为1时的el-card\n* 用于收集信息的表单name、type、date、和三个upload组件\n* 用于提交数据的submit按钮，取消提交的取消按钮\n* submit点击后发起表单提交的请求\n\n\n> 表单提交的逻辑：收集信息，将表单中的name、type、date、和三个upload组件的fileList收集起来，提交给后端。后端返回200表示提交成功后，清空表单数据，切换场景。\n\n```javascript\n<template>\n  <el-card v-if=\"scene === 0\" class=\"dataShow\">\n    <el-button type=\"primary\" size=\"default\" icon=\"Plus\" style=\"margin-bottom:10px\" @click=\"addData\">添加数据</el-button>\n    <el-button type=\"primary\" size=\"default\" icon=\"Plus\" style=\"margin-bottom:10px\" @click=\"scene=2\">抽屉</el-button>\n    <h3>数据列表</h3>\n    <el-table stripe>\n    <el-table-column prop=\"name\" label=\"异常名称\" width=\"180\"></el-table-column>\n    <el-table-column prop=\"type\" label=\"异常类型\" width=\"180\"></el-table-column>\n    <el-table-column prop=\"date\" label=\"发生时间\"></el-table-column>\n    <el-table-column prop=\"operator\" label=\"操作\">\n      <el-button icon=\"Monitor\">综合</el-button>\n      <el-button icon=\"Delete\">删除</el-button>\n    </el-table-column>\n  </el-table>\n  </el-card>\n  <el-card v-if=\"scene === 1\" class=\"dataLoad\">\n    <el-form label-width=\"100px\">\n      <el-form-item label=\"异常名称\">\n        <el-input v-model=\"dataUpLoadVar.name\"></el-input>\n      </el-form-item>\n      <el-form-item label=\"异常类型\" >\n        <el-select v-model=\"dataUpLoadVar.type\">\n          <el-option label=\"火灾\" value=\"fire\"></el-option>\n          <el-option label=\"地震\" value=\"earthquake\"></el-option>\n          <el-option label=\"水华\" value=\"algae_bloom\"></el-option>\n          <el-option label=\"滑坡\" value=\"landslide\"></el-option>\n          <el-option label=\"其他\" value=\"other\"></el-option>\n        </el-select>\n      </el-form-item>\n      <el-form-item label=\"发生时间\" >\n        <el-input type=\"date\"  v-model=\"dataUpLoadVar.date\"></el-input>\n      </el-form-item>\n      <el-form-item label=\"异常强度数据\" >\n        <div class=\"uploadDiv\">\n          <upload ref=\"loadIntensity\" ></upload>\n        </div>\n      </el-form-item>\n      <el-form-item label=\"异常影响数据\" >\n        <div class=\"uploadDiv\">\n          <upload ref=\"loadInfluence\" ></upload>\n        </div>\n      </el-form-item>\n      <el-form-item label=\"异常属性数据\" >\n        <div class=\"uploadDiv\">\n          <upload ref=\"loadProperty\" ></upload>\n        </div>\n      </el-form-item>\n    </el-form>\n    <div class=\"btnPosition\">\n      <el-button type=\"primary\" size=\"default\" @click=\"cancel\">取消</el-button>\n      <el-button type=\"primary\" size=\"default\" @click=\"submitData\">提交</el-button>\n    </div>\n  </el-card>\n  <!-- ref=\"mainCRef\" 控制子组件 -->\n  <mainC v-if=\"scene === 2\"  @changemainScene=\"changeSceneTo\"></mainC>\n</template>\n\n<script setup lang=\"ts\">\nimport {ref, provide} from 'vue'\nimport {reqSubmitData} from '@/api/map/index'\nimport upload from './upload/index.vue'\nimport mainC from '@/view/mainC/index.vue'\nimport { ElMessage } from 'element-plus';\nlet scene = ref(0)\n// 父传给子的属性\n// let intensityFileList:Array<any> =[];\n// let impactFileList:Array<any> = [];\n// let attributeFileList:Array<any> = [];\nprovide('pscene', scene)\n//数据上传页面所需变量\nlet dataUpLoadVar = ref<any>({\n  name:'',\n  type:'',\n  date:'',\n  intensity:'',\n  influence:'',\n  property:''\n})\n// 获取子组件的实例\nconst loadIntensity = ref()\nconst loadInfluence = ref()\nconst loadProperty = ref()\nlet mainCRef = ref()\nconst addData = ()=>{\n  scene.value = 1\n  console.log('添加数据')\n  //导入本地数据\n\n}\n// 提交函数\nconst submitData = () => {\n  console.log('提交数据')\n  const formData = new FormData()\n  formData.append('name', dataUpLoadVar.value.name)\n  formData.append('type', dataUpLoadVar.value.type)\n  formData.append('date', dataUpLoadVar.value.date)\n  // console.log(loadIntensity.value.fileList[0].url)\n  // console.log(loadInfluence.value.fileList[0].url)\n  // console.log(loadProperty.value.fileList[0].url)\n  formData.append('intensity_file',loadIntensity.value.fileList[0].url)\n  formData.append('impact_file', loadInfluence.value.fileList[0].url)\n  formData.append('attribute_file', loadProperty.value.fileList[0].url)\n  // 不能直接console.log(FormData),需要遍历\n  // 打印 FormData 对象的内容\n  for (let [key, value] of formData.entries()) {\n    console.log(key, value)\n  }\n\n  // 提交数据\n  reqSubmitData(formData).then(res => {\n    console.log(res)\n    if (res.code === 200) {\n      console.log('提交成功')\n    } else {\n      console.log('提交失败')\n      ElMessage.error('提交失败')\n    }\n  })\n  // 清空数据\n  dataUpLoadVar = Object.assign(dataUpLoadVar.value, {\n    name: '',\n    type: '',\n    date: '',\n    // ...\n  })\n\n  //切换场景\n  scene.value = 0\n}\n\nconst cancel = ()=>{\n  console.log('取消')\n  // 清空数据\n  dataUpLoadVar =  Object.assign(dataUpLoadVar.value,{\n    name:'',\n    type:'',\n    date:'',\n    intensity:'',\n    influence:'',\n    property:''\n  })\n  //切换场景\n  scene.value = 0\n}\nconst changeSceneTo = (num: number)=>{\n  scene.value = num\n}\n</script>\n```\n\n## 后端结构\n> Django\n* models.py：这个文件定义了你的数据模型。在 Django 中，**一个模型代表了数据库中的一个表，模型的一个实例代表了表中的一行**。模型中的每个字段都是数据库表中的一个列。\n* views.py：这个文件定义了你的视图。在 Django 中，一个视图是一个 Python 函数，它接收一个 Web 请求并返回一个 Web 响应。这个响应可以是 HTML 的内容、重定向或者 404 错误等。\n* forms.py：这个文件定义了你的表单。在 Django 中，**表单是用来收集和处理用户输入的一种工具**。表单可以生成 HTML 表单的代码，验证和清理用户提交的数据。\n* urls.py：这个文件定义了你的 URL 配置。在 Django 中，URL 配置是一个 URL 模式和一个视图函数之间的映射。当 Django 收到一个请求时，它会根据请求的 URL，查找匹配的 URL 模式，然后调用相应的视图函数。\n\n### models\n>定义两个models，也就是定义两个表，分别是uploadFile和AnomalyData\n\n>uploadFile用于保存上传的每个文件的url，AnomalyData用于保存每次提交后的表单数据。\n\n```python\nfrom django.db import models\nimport uuid\n\ndef generate_unique_name():\n  return str(uuid.uuid4())\n\nclass upLoadFile(models.Model):\n  # name = models.CharField(max_length=255, default=generate_unique_name)  # 文件名\n  file_path = models.FileField(upload_to='uploads/')  # 文件路径\n  # size = models.IntegerField()  # 文件大小\nclass AnomalyData(models.Model):\n  # upload_to 可以是一个字符串，也可以是一个函数。如果它是一个字符串，\n  # 那么这个字符串会被添加到你的 MEDIA_ROOT 设置的路径后面，来形成文件的完整路径。\n  # 例如，如果你的 MEDIA_ROOT 是 /var/www/mywebsite/media/，并且 upload_to 是 'uploads/intensity/'，\n  # 那么上传的文件会被保存到 /var/www/mywebsite/media/uploads/intensity/ 目录。\n  intensity_file = models.FileField(upload_to='submit/intensity/')\n  impact_file = models.FileField(upload_to='submit/impact/')\n  attribute_file = models.FileField(upload_to='submit/attribute/')\n  name = models.CharField(max_length=200)\n  type = models.CharField(max_length=200)\n  date = models.DateField()\n```\n\n### form\n创建表单数据\n```python\nfrom django import forms\nclass SubmitForm(forms.Form):\n  name = forms.CharField(label='异常名称')\n  type = forms.ChoiceField(label='异常类型', choices=[\n    ('fire', '火灾'),\n    ('earthquake', '地震'),\n    ('algae_bloom', '水华'),\n    ('landslide', '滑坡'),\n    ('other', '其他'),\n  ])\n  date = forms.DateField(label='发生时间')\n  density_file = forms.FileField(label='异常强度数据')\n  impact_file = forms.FileField(label='异常影响数据')\n  attribute_file = forms.FileField(label='异常属性数据')\n\n\n# 上传文件的表单\nclass UploadFileForm(forms.Form):\n  file = forms.FileField(label='文件')\n```\n### views\n* 实现上传文件和提交表单的视图\n>上传文件后，返回文件再文件系统中的url和名称\n\n>提交表单数据后，将数据保存到AnomalyData表中\n\n```python\nfrom django.core.files.storage import FileSystemStorage\nfrom .models import AnomalyData, upLoadFile\n\n# 上传文件\n@csrf_exempt\ndef upload_file(request):\n  if request.method == 'POST':\n    uploaded_file = request.FILES['file']\n    # 指定了上传文件的保存路径\n    fs = FileSystemStorage('uploads/')\n    name = fs.save(uploaded_file.name, uploaded_file)\n    # 生成url\n    file_url = fs.url(name)\n\n    # 保存文件路径到数据库\n    upLoad_data = upLoadFile(file_path=file_url)\n    upLoad_data.save()\n\n    # 成功后返回必要的code，status等字段，还需返回文件的名称和file_url\n    return JsonResponse({\n      'status': 'success',\n      'code': 200,\n      'data': {\n        'file_url': file_url,\n        'name': name\n      }\n    })\n\n  return JsonResponse({\n    'code': 400,\n    'error': 'Invalid method',\n    'status': 'failed'\n  })\n\n# 提交表单\n@csrf_exempt\ndef submit_form(request):\n  # 前端提供一个FormData，从FormData中获取需要的字段值，使用request.POST.get('字段名')\n  if request.method == 'POST':\n    name = request.POST.get('name')\n    type = request.POST.get('type')\n    date = request.POST.get('date')\n    intensity_file = request.POST.get('intensity_file')\n    impact_file = request.POST.get('impact_file')\n    attribute_file = request.POST.get('attribute_file')\n    print(name, type, date, intensity_file, impact_file, attribute_file)\n    # 如果有一个是空的，返回提交失败\n    if not all([name, type, date, intensity_file, impact_file, attribute_file]):\n      return JsonResponse({'status': 'fail', 'code': 400, 'message': 'Missing required fields'})\n    # 如果表单中的所有元素都有值，保存到数据库中的AnomalyData表中\n    # anomaly_data是一个AnomalyData实例，每个实例代表表中的一行记录\n    anomaly_data = AnomalyData(name=name, type=type, date=date, intensity_file=intensity_file, impact_file=impact_file, attribute_file=attribute_file)\n    anomaly_data.save()\n    return JsonResponse({'status': 'success', 'code': 200})\n```\n### urls\n定义上传文件和提交表单信息的url\n\n```python\nfrom django.contrib import admin\nfrom django.urls import re_path\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    re_path(r'^admin/?$', admin.site.urls),\n    re_path(r'^register/?$', views.register , name='register'),\n    re_path(r'^login/?$', views.login_view, name='login'),\n    re_path(r'^logout/?$', views.logout_view, name='logout'),\n    re_path(r'^upload/?$', views.upload_file, name='upload'),\n    re_path(r'^submit/?$', views.submit_form, name='submit'),\n]\n```\n","tags":["Django","Element-PLus"],"categories":["开发"]},{"title":"登录注册Django后端搭建","url":"/2023/03/09/devlopment/登录注册Django后端搭建/","content":"# 登录注册Django后端搭建\n## 安装Django并初始化项目\n* 安装 `pip install django==2.2.28`  此处指定了的版本，可以兼容环境中的其他库\n\n* 项目目录组织如下：\n  >/myproject\n  ├── frontend   前端代码\n  └── backend    后端代码\n\n* 在项目根目录下使用以下命令创建一个新的 Django 项目\n  `django-admin startproject backend`\n\n* 处理数据库迁移\n  python manage.py makemigrations 和 python manage.py migrate 是 Django 的命令行工具中的两个命令，用于处理数据库迁移。\n\n  1、python manage.py makemigrations：这个命令会检查你的 Django 项目中的所有模型，并创建迁移文件。这些迁移文件是 Django 用来跟踪你的模型和数据库模式之间的变化的方式。每当你修改了模型（例如，添加字段、删除字段、更改字段类型等），你都需要运行这个命令来创建一个新的迁移文件。\n\n  2、python manage.py migrate：这个命令会应用（执行）所有还未应用的迁移。这意味着它会执行迁移文件中的操作，将这些变化应用到数据库模式中。例如，如果你添加了一个新的字段，migrate 命令会在相应的表中添加一个新的列。\n\n## 增加注册和登录的后端\n* 1、新建views.py文件夹，在其中写登陆注册的相关逻辑\n  ```python\n  import json\n  from django.http import JsonResponse\n  from django.views.decorators.csrf import csrf_exempt\n  from django.contrib.auth.models import User\n  from django.contrib.auth import authenticate, login\n\n  # 注册功能\n  @csrf_exempt\n  def register(request):\n    if request.method == 'POST':\n      data = json.loads(request.body)\n      username = data.get('username')\n      password = data.get('password')\n\n      # 验证用户名长度\n      if len(username) < 4:\n        return JsonResponse({'status': 'error', 'message': 'Username must be at least 4 characters'}, status=400)\n\n      # 验证密码长度和格式\n      if len(password) < 6 or not any(char.isdigit() for char in password) or not any(char.isalpha() for char in password):\n        return JsonResponse({'status': 'error', 'message': 'Password must be at least 6 characters and contain at least one digit and one letter'}, status=400)\n\n      user = User.objects.create_user(username, password=password)\n      return JsonResponse({'status': 'success'}, status=201)\n\n  # 登录\n  @csrf_exempt\n  def login_view(request):\n    if request.method == 'POST':\n      data = json.loads(request.body)\n      username = data.get('username')\n      password = data.get('password')\n      user = authenticate(request, username=username, password=password)\n      if user is not None:\n        login(request, user)\n        return JsonResponse({'status': 'success', 'token': request.session.session_key}, status=200)\n      else:\n        return JsonResponse({'status': 'error', 'message': 'Invalid credentials'}, status=401)\n    else:\n      return JsonResponse({'status': 'error', 'message': 'Invalid request method'}, status=400)\n  ```\n* 2、在urls.py文件中配置路由\n  ```python\n  from django.contrib import admin\n  from django.urls import path\n  from . import views\n\n  urlpatterns = [\n      path('admin/', admin.site.urls),\n      path('register/', views.register , name='register'),\n      path('login/', views.login_view, name='login'),\n  ]\n  ```\n## 启动服务并在postman中测试\n` python manage.py runserver `\n\n![图 0](../../images/2609ba452af6c61b944757bdae0dbf034ca208aceea9f16ff6c7b0ccc464aba4.png)\n\n\n## 在实现前端时出现的问题\n数据组织形式\n\n在前端中我是用了`res.data.username`但是在后端中我没有使用Json格式返回数据，返回数据中也没有data字段，所以导致前端访问不到数据。\n\n后端中的接口以login为例，必须以`...\\login\\`访问，而我前端访问的地址是`login`导致访问失败。解决办法是修改后端路由。\n\n```python\nfrom django.contrib import admin\nfrom django.urls import re_path   # 一定要引入此库\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    re_path(r'^admin/?$', admin.site.urls),\n    re_path(r'^register/?$', views.register , name='register'),\n    re_path(r'^login/?$', views.login_view, name='login'),\n]\n```\n","tags":["Django"],"categories":["开发","Django"]},{"title":"地图组件联动开发","url":"/2023/03/07/devlopment/地图组件可视化/","content":"# 地图组件联动开发\n开发目标简介：\n* 1、点击按钮切换到场景2。\n* 2、在该场景的div中创建两个地图组件，分别用于展示原始地图和综合后地图数据。\n* 3、使两个地图组件互相影响，缩放或拖动其中一个子组件中的地图，另外一个也跟着变化\n\n## 创建地图组件\n开发目标：\n* 实现瓦片地图加载啊\n* 地图缩放控件\n* 地图图层切换控件\n\n### 使用leaflet.chinatmsproviders新建多种图层\n基本语法：`L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{})`\n\n该方法的第一个参数定义了图层类型\n\n>首先使用该方法返回并接受图层\n\n>接着定义baseLayer对象，其中保存了图层名及其值也就是上述函数返回的图层\n\n>然后这是地图初始化需要的值mapValue，是一个对象，其中包括坐标系、中心点经纬度、缩放等级、图层类型、是否添加缩放空间等属性。\n\n>定义初始化函数，在挂载时调用。添加控件\n```javascript\n// map是在初始化函数外定义的响应式数据\nmap.value = L.map('mapid', mapValue) //第一个参数是放置地图的容器的id名，第二个参数是上述的初始化值\nL.control.layers(baseLayers, null).addTo(map.value)\n\n// L.control.layers(baseLayers, null).addTo(map.value) 这行代码做了以下几件事：\n\n// L.control.layers(baseLayers, null) 创建了一个新的图层控制器。baseLayers 是一个对象，\n// 它的每个键值对定义了一个基础图层。在这个例子中，null 表示没有叠加层。\n\n// .addTo(map.value) 将这个图层控制器添加到了地图上。map.value 应该是一个 L.Map 实例。\n\n//返回L.Map构造的实例\nreturn map.value\n```\n\n完整的代码，此时还未实现动图组件互动\n```javascript\n<template>\n  <div id=\"mapid\" style=\"height: 100%\"></div>\n</template>\n\n<script setup lang=\"ts\">\nimport {ref, inject, onUnmounted, watch, nextTick, onMounted} from 'vue'\nimport L from 'leaflet'\nlet pscene: any = inject('pscene')\nimport 'leaflet.chinatmsproviders'\n\nlet map = ref<any>(null);\nconst normalm3 = L.tileLayer.chinaProvider(\n    'Geoq.Normal.PurplishBlue',\n    {}\n  )\n  // Google map layers\n  const normalMap = L.tileLayer.chinaProvider('Google.Normal.Map', {})\n  const satelliteMap = L.tileLayer.chinaProvider(\n    'Google.Satellite.Map',\n    {}\n  )\n  // 高德地图\n  const Gaode = L.tileLayer.chinaProvider('GaoDe.Normal.Map', {})\n  const Gaodimage = L.tileLayer.chinaProvider('GaoDe.Satellite.Map', { })\n\n\n  // Create base layers with different tile layers\n  const baseLayers = {\n    智图午夜蓝: normalm3,\n    谷歌地图: normalMap,\n    谷歌影像: satelliteMap,\n    高德地图: Gaode,\n    高德影像: Gaodimage,\n  }\n//初始化地图\nconst mapValue = {\n    crs: L.CRS.EPSG3857,\n    center: [32.0603, 118.7969],\n    zoom: 12,\n    maxZoom: 18,\n    minZoom: 5,\n    layers: [normalMap],\n    zoomControl: true\n  }\nconst initMap = () => {\n    map.value = L.map('mapid', mapValue)\n\n  // Add control layers and zoom control to the map\n\n  L.control.layers(baseLayers, null).addTo(map.value)\n  return map.value\n}\n\nonMounted(() => {\n  const mapInstance = initMap()\n  //等初始化完成后，强制地图重新计算大小和位置\n  nextTick(() => {\n    // 强制地图重新计算大小和位置\n    if (mapInstance){\n      mapInstance.invalidateSize();\n    }\n  });\n  mapInstance.on('zoomend dragend', () => {\n    emit('map-moved', { center: mapInstance.getCenter(), zoom: mapInstance.getZoom() })\n  })\n\n})\n\nonUnmounted(() => {\n  if (map.value) {\n    map.value.remove();\n    map.value = null;\n  }\n})\n\n</script>\n\n<style scoped>\n#mapid {\n  height: 100%;\n}\n</style>\n```\n\n### 在父组件中导入组件\n```javascript\n<template>\n  <div class=\"mainBox\" >\n    <el-button size=\"small\" style=\"margin:0px; border-color: aliceblue;\" icon=\"CloseBold\" @click=\"changeScene\"></el-button>\n    <div class=\"mapOuterBox\" >\n      <!-- 左边的地图组件 -->\n      <mapBox ref=\"mapBox1\" class=\"leftMap\" @map-moved=\"handelMapMoved2\"></mapBox>\n      <!-- 中间的地图组件 -->\n      <mapBoxMid ref=\"mapBox2\" class=\"midMap\" @map-moved=\"handelMapMoved1\"></mapBoxMid>\n    <div class=\"rightMap\">文字展示</div>\n    </div>\n  </div>\n</template>\n```\n\n## 互动效果实现\n> 使用自定义事件emit，当地图发生缩放或者拖拽时，在附件中监听到该自定义事件。在父组件通知另外一个地图组件进行中心点和缩放等级的变化。\n\n因此步骤如下\n* 在左中两个地图组件中，监听地图实例的缩放和拖拽事件\n* 监听到拖拽事件触发自定义事件 map-moved\n* 在父组件中分别获取到两个地图组件的实例，使用ref\n* 在父组件中的<mapBox>和<mapMidBox>监听到map-move的后,分别调用handelMapmove2和handelMapmove1\n* 在父组件中定义handelMapmove2和handelMapmove1函数，前者用于调整中间地图组件的中心和缩放等级，后者用于调整左边地图组件。\n* 分别在两个地图组件中定义setMapView函数，并暴露出来，这样父组件中才能使用$refs调用该方法\n\n```javascript\n//地图组件中代码\n//自定义事件\nconst setMapView = (center: L.LatLngExpression, zoom: number) => {\n  if (map.value) {\n    map.value.setView(center, zoom)\n  }\n}\n//暴露给父组件的方法\ndefineExpose({ setMapView })\n//注意vue3的写法\nconst emit = defineEmits(['map-moved'])\nonMounted(() => {\n  const mapInstance = initMap()\n  //等初始化完成后，强制地图重新计算大小和位置\n  nextTick(() => {\n    // 强制地图重新计算大小和位置\n    if (mapInstance){\n      mapInstance.invalidateSize();\n    }\n  });\n  mapInstance.on('zoomend dragend', () => {\n    emit('map-moved', { center: mapInstance.getCenter(), zoom: mapInstance.getZoom() })\n  })\n})\n```\n\n```javascript\n//父组件中代码\nconst mapBox1 = ref(null)\nconst mapBox2 = ref(null)\n\n//重置第二个子组件的center和zoom\nconst handelMapMoved2 = (e:any)=>{\n  if(mapBox2.value){\n    console.log(mapBox2.value.setMapView(e.center, e.zoom))\n  }\n}\nconst handelMapMoved1 = (e)=>{\n  if(mapBox1.value){\n    console.log(mapBox1.value.setMapView(e.center, e.zoom))\n  }\n\n}\n```\n\n## 踩到的坑们\n### setup\n1、在子组件的setup中定义的方法，在父组件中通过子组件实例（在父组件中的子组件标签中使用ref='ziname'）ziname.的方法无法调用，必须在setup中暴露出该方法才行；暴露的方法也踩了坑，由于使用ts，一直提示不能使用return暴露函数。应该使用defineExpose({ setMapView })\n\n2、地图总是加载左上角，因为组件的大小不是固定的px值，所以会发生变化，因此，需要在初始化完成后强制地图进行大小和位置计算。且在组件卸载后要清空地图的配置值。\n\n3、将地图配置对象mapValue设置成响应式对象，对导致第一个被初始化的地图能加载出地图，而另外一个不能。因此放弃了响应式配置值实现互动的方法。\n\n4、vue3中不能使用this，自定义方法，组件实例调用方法，均和vue2有差异\n```javascript\nconst emit = defineEmits(['map-moved'])\nmapInstance.on('zoomend dragend', () => {\n    emit('map-moved', { center: mapInstance.getCenter(), zoom: mapInstance.getZoom() })\n  })\n\nconst mapBox1 = ref(null)\nmapBox1.value.setMapView(e.center, e.zoom)\n```\n\n## 总结\n以为自己掌握了知识，实践中却有很多问题。学好底层逻辑有助于快速发现问题和解决问题\n\n\n","tags":["leaflet","地图","联动"],"categories":["开发","前端"]},{"title":"登录界面开发","url":"/2023/03/06/devlopment/登录界面开发/","content":"\n## 配置\n### 组件\n> 分别注册了两个组件，一个是login页面(src/views/login/index.vue)、另外一个是登陆后展示的layout页面(src/views/layout/index.vue)\n\n### 路由配置\n#### 配置路由(src/router/index.ts)\n>\n```javascript\n//引入createRouter和createWebHashHistory方法\nimport { createRouter, createWebHashHistory } from \"vue-router\";\n//创建router实例\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes:[\n    {\n      path:'/login',\n      component:()=>import('@/view/login/index.vue'),  //导入组件\n      name:'login',\n      meta:{\n        title:'登录',\n        hidden:true,\n        icon:'el-icon-s-home'\n      }\n    },\n    {\n      path:'/',\n      name:'layout',\n      component:()=>import('@/view/layout/index.vue'),\n      meta: {\n      title: '', //菜单需要的标题\n      hidden: false,\n      icon: '',\n    }\n  }\n  ],\n  //滚动行为，只有在history模式下才有用\n  // scrollBehavior(){\n  //   return{\n  //     left:0,\n  //     top:0\n  //   }\n  // }\n})\nexport default router\n```\n\n> `在 Vue Router 中，router 和 route 是两个不同的概念。`\n> - `router 是 Vue Router 的实例，它包含了一些方法和属性，如 push、> replace、go 等，用于控制路由的跳转和行为。你可以通过 this.$router 在 Vue 组件中访问到 router 实例。`\n> - `route 是当前激活的路由信息对象，它包含了当前路由的路径、参数、查询字符串等信息。你可以通过 this.$route 在 Vue 组件中访问到当前的 route 对象。`\n> - `router 和 route 的主要区别在于，router 是用于控制路由的跳转和行为的，而 route 是表示当前路由状态的信息对象。`\n> - `在大多数情况下，你可能需要使用 this.$router 来进行路由跳转，如 this.$router.push('/path')。而当你需要获取当前路由的信息，如路径、参数等，你可以使用 this.$route，如 this.$route.params.id。`\n\n#### 在app.vue中使用router-view\n\n```javascript\n<template>\n  <div class=\"outer\">\n    <router-view></router-view>\n  </div>\n</template>\n<script setup lang=\"ts\">\n\n</script>\n<style scoped lang=\"scss\">\n.outer{\n  width: 100vw;\n  height:100vh;\n  margin: 0px;\n  padding: 0px;\n}\n</style>\n```\n\n\n\n## 静态页面\n### el-row/el-col\n> 官网介绍：https://element-plus.org/zh-CN/component/layout.html\n\n```javascript\n<template>\n  <div class=\"login_box\">\n    <el-row>\n      {/* :span总和是24，各设置为12，那就是两列对半分。 */}\n      <el-col :span=\"12\" :xs=\"24\">\n        <el-form class=\"login_form\">\n          <h2>地表异常预警平台</h2>\n          <el-form-item prop=\"username\">\n            <el-input prefix-icon=\"User\"></el-input>\n          </el-form-item>\n          <el-form-item prop=\"password\">\n            <el-input type=\"password\" prefix-icon=\"Lock\"></el-input>\n          </el-form-item>\n          <el-form-item>\n            <el-button type=\"primary\" class=\"login_but\">登录</el-button>\n          </el-form-item>\n        </el-form>\n      </el-col>\n      <el-col :span=\"12\" :xs=\"0\"></el-col>\n    </el-row>\n  </div>\n</template>\n\n<script setup lang=\"ts\"></script>\n\n<style lang=\"scss\" scoped>\n.login_box {\n  width: 100%;\n  height: 100%;\n  background-image: url('../../assets/login/bg.gif');\n  background-size: cover;\n  .login_form {\n    position: relative;\n    padding: 40px;\n    width: 60%;\n    top: 30vh;\n    .login_but{\n      width: 100%;\n    }\n  }\n}\n</style>\n\n\n```\n### css\n```javascript\n<style lang=\"scss\" scoped>\n.login_box {\n  //能用100%是因为父盒子有定义width和height。这里的百分比是相对于父盒子的\n  //如果父盒子没有明确的width和height，那么百分比会失效\n  width: 100%;\n  height: 100%;\n  background-image: url('../../assets/login/bg.gif');\n  //cover和contain都会保持图片的宽高比，区别在于contain会留白，cover会完全覆盖，\n  //也就是cover会导致，图片某部分被裁剪\n  background-size: cover;\n  .login_form {\n    //position属性可能有static、realative、sbsolute、sticky和fixed\n    position: relative;\n    padding: 40px;\n    width: 60%;\n    top: 30vh;\n    .login_but{\n      width: 100%;\n    }\n  }\n}\n</style>\n\n```\npositon的值\n*  `static`：这是元素的默认值。静态定位的元素不会受到 `top`、`bottom`、`left`、`right` 的影响。\n* `relative`：元素按照正常的文档流进行定位，然后相对于它的正常位置进行偏移。偏移不会影响其他元素的位置。\n* `absolute`：元素脱离正常的文档流，并相对于最近的已定位父元素（`position` 属性为 `relative`、`absolute`、`fixed` 或 `sticky` 的元素）进行定位。如果没有已定位的父元素，那么它会相对于 `body` 元素进行定位。\n* `fixed`：元素脱离正常的文档流，并相对于浏览器窗口进行定位。即使页面滚动，它仍然会停留在同一的位置。\n* `sticky`：元素在滚动范围内表现为 `relative`，而在滚动范围外表现为 `fixed`。也就是说，元素会“粘”在特定位置，然后随着页面滚动。\n\n## 动态绑定\n### mock模拟服务器\n使用mock模拟后端\n* 安装mock\n  `pnpm i mockjs --save`\n* 模拟数据和服务\n  ```javascript\n  //导入mock库\n  import Mock from 'mockjs'\n  //模拟数据\n  const user = Mock.mock({\n    fixedUser: [\n      {\n        username: 'admin',\n        password: 'admin111',\n        avatar:\n          ' https://tse4-mm.cn.bing.net/th/id/OIP-C.NNF59vntIv7760rOlX1zMgAAAA?w=187&h=188&c=7&r=0&o=5&cb=10&dpr=1.2&pid=1.7'\n      },\n      {\n        username: 'user',\n        password: 'user111',\n        avatar:\n          'https://tse1-mm.cn.bing.net/th/id/OIP-C.D34PjxR7ud-vxeTDvs5Z8gAAAA?w=135&h=150&c=7&r=0&o=5&cb=10&dpr=1.2&pid=1.7'\n      }\n    ]\n  })\n\n  export default()=>{\n    Mock.mock('/api/login', 'post', (req: any) => {\n      const { username, password } = JSON.parse(req.body)\n      //从模拟数据中找\n      const userItem = user.fixedUser.find(\n        (item: any) => item.username === username && item.password === password\n      )\n      //如果用户数据在模拟数据中，return200，和token\n      if (userItem) {\n        return {\n          code: 200,\n          data: {\n            //返回用户名，用户头像和token\n            username: userItem.username,\n            avatar: userItem.avatar,\n            token: 'admin-token'\n          }\n        }\n      } else {\n        return {\n          code: 400,\n          message: '用户名或密码错误'\n        }\n      }\n    })\n  }\n  ```\n* 在main.ts中引入mock\n  ```javascript\n  import configureMockServer from './mock/user.ts';\n  configureMockServer()\n  ```\n### 新建仓库\n新建仓库用来存放用户数据，发起登录请求等\n* 安装pinia\n  `pnpm i pinia`\n\n* 新建一个大仓库（src/store/index.ts）\n  ```javascript\n  import {createPinia} from 'pinia'\n  const pinia = createPinia()\n  export default pinia\n  ```\n\n* 封装本地存储、获取和移除token的功能（src/utils/token）\n  ```javascript\n  //封装本地存储和读取数据的方法\n  //本地存储数据\n  export const SET_TOKEN = (token: string) => {\n    localStorage.setItem('TOKEN', token)\n  }\n  //本地存储获取数据\n  export const GET_TOKEN = () => {\n    return localStorage.getItem('TOKEN')\n  }\n  export const REMOVE_TOKEN = () => {\n    return localStorage.removeItem('TOKEN')\n  }\n  ```\n\n* 在main.ts中注册pinia\n  ```javascript\n  import pinia from './store'\n  app.use(pinia)\n  ```\n\n* 创建用户仓库\n  ```javascript\n  //存放用户数据的仓库\n  import { defineStore } from 'pinia'\n  import { reqLogin } from '@/api/user'\n  import { SET_TOKEN, GET_TOKEN, } from '@/utils/token'\n  export const userStore = defineStore({\n    id: 'user',\n    state: () => {\n      return {\n        token: GET_TOKEN(),\n        username: '',\n        avatar: ''\n      }\n    },\n    //异步操作\n    actions: {\n      //登录\n      async userLogin(data: any) {\n        const res = await reqLogin(data)\n        if (res.code === 200) {\n          //将用户名、头像存入仓库\n          this.username = res.data.username\n          this.avatar = res.data.avatar\n          //将token存入localStorage\n          SET_TOKEN(res.data.token)\n        } else {\n          //登录失败\n          return Promise.reject(new Error(res.message))\n        }\n      }\n    }\n  })\n  ```\n### 创建并暴露用户登录api\n在（src/api/user/index.ts）中书写相关代码\n```javascript\n//导入二次封装的axios\nimport request from '@/utils/request'\n\n// 枚举接口\nenum API{\n  LOGIN_URL = '/login'\n}\n//暴露登录接口\nexport const reqLogin = (data:any)=> request.post<any, any>(API.LOGIN_URL,data)\n```\n### v-model绑定\n* 双向绑定\n  ```javascript\n  <template>\n    <div class=\"login_box\">\n      <el-row>\n        <el-col :span=\"12\" :xs=\"24\">\n        {/* 使用ref获取el-form组件 */}\n          <el-form class=\"login_form\" :model=\"LoginForm\" :rules=\"rules\" ref=\"loginFormRef\">\n            <h2>我的平台</h2>\n            <el-form-item prop=\"username\">\n              {/* 使用v-model双向绑定 */}\n              <el-input prefix-icon=\"User\" v-model=\"LoginForm.username\"></el-input>\n            </el-form-item>\n            <el-form-item prop=\"password\">\n              <el-input type=\"password\" prefix-icon=\"Lock\" v-model=\"LoginForm.password\"></el-input>\n            </el-form-item>\n            <el-form-item>\n              {/* 绑定点击事件发起登录请求 */}\n              <el-button type=\"primary\" class=\"login_but\" @click=\"login\">登录</el-button>\n            </el-form-item>\n          </el-form>\n        </el-col>\n        <el-col :span=\"12\" :xs=\"0\"></el-col>\n      </el-row>\n    </div>\n  </template>\n  ```\n* 点击事件触发login\n\n  ```javascript\n  <script setup lang=\"ts\">\n  import { ref } from 'vue'\n  import { userStore } from '@/store/modules/user'\n  import {useRouter, useRoute} from 'vue-router'\n  import { ElNotification } from 'element-plus';\n  //新建一个loginForm用于收集表单数据\n  let LoginForm = ref({\n    username: '',\n    password: ''\n  })\n  //获取用户仓库\n  let ustore = userStore()\n  //获取路由器\n  let $router = useRouter()\n  let $route = useRoute()\n  //获取表单组件\n  let loginFormRef = ref()\n  const login = async()=>{\n    await loginFormRef.value.validate()\n    //登录逻辑\n    //首先，发起请求，将用户名和密码发送给后端\n    //然后，后端返回一个token，将token存储在本地\n    //最后，跳转到首页\n    try{\n      await ustore.userLogin(LoginForm.value)\n      //RU: 如果有redirect参数，就跳转到redirect，否则跳转到首页\n      let redirect: any = $route.query.redirect\n      $router.push({ path: redirect || '/' })\n      // 提示登录成功\n      ElNotification({\n        title: `欢迎回来${ustore.username}`,\n        message: '欢迎回来',\n        type: 'success'\n      });\n    } catch(error){\n\n      // 提示登录失败\n      ElNotification({\n        type: 'error',\n        message: (error as Error).message,\n      });\n    }\n  }\n\n  const validatorUsername = (rule:any , value:string, callback:any)=>{\n    if(value== undefined){\n      callback(new Error('用户名不能为空'))\n    }\n    if(value.length>=5 && value.length<=20){\n      callback()\n    }else{\n      callback(new Error('用户名必须是5-20位的字符串'))\n    }\n  }\n\n  const validatorPassword = (rule:any , value:string, callback:any)=>{\n    if(value== undefined){\n      callback(new Error('密码不能为空'))\n    }\n    if(value.length > 5){\n      callback()\n    }else{\n      callback(new Error('密码长度必须大于5位'))\n    }\n  }\n  //定义表达验证需要配置的对象\n  const rules = {\n    username: [\n      //validatorUsername在上面定义\n    {trigger:'blur', validator: validatorUsername}\n    ],\n    password: [\n      {trigger:'blur', validator:validatorPassword}\n    ]\n  }\n  </script>\n\n  ```\n\n### 规则校验\n使用elementPlus规定好的关键字，实现进入规则校验\n* 在表单中绑定rules属性为rules对对象\n  ```javascript\n  <el-form class=\"login_form\" :model=\"LoginForm\" :rules=\"rules\" ref=\"loginFormRef\">\n  ```\n* 在script中，定义表单验证的配置对象\n  ```javascript\n  //这点代码中定义的前两个对象用于rules对象中\n  const validatorUsername = (rule:any , value:string, callback:any)=>{\n    if(value== undefined){\n      callback(new Error('用户名不能为空'))\n    }\n    if(value.length>=5 && value.length<=20){\n      callback()\n    }else{\n      callback(new Error('用户名必须是5-20位的字符串'))\n    }\n  }\n\n  const validatorPassword = (rule:any , value:string, callback:any)=>{\n    if(value== undefined){\n      callback(new Error('密码不能为空'))\n    }\n    if(value.length > 5){\n      callback()\n    }else{\n      callback(new Error('密码长度必须大于5位'))\n    }\n  }\n  //定义表达验证需要配置的对象\n  const rules = {\n    username: [\n      //validatorUsername在上面定义\n      //失去焦点后触发\n    {trigger:'blur', validator: validatorUsername}\n    ],\n    password: [\n      {trigger:'blur', validator:validatorPassword}\n    ]\n  }\n  ```\n* 在登录点击事件中，发起请求之前先进行规则校验，校验通过后才能发起请求\n\n### 路由跳转\n登录成功后跳转到页面\n```javascript\nlet $router = useRouter()\nlet $route = useRoute()\n\n登录函数中：\n登录成功后：\n//如果有redirect参数，就跳转到redirect，否则跳转到首页\nlet redirect: any = $route.query.redirect\n$router.push({ path: redirect || '/' })\n```\n","tags":["登录","路由","css"],"categories":["开发","前端"]},{"title":"项目集成配置","url":"/2023/03/05/devlopment/项目集成配置/","content":"\n# 项目集成配置\n### 1、集成element-plus\n> 官网地址：https://element-plus.gitee.io/zh-CN/\n\n安装命令: `pnpm install element-plus @element-plus/icons-vue`\n\n```javascript\n//在入口文件中main.ts中全局安装element-plus\nimport ElementPlus from 'element-plus'\nimport 'element-plus/dist/index.css'\n////@ts-ignore忽略当前文件ts类型的检测否则有红色提示(打包会失败)\nimport zhCn from 'element-plus/es/locale/lang/zh-cn'\napp.use(ElementPlus, { locale: zhCn })\n```\n>同样别忘了把icon图标都注册成全局组件，注册方式和svg图标全局化的方式一样\n``` javascript\n import * as ElementPlusIconsVue from '@element-plus/icons-vue'\n```\n\n### 2、别名配置\n在开发项目时文件与文件关系很复杂，因此需要给src文件配置一个别名\n安装：`pnpm i --save-dev @types/path`\n```javascript\n//在vite.config.ts中配置\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport path from 'path'\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  resolve: {\n    alias: {\n      '@': path.resolve('./src') // 相对路径别名配置，使用 @ 代替 src\n    }\n  }\n  })\n```\n\n```json\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\", // 解析非相对模块的基地址，默认是当前目录\n    \"paths\": { //路径映射，相对于baseUrl\n      \"@/*\": [\"src/*\"]\n    }\n  }\n}\n```\n\n### 3、环境变量配置\n\n项目开发过程中，至少会经历 **开发环境、测试环境和生产环境(即正式环境)** 三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。\n\n项目根目录分别添加 开发、生产和测试环境的文件!\n\n```javascript\n.env.development\n.env.production\n.env.test\n```\n\n文件内容\n\n```javascript\n# 变量必须以 VITE_ 为前缀才能暴露给外部读取\nNODE_ENV = 'development'\nVITE_APP_TITLE = '硅谷甄选运营平台'\nVITE_APP_BASE_API = '/dev-api'\n```\n\n```javascript\nNODE_ENV = 'production'\nVITE_APP_TITLE = '硅谷甄选运营平台'\nVITE_APP_BASE_API = '/prod-api'\n```\n\n```javascript\n# 变量必须以 VITE_ 为前缀才能暴露给外部读取\nNODE_ENV = 'test'\nVITE_APP_TITLE = '硅谷甄选运营平台'\nVITE_APP_BASE_API = '/test-api'\n```\n\n配置运行命令：package.json\n\n```javascript\n \"scripts\": {\n    \"dev\": \"vite --open\",\n    \"build:test\": \"vue-tsc && vite build --mode test\",\n    \"build:pro\": \"vue-tsc && vite build --mode production\",\n    \"preview\": \"vite preview\"\n  },\n```\n\n通过import.meta.env获取环境变量\n\n### 4、SVG图标配置\n\n在开发项目的时候经常会用到svg矢量图,而且我们使用SVG以后，页面上加载的不再是图片资源,\n\n**安装依赖**  `pnpm install vite-plugin-svg-icons -D`\n\n在vite.config.ts中配置\n```javascript\nimport { createSvgIconsPlugin } from 'vite-plugin-svg-icons'\nimport path from 'path'\nexport default () => {\n  return {\n    plugins: [\n      createSvgIconsPlugin({\n        // 指定要缓存的图标文件夹\n        iconDirs: [path.resolve(process.cwd(), 'src/assets/icons')],\n        // 指定 symbolId 格式\n        symbolId: 'icon-[dir]-[name]',\n      }),\n    ],\n  }\n}\n```\n\nmain.ts入口文件中引入 `import 'virtual:svg-icons-register'`\n\n#### 将svg封装为全局组件\n步骤如下\n+ 创建一个Svgicon组件 src/components/SvgIcon.vue\n+ 在src/components文件夹下创建一个index.t文件，用于注册全部全局文件\n+ 在入口文件引入src/index.ts文件,通过app.use方法安装自定义插件\n\n```javascript\n// src/components/SvgIcon.vue\n<template>\n  <div>\n    <svg :style=\"{ width: width, height: height }\">\n      <use :xlink:href=\"prefix + name\" :fill=\"color\"></use>\n    </svg>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\ndefineProps({\n  //xlink:href属性值的前缀\n  prefix: {\n    type: String,\n    default: '#icon-'\n  },\n  //svg矢量图的名字\n  name: String,\n  //svg图标的颜色\n  color: {\n    type: String,\n    default: \"\"\n  },\n  //svg宽度\n  width: {\n    type: String,\n    default: '16px'\n  },\n  //svg高度\n  height: {\n    type: String,\n    default: '16px'\n  }\n\n})\n</script>\n<style scoped></style>\n```\n\n\n```javascript\n// src/componebts/index.ts\nimport SvgIcon from './SvgIcon/index.vue'\n//分页器\nimport Pagination from './Pagination/index.vue'\n//一个仓库\nimport Category from './Category/index.vue'\n//引入element-plus提供全部图标组件\nimport * as ElementPlusIconsVue from '@element-plus/icons-vue'\n//全局对象\nconst allGloablComponent: any = { SvgIcon, Pagination, Category }\n//对外暴露插件对象\nexport default {\n  //务必叫做install方法\n  install(app: any) {\n    //注册项目全部的全局组件\n    Object.keys(allGloablComponent).forEach((key) => {\n      //注册为全局组件\n      app.component(key, allGloablComponent[key])\n    })\n    //将element-plus提供图标注册为全局组件\n    for (const [key, component] of Object.entries(ElementPlusIconsVue)) {\n      app.component(key, component)\n    }\n  }\n}\n```\n\n```javascript\n// main.ts\nimport gloablComponent from './components/index';\napp.use(gloablComponent);\n```\n\n#### 5、集成sass\n安装sass和sass-loader: `pnpm install --save-dev sass sass-loader`\n\n接下来我们为项目添加一些全局的样式\n\n在src/styles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss\n```javascript\n@import reset.scss\n```\n但是你会发现在src/styles/index.scss全局样式文件中没有办法使用`$`变量.因此需要给项目中引入全局变量`$`.\n\n在./src/style 中创建一个variable.scss文件！ **在这里可以写入一些全局可用的样式变量。**\n\n在vite.config.ts文件配置如下:\n\n```javascript\nexport default defineConfig((config) => {\n\tcss: {\n      preprocessorOptions: {\n        scss: {\n          javascriptEnabled: true,\n          additionalData: '@import \"./src/styles/variable.scss\";',  //;不要忘记\n        },\n      },\n    },\n\t})\n```\n\n#### 6、axios二次封装\n安装：`pnpm install axios`\n\n在开发项目的时候避免不了与后端进行交互,因此我们需要使用axios插件实现发送网络请求。在开发项目的时候我们经常会把axios进行二次封装。\n\n>目的:\n>1:使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数)\n>2:使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理http网络错误)\n\n在根目录下创建utils/request.ts\n```javascript\nimport axios from \"axios\";\nimport { ElMessage } from \"element-plus\";\n//创建axios实例\nlet request = axios.create({\n    baseURL: import.meta.env.VITE_APP_BASE_API,\n    timeout: 5000\n})\n//请求拦截器\nrequest.interceptors.request.use(config => {\n    return config;\n});\n//响应拦截器\nrequest.interceptors.response.use((response) => {\n    return response.data;\n}, (error) => {\n    //处理网络错误\n    let msg = '';\n    let status = error.response.status;\n    switch (status) {\n        case 401:\n            msg = \"token过期\";\n            break;\n        case 403:\n            msg = '无权访问';\n            break;\n        case 404:\n            msg = \"请求地址错误\";\n            break;\n        case 500:\n            msg = \"服务器出现问题\";\n            break;\n        default:\n            msg = \"无网络\";\n\n    }\n    ElMessage({\n        type: 'error',\n        message: msg\n    })\n    return Promise.reject(error);\n});\nexport default request;\n```\n#### 7、API接口统一管理\n在src目录下创建api文件夹\n\n```javascript\n//示例\n//统一管理咱们项目用户相关的接口\n\nimport request from '@/utils/request'\n\nimport type {\n\n loginFormData,\n loginResponseData,\n userInfoReponseData,\n\n} from './type'\n\n//项目用户相关的请求地址\n\nenum API {\n LOGIN_URL = '/admin/acl/index/login',\n USERINFO_URL = '/admin/acl/index/info',\n LOGOUT_URL = '/admin/acl/index/logout',\n\n}\n//登录接口\nexport const reqLogin = (data: loginFormData) =>\n request.post<any, loginResponseData>(API.LOGIN_URL, data)\n//获取用户信息\n\nexport const reqUserInfo = () =>\n\n request.get<any, userInfoReponseData>(API.USERINFO_URL)\n\n//退出登录\nexport const reqLogout = () => request.post<any, any>(API.LOGOUT_URL)\n```","tags":["Element Plus","配置","全局组件"],"categories":["开发","前端"]},{"title":"数组的方法","url":"/2022/12/02/es6/forEach,map,filter,reduce/","content":"\n# 数组的方法\n## some\n检测数组中所有元素是否满足制定条件，满足返回true，否则false\n\n该方法依次检测数组中每个元素。如果有一个元素满足条件，则返回true，剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false\n\n一真即真\n\n⚠️注意：some()不对空数组进行检测、some()不改变原数组。\n\n## every\n检测数组中所有元素是否符合指定条件，符合返回true，否则false\n\n该方法根据指定条件检测数组中所有元素。如果监测到有一个元素不满足，则返回false，且剩余元素不会再次检测。如果所有条件都满足则返回true。\n\n一假即假 ，而且只要有一个元素是假，其后面的元素将不再遍历\n\n⚠️注意：every()不对空数组进行检测、every()不改变原数组。\n> https://juejin.cn/post/6996892724100562974\n\n## forEach\nforEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。\n>forEach(): 没有返回值，本质上等同于 for 循环，对每一项执行 function 函数。map是返回一个新数组，原数组不变，forEach 是不改变原数组（尽管回调函数 callbackFn 在被调用时可能会改变原数组）。\n>不支持 continue，用 return false 或 return true 代替。\n>不支持 break，用 try catch/every/some 代替。\n\n```javascript\narr = [1,2,3,4,5,6]\narr.forEach(item=>console.log(item)) //1 2 3 4 5 6\n//实现 continue\narr.forEach((item)=>{\n  if (item == 3){\n    return;\n  }\n  console.log(item)  //1 2 4 5 6\n})\narr.some((item)=>{\n  if(item == 3){\n    return;\n  }\n  console.log(item)\n})\n//实现break\narr.every((item)=>{\n  if(item == 3){\n    return false;\n  }\n  else{\n    console.log(item)\n    return true\n  }\n})\n\ntry {\n  arr.forEach((item) => {\n    if (item == 3) {\n      throw new Error('wrong')\n    }\n    console.log(item)\n  })\n} catch (e) {\n  console.log(e)\n}\n```\n<hr>\n\n## map\nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\n返回值是一个新数组，每个元素都是回调函数的结果。\n```javascript\n// 语法：\nvar new_array = arr.map(function callback(currentValue[, index[, array]]) {\n    // Return element for new_array\n}[, thisArg])\n// 参数：\n// callback 生成新数组元素的函数，使用三个参数：\n// currentValue callback 数组中正在处理的当前元素。\n// index可选 callback 数组中正在处理的当前元素的索引。\n// array可选 callback map 方法被调用的数组。\n// thisArg可选 执行 callback 函数时使用的this 值。\n\narr = ['1', '2',' 3', '4', '5', '6']\nconst arry = arr.map( str => parseInt(str))\nconsole.log(arry)\n```\n> https://blog.csdn.net/qq_43437571/article/details/95634526\n\n## filter\n和map类似，Array的filter也接收一个函数。但是和map不同的是， filter把传入的函数依次作用于每个元素，然后根据返回值是 true 还是false决定保留还是丢弃该元素。\n\nfilter 接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：\n\n```javascript\nvar arr = ['A', 'B', 'C'];\nvar r = arr.filter(function (element, index, self) {\n console.log(element); // 依次打印'A', 'B', 'C'\n console.log(index); // 依次打印0, 1, 2\n console.log(self); // self就是变量arr\n return true;\n});\n\n//巧用filter进行数组去重\narr = [1, 2, 3, 3, 4, 5, 2, 6, 1, 7]\nconst r = arr.filter((item, index, self) => {\n  if (self.indexOf(item) === index) {\n    return true\n  }\n})\nconsole.log(r)\n```\n> https://blog.csdn.net/qq_39207948/article/details/80357367\n\n## reduce\n![图 0](../../images/3c7bad2c6a9f2f0176022e4394c8d3dd8c8a2a2ae668bfa3c7428769835fac0f.png)\n\n> https://blog.csdn.net/qq_43441476/article/details/105559561","tags":["数组方法"],"categories":["基础","es6"]}]